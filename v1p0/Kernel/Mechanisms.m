(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Mechanisms`",{"Developer`"}];


$MechanismsVersion::usage = "$MechanismsVersion returns the version number of the package.";
$MechanismsVersionText::usage = "$MechanismsVersionText returns the version number of the package as a string.";

$MechanismsVersion=1;
$MechanismsVersionText="Mechanisms version 1.0b";

(* 
	We use MeshRegion in this package to work so make sure we are using at least version 10 of Mathematica
*)
Mechanism::usage = "Keyword used to report some errors.";

Mechanism::version="Mathematica version may be too low.";
Mechanism::paclet="Mathematica version may be too low to install Paclet.
Fix by changing Paclet[] to PacletObject[] in the file PacletInfo.m";
Which[ $VersionNumber<11, Message[Mechanism::version] , $VersionNumber<13, Message[Mechanism::versionpaclet]];


MechanismCellTypes::usage = "MechanismCellTypes[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns all mechanism cell types in a mechanism.
MechanismCellTypes[] returns all possible mechanism cell types.";

(*mechanism cells*)
RigidBar::usage="RigidBar[ {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)} ] is a rigid bar. Use DefaultCellProperties[ RigidBar ] to see its associated data.";
Spring::usage="Spring[ {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)} ] is a Spring allowing you to set an arbitrary force. Use DefaultCellData[ Spring ] to see its associated data.";
Face::usage="Face[ {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] is a Face. Use DefaultCellProperties[ Face ] to see its associated data.";
SpringFace::usage="SpringFace[ {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] is a Face that expands to a face with spring sides.";
ElasticTriangle::usage="ElasticTriangle[ {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] is an elastic Face. Use DefaultCellProperties[ Face ] to see its associated data.";
TorsionalFold::usage="TorsionalFold[ {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)} ] is a TorsionalFold with torsional Spring controlling its angle. Use DefaultCellProperties[ TorsionalFold ] to see its associated data.";
FreeJoint::usage="FreeJoint[\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)] is a free joint.";
AngleJoint::usage="AngleJoint[{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)}] is a torsional spring attached to a joint \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\). Use DefaultCellProperties[ AngleJoint ] to see its associated data.";
PinnedJoint::usage="PinnedJoint[\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)] is a pinned FreeJoint. Use DefaultCellProperties[ PinnedJoint ] to see its associated data.";
StraightJoint::usage="StraightJoint[{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)}] maintains a straight joint \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\) between two other vertices. Use DefaultCellProperties[ StraightJoint ] to see its associated data.";

(*an extra type*)
AnyJoint::usage="AnyJoint is a pattern that matches either a PinnedJoint or a FreeJoint.";

DefaultCellProperties::usage="DefaultCellProperties[ \!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"type\",\nFontSlant->\"Italic\"]\) ] returns the default properties associated with a cell type.
All cells also take the properties \"Style\", \"Shape\", and \"Label\", which act like MeshCellStyle, MeshCellShapeFunction, and MeshCellLabel.";


CellPattern::usage="CellPattern is an option in the Mechanisms package to specify patterns for cells.";


MechanismVertexCells::usage="MechanismVertexCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns all cells associated with vertices.
MechanismVertexCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...}] returns a list of all vertex cells with indices \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...
MechanismVertexCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] returns a list of all vertex cells output by \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)]";
MechanismEdgeCells::usage="MechanismEdgeCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns all cells associated with edges.
MechanismEdgeCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}, ...}] returns a list of all edge cells with indices {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}, ...}
MechanismEdgeCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] returns a list of all edge cells output by \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)]";
MechanismFaceCells::usage="MechanismFaceCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns all cells associated with faces.
MechanismFaceCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2, \\\  ... \)]\)}, ...}] returns a list of all face cells with indices {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2, \\\  ... \)]\)}, ...}.
MechanismFaceCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] returns a list of all face cells output by \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)]";


(*Basic elements of a mechanism and checks*)
MechanismFaces::usage="MechanismFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns a list of Faces in the Mechanism.
MechanismEdgeIndex[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}, ...} ] returns an index with the location the specific edge {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}, ...} would appear in a list of all edges.
MechanismFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] returns a list of face indices associated with \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)].";

MechanismEdges::usage="MechanismEdges[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns a list of edges in the Mechanism.
MechanismFaceIndex[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...}, ...} ] returns an index with the location the specific face {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...}, ...} would appear in a list of all edges.
MechanismEdges[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] returns a list of edges indices associated with \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)].";

MechanismVertices::usage="MechanismVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns a list of vertices in the mechanism.
MechanismVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the integer indices of a list of vertices.";

MechanismCells::usage = "MechanismCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns a list of all cells of the form {celltype1[ {i1, i2, ...} ], ...}.
MechanismCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\)] returns a list of cells matching \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\).
MechanismCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"dataType\",\nFontSlant->\"Italic\"]\) -> \!\(\*
StyleBox[\"dataPattern\",\nFontSlant->\"Italic\"]\)] returns cells matching \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\) having \!\(\*
StyleBox[\"dataType\",\nFontSlant->\"Italic\"]\) whose value matches \!\(\*
StyleBox[\"dataPattern\",\nFontSlant->\"Italic\"]\).
MechanismCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tag\",\nFontSlant->\"Italic\"]\)] returns the indices associated with a string \!\(\*
StyleBox[\"tag\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)";

MechanismVertexQ::usage="MechanismVertexQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2, \\\  ... \)]\)}] returns True if all vertices are in the mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";
MechanismEdgeQ::usage="MechanismEdgeQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}, ...}] returns True if all edges are in the mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";
MechanismFaceQ::usage="MechanismFaceQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2, \\\  ... \)]\)}, ...}}] returns True if all Faces are in the mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";

ValidMechanismEdgeQ::usage="ValidMechanismEdgeQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}, ...}] returns True if all edges could be an edge in mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";
ValidMechanismFaceQ::usage="ValidMechanismFaceQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2, \\\  ... \)]\)}, ...}] returns True if all Faces could be a Face in mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";

ValidMechanismCellQ::usage="ValidMechanismCellQ[ \!\(\*
StyleBox[\"cellSpec\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"cellSpec\",\nFontSlant->\"Italic\"]\) is a properly specified cell.
ValidMechanismCellQ[] returns a pattern that can be used to test if a cell has a valid specification.";
ValidMechanismCellHeadQ::usage="ValidMechanismCellHeadQ[ \!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\) is a cell type. Use MechanismCellTypes[] to see a list of cell types.";


VertexPosition::usage=
"VertexPosition[\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\)] represents the position of vertex \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) along a particular component \!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\).
\!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\) is one of \"x\", \"y\", \"z\" or All[\!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\)] where \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\) is the number of dimensions.
VertexPosition[{\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(3\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)...}, {\!\(\*SubscriptBox[
StyleBox[\"c\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"c\",\nFontSlant->\"Italic\"], \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\) ...}] expands to a list of vertex positions.";
SetAttributes[VertexPosition,{NHoldAll,Constant}]

VertexDisplacement::usage=
"VertexDisplacement[\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\)] represents the displacement of vertex n along a particular component c.
\!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\) is one of \"x\", \"y\", \"z\" or All[\!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\)] where \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\) is the number of dimensions.
VertexDisplacement[{\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(3\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)...}, {\!\(\*SubscriptBox[
StyleBox[\"c\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"c\",\nFontSlant->\"Italic\"], \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\) ...}] expands to a list of vertex displacements.";
SetAttributes[VertexDisplacement,{NHoldAll,Constant}]

MechanismPositions::usage=
"MechanismPositions[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns the coordinates of the vertices of mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).
MechanismPositions[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) ] returns a new Mechanism with coordinates given by positions.";


Linkage::usage = "Linkage[ {{\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\)},...}, {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)[ {\!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(2\)]\), ..} ], ... } ] returns a linkage in 2D with vertices at { {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\)},...} and made from the specified cells.
Linkage[ {{\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[SubscriptBox[\"z\", \"1\"],\nFontSlant->\"Italic\"]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*
StyleBox[SubscriptBox[\"z\", \"2\"],\nFontSlant->\"Italic\"]\)},...}, {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)[ {\!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(2\)]\), ..} ], ... } ] returns a linkage in 3D with vertices at {{x1, y1}, ..} and made from the specified cells.

Use Linkage[\"Examples\"] to list some examples that can be accessed by Linkage[ \!\(\*
StyleBox[\"example\",\nFontSlant->\"Italic\"]\) ] to generate it.

Properties:\n
Cell properties can be specified by Property[ \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)[ {\!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(2\)]\), ..} ], {\!\(\*SubscriptBox[
StyleBox[\"property\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"value\",\nFontSlant->\"Italic\"], \(1\)]\), ... } ].
Properties are \"Style\", \"Shape\" (to specify a shape function), \"Label\". MechanismCellTypes[\!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\)] will list additional properties that can be specified for a cell.

Options:\n
Linkage[] takes the option OverlapPrecision which determines how close vertices need to be in order to be mapped onto each other. This could be set to 0 (or None).";

Origami::usage=
"Origami[ {{\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\)},...}, {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)[ {\!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(2\)]\), ..} ], ... } ] returns an Origami in 3D (displayed in 2D) with vertices at {{\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\)},...} and made from the specified cells.
Origami[ {{\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[SubscriptBox[\"z\", \"1\"],\nFontSlant->\"Italic\"]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*
StyleBox[SubscriptBox[\"z\", \"2\"],\nFontSlant->\"Italic\"]\)},...}, {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)[ {\!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(2\)]\), ..} ], ... } ] returns an Origami in 3D with vertices at {{\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[SubscriptBox[\"z\", \"1\"],\nFontSlant->\"Italic\"]\)}, {\!\(\*SubscriptBox[
StyleBox[\"x\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"y\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*
StyleBox[SubscriptBox[\"z\", \"2\"],\nFontSlant->\"Italic\"]\)},...} and made from the specified cells.

Use Origami[\"Examples\"] to list some examples that can be accessed by Origami[ example ].

Properties:\n
Cell properties can be specified by Property[ \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)[ {\!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"i\",\nFontSlant->\"Italic\"], \(2\)]\), ..} ], {\!\(\*SubscriptBox[
StyleBox[\"property\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"value\",\nFontSlant->\"Italic\"], \(1\)]\), ... } ].
Properties are \"Style\", \"Shape\" (to specify a shape function), \"Label\". MechanismCellTypes[\!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\)] will list additional properties that can be specified for a cell.\n

Options:

Origami[] takes the option OverlapPrecision which determines how close vertices need to be in order to be mapped onto each other. This could be set to 0 (or None).";

MechanismQ::usage="MechanismQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) is a Mechanism.";


ToLinkage::usage=
"ToLinkage[\!\(\*
StyleBox[\"obj\",\nFontSlant->\"Italic\"]\)] attempts to create a Linkage from some other object (e.g. Graph[], MeshRegion[], etc.). It takes the same options as Linkage[].
ToLinkage[\!\(\*
StyleBox[\"obj\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"rules\",\nFontSlant->\"Italic\"]\) ] attempts to create a Linkage using a list of rules of the form {Point \[RightArrow] FreeJoint, Line \[RightArrow] RigidBar, Polygon \[RightArrow] Face} to assign elastic objects. The rules are not checked for errors.";

ToOrigami::usage=
"ToOrigami[ \!\(\*
StyleBox[\"object\",\nFontSlant->\"Italic\"]\) ] converts an object to an Origami Mechanism. Effectively, this only works for some MeshRegion[] or Linkage[] objects.";


OverlapPrecision::usage="OverlapPrecision is an option that indicates how close points have to be to be considered identical.";


(*cell modifiers*)
TagCells::usage= "TagCells[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\){\!\(\*SubscriptBox[
StyleBox[\"index\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"index\",\nFontSlant->\"Italic\"], \(2\)]\),...} ] ] adds a data tag to the indices.
TagCells[\!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\){\!\(\*SubscriptBox[
StyleBox[\"index\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"index\",\nFontSlant->\"Italic\"], \(2\)]\),...}] ] is a version that can be applied to a mechanism.";

LabelVertices::usage="LabelVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"labels\",\nFontSlant->\"Italic\"]\) ] adds \!\(\*
StyleBox[\"labels\",\nFontSlant->\"Italic\"]\) to the vertices of a mechanism.
labels can be \"Name\", \"Index\", None, a list {\!\(\*SubscriptBox[
StyleBox[\"label\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[SubscriptBox[\"label\", \"2\"],\nFontSlant->\"Italic\"]\), ...} for all vertices or a list of rules {\!\(\*SubscriptBox[
StyleBox[\"vertex\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"label\",\nFontSlant->\"Italic\"], \(1\)]\), ...}";

SelectCells::usage=
"SelectCells[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*
StyleBox[SubscriptBox[\"cell\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)} ] selects a sub-Mechanism with cell specification matching pattern.";

DeleteCells::usage="DeleteCells[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*
StyleBox[SubscriptBox[\"cell\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)} ] deletes a subset of cells in a mechanism.";

AddCells::usage="AddCells[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*
StyleBox[SubscriptBox[\"cell\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)} ] adds cells to a mechanism.";

SubdivideCells::usage="SubdivideCells[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\) ] adds a vertex to a cell at its centroid named by \!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\). cell has the form {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),...}
SubdivideCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...}, \!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\)] subdivides a list of cells, naming the new vertices a variation of \!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\).";

DivideFaces::usage="DivideFaces[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}} ] divides a face along diagonal {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\)}. The new faces match the orientation of their parent face.
DivideFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*
StyleBox[SubscriptBox[\"e\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"e\",\nFontSlant->\"Italic\"], \(2\)]\), ...}] divides several faces along the listed edges read from left to right.";

DivideEdges::usage="DivideEdges[ m, edges ] adds a vertex at the center of each edge.
DivideEdges[ m, edges , label] adds a vertex named by label to the center of each specified edge.

The function breaks up associated faces appropriately.";

TriangulateFaces::usage="TriangulateFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] triangulates all Faces along the shortest diagonal recursively, leaving triangles alone.";

PlaceVertices::usage="PlaceVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"pos\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] moves vertices to new positions.
PlaceVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), { \!\(\*SubscriptBox[
StyleBox[\"pos\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"pos\",\nFontSlant->\"Italic\"], \(2\)]\), ... } ] replaces all vertex positions by a list of new positions.";

DisplaceVertices::usage="DisplaceVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"disp\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] displaces vertices by a displacement.
DisplaceVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), { \!\(\*SubscriptBox[
StyleBox[\"disp\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"disp\",\nFontSlant->\"Italic\"], \(2\)]\), ... } ] displaces all vertices by a list of displacements.
DisplaceVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) ] changes a mechanism with positions {\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"],\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[SubscriptBox[\"p\", \"2\"],\nFontSlant->\"Italic\"]\), ...} to one with \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[{\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"],\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[SubscriptBox[\"p\", \"2\"],\nFontSlant->\"Italic\"]\), ...}].";

MapVertices::usage="MapVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] applies \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) to every vertex position and returns a new mechanism.
MapVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),...}] replaces vertex positions {p1,p2,...} with {\!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"],\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[SubscriptBox[\"v\", \"1\"],\nFontSlant->\"Italic\"]\)], \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*
StyleBox[SubscriptBox[\"p\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"2\"],\nFontSlant->\"Italic\"]\)], ...}.
MapVertices[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\), {{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(11\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(12\)]\), ...}, {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(21\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(22\)]\), ...}, ...} ] replaces vertex positions with {f[\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"],\nFontSlant->\"Italic\"]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(21\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(22\)]\), ...], f[\!\(\*
StyleBox[SubscriptBox[\"p\", \"2\"],\nFontSlant->\"Italic\"]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(21\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(22\)]\), ...], ...}";

DeleteVertices::usage="DeleteVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),...} ] deletes a list of vertices and all cells associated with those vertices.";

MapCells::usage="MapCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] applies a map \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) to each of the cells of a mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";
ReplaceCells::usage="ReplaceCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] applies rules \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) to the cells of a mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";

JoinMechanism::usage="JoinMechanism[ \!\(\*
StyleBox[SubscriptBox[\"m\", \"1\"],\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[SubscriptBox[\"m\", \"2\"],\nFontSlant->\"Italic\"]\), ... ] joins a list of Mechanisms of the same type together.";


ChangeCellData::usage="ChangeCellData[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"head\",\nFontSlant->\"Italic\"]\)[ {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ], \!\(\*
StyleBox[\"dataSpec\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\)] modifies the data of specific cells in mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).
ChangeCellData[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"dataSpec\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\)] uses \!\(\*
StyleBox[\"f\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) to generate a list of cells to change.

\!\(\*
StyleBox[\"dataSpec\",\nFontSlant->\"Italic\"]\) is either appropriate data specification for the cells or one of \"Style\", \"Shape\", or \"Label\".

\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\) can be one of three things:
	{\!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(2\)]\), ...}
	a single element is evaluated as a list of identical data
	a function \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) is evaluated as the data {\!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\)], \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)[\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\)], ...}";


AddOption::usage="AddOption[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"key\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"value\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] adds a list of options to a mechanism, flattening the options.
AddOption[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"key\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"value\",\nFontSlant->\"Italic\"], \(1\)]\), ...} , \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\)] adds a list of options to a mechanism, using function \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) to merge.

You can also use KeyExistsQ[] and Delete[] to test and delete options.";


TesselateMechanism::usage=
"TesselateMechanism[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"primitive\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"vector\",\nFontSlant->\"Italic\"]\), \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\) ], TesselateMechanism[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\)}],  TesselateMechanism[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(3\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(3\)]\)}] tesselates a mechanism using a set of 2D or 3D primitive vectors as an \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\) x \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(1\)]\) x \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\) x \!\(\*SubscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(3\)]\)} celled mechanism.";


(*Example linkages*)
PinnedFourBarLinkage::usage="PinnedFourBarLinkage[{\!\(\*
StyleBox[\"width\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"height\",\nFontSlant->\"Italic\"]\)}] represents a pinned, four-bar linkage with a given \!\(\*
StyleBox[\"width\",\nFontSlant->\"Italic\"]\) and \!\(\*
StyleBox[\"height\",\nFontSlant->\"Italic\"]\).";
ChainLinkage::usage="ChainLinkage[\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\), {\!\(\*
StyleBox[\"start\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"end\",\nFontSlant->\"Italic\"]\)}] represents a chain of n bars between a \!\(\*
StyleBox[\"start\",\nFontSlant->\"Italic\"]\) and \!\(\*
StyleBox[\"end\",\nFontSlant->\"Italic\"]\). Endpoints are vertex 1 and 2.";
PolygonalLinkage::usage="PolygonalLinkage[\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] represents a polygonal linkage in 2D with n equal length segments.";
WattLinkage::usage="WattLinkage represents a Watt linkage with equal length bars.
WattLinkage[ \!\(\*
StyleBox[\"l\",\nFontSlant->\"Italic\"]\) ] represents a Watt linkage with middle bar of length \!\(\*
StyleBox[\"l\",\nFontSlant->\"Italic\"]\).";
ConnellyServatiusLinkage::usage="ConnellyServatiusLinkage represents the ConnellyServatius linkage with cusp singularity.";
Connelly2ndOrderRigidLinkage::usage="Connelly2ndOrderRigidLinkage represents Connelly's example of a 2nd order rigid linkage that is not prestress stable.";
PeaucellierLinkage::usage="PeaucellierLinkage represents the Peaucellier linkage with a vertex that moves along a straight line. Changing the distance between fixed joints changes the trajectory to a curved arc.";
Pantograph::usage="Pantograph[\!\(\*
StyleBox[\"length\",\nFontSlant->\"Italic\"]\)], Pantograph[] represents a Pantograph (a copying mechanism).";

(*Example origami*)
BirdsFoot::usage="BirdsFoot represents a single bird's foot origami.
BirdsFoot[ \!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\) ] represents a bird's foot with an interior angle \!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\).";
SingleVertex::usage="SingleVertex[ {\!\(\*SubscriptBox[
StyleBox[\"a\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"a\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] represents a single vertex with sector angles {\!\(\*SubscriptBox[
StyleBox[\"a\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"a\",\nFontSlant->\"Italic\"], \(2\)]\), ...}";
RandlettBirdOrigami::usage="RandlettBirdOrigami represents an unfolded Randlett bird. RandlettBirdOrigami[\"Folded\"] represents a folded version of the Randlett bird.";
WaterBombBase::usage="WaterBombBase represents a unit cell of the water bomb base origami.";
MiuraOriCell::usage="MiuraOriCell[\!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\)] represents the unit cell of a Miura ori origami with vertical folds offset from vertex by \!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\).
MiuraOriCell[x, \"Triangulated\"] is a triangulated Miura ori unit cell with vertical folds offset from vertex by \!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\).";
SteffanPolyhedron::usage="SteffanPolyhedron[], SteffanPolyhedron[\!\(\*
StyleBox[\"t\",\nFontSlant->\"Italic\"]\)] represents a Steffan polyhedron origami with angle \!\(\*
StyleBox[\"t\",\nFontSlant->\"Italic\"]\). The Steffan polyhedron is a non-convex polyhedron that can flex.
Its evaluation is partially numeric but the equilibirum edge lengths are given exactly.";

KagomeUnitCell::usage="KagomeUnitCell[] represents a unit cell for a Kagome lattice. The lattice vectors are {2 Sqrt[3],0},{Sqrt[3],3}}.
KagomeUnitCell[ s ] represents a unit cell for a Kagome lattice whose size is rescaled by s.";


Begin["`Private`"];


$meshRegionProperties={MeshCellStyle -> "Style", MeshCellLabel -> "Label" , MeshCellShapeFunction -> "Shape"};

packedCellPattern = {_[_,_]...};
labelPattern = {___Rule};

coordinatePattern2D = {{_, _}..};
coordinatePattern3D = {{_, _, _}..};
coordinatePattern = coordinatePattern2D | coordinatePattern3D;


mechanismPattern = (Linkage|Origami)[ coordinatePattern, _ , packedCellPattern, labelPattern , _Association ];

MechanismQ[ mechanismPattern ]:=True
MechanismQ[_]:=False


(*define how the indices work for these types of cells*)
vertexCells = {FreeJoint , PinnedJoint } ;
edgeCells = {RigidBar , Spring , TorsionalFold };
faceCells = { Face };
angleCells = { AngleJoint , StraightJoint, ElasticTriangle (*this is really a triangular face*)};

$MechanismCellTypes = Join[ vertexCells, edgeCells, faceCells, angleCells ];


(*some cells should expand*)
cellParsingExpansionRules = {
	Face[ i_ , properties_ ] :> { Face[ i , properties ], RigidBar[ #, properties ] & /@ Partition[ i , 2, 1, 1 ] },
	Polygon[ i_ , properties_ ] :> Face[ i , properties ],
	SpringFace[i_, properties_ ] :> { Face[ i , properties ], Spring[ #, properties ] & /@ Partition[ i , 2, 1, 1 ] },
	StraightJoint[i_List, properties_ ] :> { FreeJoint[i[[2]] , properties], StraightJoint[i, properties]}
};


(* default data in all cell types *)
DefaultCellProperties[RigidBar] = {"EquilibriumLength" -> Automatic, "Stiffness" -> Infinity};
DefaultCellProperties[Spring] = {"EquilibriumLength" -> Automatic, "Stiffness" -> Infinity, "Strain" -> "LinearStrain"};
DefaultCellProperties[Face] = { "FaceStiffness"->0};
DefaultCellProperties[ElasticTriangle] = { "YoungsModulus" -> Infinity , "PoissonRatio" -> 1/3 };
DefaultCellProperties[TorsionalFold] = { "TorsionalStiffness" -> Infinity, "Angle" -> Automatic};
DefaultCellProperties[FreeJoint] = {};
DefaultCellProperties[PinnedJoint] = { "PinningStiffness" -> Infinity, "ConstraintFunction" -> Automatic };
DefaultCellProperties[AngleJoint] = {"AngleStiffness" -> Infinity, "Angle" -> Automatic };
DefaultCellProperties[StraightJoint] = {"Distance" -> Automatic, "AngleStiffness"->Infinity};
DefaultCellProperties[_String] = {};

DefaultCellProperties[ head_ ] := (Message[Mechanism::cellerr, head]; {})
Mechanism::cellerr="Cell type `1` is not recognized.";


(*pattern for all possible cell heads*)
celltypePattern = Alternatives @@ Flatten[{vertexCells, edgeCells, faceCells , angleCells }];

(*pattern for cells*)
inputCellPattern = 
	Alternatives[
		(Alternatives@@edgeCells)[ { Except[_List] , Except[_List] } ],
		(Alternatives@@vertexCells)[ Except[_List] ],
		(Alternatives@@faceCells)[ _?VectorQ ],
		(Alternatives@@angleCells)[ {Except[_List],Except[_List],Except[_List]} ]
	];

(*pattern for cells with integer indices only*)
exactCellPattern =
	Alternatives[
		(Alternatives@@edgeCells)[ { _Integer , _Integer } ],
		(Alternatives@@vertexCells)[ _Integer ],
		(Alternatives@@faceCells)[ _?(VectorQ[#,IntegerQ]&) ],
		(Alternatives@@angleCells)[ {_Integer, _Integer, _Integer} ]
	];

ValidMechanismCellHeadQ[ cell_ ] := MatchQ[ cell, celltypePattern ]
ValidMechanismCellQ[ cell_ ] := MatchQ[ cell, exactCellPattern ]


dataForm[ head_ ]:= Join[DefaultCellProperties[head][[All,1]], {"Shape","Label","Style"}]


(*take a list of cells with elements of the form

	head[ index , data ]

and combine them into a compressed form for storage.
*)
packCells[ cells : {_[_,_]...} ] :=
	With[ { groupedCells = GatherBy[ Flatten[preparseCellsForStorage /@ cells], Head ] },
		packCellsOfSameType[  Head[#[[1]]] , #[[All,1]], #[[All,2]] ]& /@ groupedCells
	]

packCellsOfSameType[ s_String, indices_, data_ ] := s[ToPackedArray[indices],{}]
packCellsOfSameType[ head_Symbol, indices_, data_ ] := 
	head[
		ToPackedArray[indices] , 
		compressCellData[ head, data ]
	]


preparseCellsForStorage[ head_[ indices_, properties_ ] ] := With[ 
{ 
rules = (# -> _ &) /@ dataForm[head], 
untagged = DeleteCases[ Flatten @ {properties}, _String ]
},
	{
		#[indices,{}]& /@ Cases[ Flatten@{properties}, _String ], (*tag cells look like this*)
		head[indices, FilterRules[ untagged, rules ] ] (*remove bad properties from mechanism cells*)
	}
]

Mechanism::badprop = "Properties `1` do not exist for cell `2`.";


compressCellData[ head_ , data_ ] :=
With[
	{
		mergedData = Merge[#, Flatten[#]&]& /@ data,
		default = FilterRules[ DefaultCellProperties[head], "Style" ],
		cellData = DefaultCellProperties[head][[All,1]],
		defaultValues = DefaultCellProperties[head][[All,2]] /. Automatic -> "Automatic"
	},
	Join[
		MapThread[
			combineData[ #1, #2 , mergedData, Last ]&,
			{
			cellData,
			defaultValues
			}
		],
		{
			combineData[ "Shape", "Automatic", mergedData , Last],
			combineData[ "Label", None, mergedData , Last],
			combineDataList[ {}, "Style" /. mergedData /. default /. "Style"->{} ]
		}
	]
]

(*combine data presented as a list*)
combineDataList[ default_ , data_  ] := (Last /@ GatherBy[ Flatten[{default, #} ], directiveQ ])& /@ data
directiveQ[ _?ColorQ|_Hue|_RGBColor|_GrayLevel|_CMYKColor|_LCHColor|_LUVColor|_XYZColor ] := "color"
directiveQ[ x_ ] := Head[x]

(*combine single atom data*)
combineData[ dataType_, DefaultCellProperties_, data_ , f_ ] := 
	SparseArray[
		f /@ (dataType /. data /. {dataType -> {DefaultCellProperties}} /. Automatic -> "Automatic"),
		Length[data],
		DefaultCellProperties
	]


unpackCells[ cells : packedCellPattern ] := Flatten[unpackCellsOfOneType /@ cells]

unpackCellsOfOneType[ s_String[ indices_ ] ] := s /@ indices

unpackCellsOfOneType[ head_Symbol[ indices_, data_ ] ] :=
	MapThread[
		head,
			{
			indices,
			Transpose @ uncompressCellData[ head, indices, data ]
			}
	]

uncompressCellData[ head_ , indices_, data_ ] :=
With[ { dataNames=dataForm[head] , length = Length[indices] },
	MapThread[ Thread[ ConstantArray[#1, length] -> #2 ] &, {dataNames , data}]
]


(*do a regular ReplaceAll on just cell indices*)
replaceCellIndices[ cells : packedCellPattern , rules_ ] := Head[#][ ReplaceAll[ #[[1]], rules ], #[[2]] ]& /@ cells


(*do a regular ReplaceRepeated on just cell indices*)
replaceRepeatedCellIndices[ cells : packedCellPattern , rules_ ] := Head[#][ ReplaceRepeated[ #[[1]], rules ], #[[2]] ]& /@ cells


(*do a ReplaceAll on the data stored in a type of cell*)
replaceCellData[ cells : packedCellPattern, rules_ ] := Head[#][ #[[1]], replaceElement[ #, rules ] & /@ #[[2]] ]& /@ cells

(*(*
from: https://mathematica.stackexchange.com/questions/13790/using-replaceall-on-sparsearray
*)
replaceElement[s_SparseArray, rule_] := With[
    {
    elem = ReplaceAll[s["NonzeroValues"], rule],
    def = ReplaceAll[s["Background"], rule]
    },

    Replace[
        s,
        Verbatim[SparseArray][a__, _, {b__, _}] \[RuleDelayed] SparseArray[a, def, {b, elem}]
    ]
]*)
replaceElement[ s_SparseArray, rule_ ] := ((#/.rule)&/@s)
(*
if the data isn't a SparseArray
*)
replaceElement[ s_, rule_ ] := ReplaceAll[ s, rule ]


(*Sort cells of one type by a sorting function*)
sortCellType[ head_[ indices_, data_ ], sortingFunction_ : Identity ]:=With[
{ order = OrderingBy[ indices, sortingFunction ] },
	head[ indices[[ order ]], #[[ order ]]& /@ data ]
]


(*
sort cells of one type by a list of integers
This function should technically also allow deleting cells not listed.
*)
orderCellType[ head_[indices_,data_ ], ordering_ ] :=
	head[ indices[[ ordering ]], #[[ ordering ]]& /@ data ]


(*this function unpacked arrays*)
deleteDuplicateCells[ cells : packedCellPattern ] := deleteDuplicateCells /@ cells
deleteDuplicateCells[ head_[ indices_, data_ ] ] := Module[
{
indexList = DeleteDuplicatesBy[
		Transpose[ { Range[ Length[indices] ], indices } ], 
		Sort[Flatten[{Last[#]}]]& 
	][[All,1]] 
},
	head[ ToPackedArray @ indices[[ indexList ]], #[[ indexList ]]& /@ data ]
]


deleteDegenerateCells[ cells : packedCellPattern ] := deleteDegenerateCells /@ cells
deleteDegenerateCells[ head_[ indices_, data_ ] ] :=
With[ { id = Pick[ Range[Length[indices]], DuplicateFreeQ[Flatten[{#}]]& /@ indices] },
	head[ indices[[id]], #[[id]]&/@data ]
]


deleteOutOfRangeCells[ range_ , cells : packedCellPattern ] := Transpose[ deleteOutOfRangeCells[range, # ]& /@ cells ]
deleteOutOfRangeCells[ range_ , head_[ indices_, data_ ] ] :=
With[ {selector = And[Min[#] > 0, Max[#] <= range, IntegerQ[#] || VectorQ[#,NumericQ]]& /@ indices},
	With[ { id = Pick[ Range[Length[indices]], selector ] , badid = Pick[ Range[Length[indices]], selector , False]},
		{head[ indices[[id]], #[[id]]& /@ data ], head /@ indices[[badid]]}
	]
]


joinCells[ cells_ ] := joinCellType /@ GatherBy[ Flatten[cells], Head ]

joinCellType[ cells : packedCellPattern ] :=
With[ { head = Head[cells[[1]]], indices = cells[[All,1]], data = cells[[All,2]]},
	sortCellType @ deleteDegenerateCells @ deleteDuplicateCells @ head[ Join @@ indices , Join @@@ Transpose[ data ] ]
]


facePattern = Alternatives @@ Flatten[{faceCells,SpringFace, Polygon}] ;
edgePattern = Alternatives @@ Flatten[{edgeCells}] ;
vertexPattern = Alternatives @@ Flatten[{vertexCells}];
anglePattern = Alternatives @@ Flatten[{angleCells}];
cellSpecPattern = facePattern|edgePattern|vertexPattern|anglePattern|_String ;


edgeLoopQ = (VectorQ[#] && Length[#]>2 &) ;
faceListQ = (VectorQ[#, VectorQ]&) ;
tripleListQ = (MatrixQ[#] &) ;

distributePropertyRules = {
	(h : facePattern|edgePattern|vertexPattern|anglePattern)[ indices_ ] :> h[indices, {} ],
	(h : cellSpecPattern)[ indices_, properties_Rule ] :> h[indices, {properties} ],
	Property[ h_List, properties_ ] :> (Property[ #, properties ]& /@ h),
	Property[ ( h : cellSpecPattern)[ indices_, properties_ ] , newProperties_ ] :> h[indices, Flatten[ { properties, newProperties } ] ],
	(h : vertexPattern)[ indices_?VectorQ , properties_ ] :> (  h[ # , properties ]& /@ indices  ),
	(h : edgePattern)[ indices_?faceListQ , properties_ ] :> (  h[ # , properties ]& /@ indices  ),
	(h : edgePattern)[ indices_?edgeLoopQ , properties_ ] :> (  h[ # , properties ]& /@ Partition[indices,2,1] ),
	(h : facePattern)[ indices_?faceListQ , properties_ ] :> (  h[ # , properties ]& /@ indices  ),
	(h : anglePattern)[ indices_?tripleListQ , properties_ ] :> ( h[ # , properties ]& /@ indices ),
	(h : vertexPattern)[ label_ -> coordinates_ , properties_ ] :> { h[ label, properties ], add[ label , coordinates ] }
};

(*this should be applied to the top level after everything else has been processed.*)
tagExpansionRules = {
	(h : _String)[ indices_ ] :> h[indices, {} ]
};

coordinateRules[coords_?MatrixQ] := With[{max = Length[coords], dim = If[Length[coords]>0, Length[coords[[1]]], 0]},
	{
	VertexPosition[ n_Integer , "x" ] /; (0<n<=max) :> coords[[n,1]],
	VertexPosition[ n_Integer , "y" ] /; (0<n<=max) :> coords[[n,2]],
	VertexPosition[ n_Integer , "z" ] /; (0<n<=max && dim == 3) :> coords[[n,3]]
	} /; dim >= 2
]


simplifyBadCell[ head_[x_, y___] ] := head[x]
simplifyBadCell[ head_ ] := head


properCellPattern= (vertexPattern)[ Except[_List], _ ] | (edgePattern)[ _?(VectorQ[#]&&Length[#]==2&), _ ] | (facePattern)[ _?(VectorQ[#]&&Length[#]>2&) , _]|(anglePattern[_?(VectorQ[#]&&Length[#]==3&),_])|_String[_,_];

parseCells[ cells_List ] := parseCells[ {{},{},{}}, cells ]
parseCells[ {oldcoordinates_, oldcells_ , oldlabels_}, cells_List ] := 
Module[{ expandedCells , goodCells, badCells, newcoordinates , labels, newlabels, coordinateCells},
	expandedCells = Replace[ Flatten @ ReplaceAll[ Flatten @ ReplaceRepeated[ Flatten[cells], distributePropertyRules] , cellParsingExpansionRules ], tagExpansionRules, 1];
	coordinateCells = Cases[ expandedCells , add[_,_] ];
	goodCells = Cases[ expandedCells, properCellPattern ];

	(*if there are bad cells, report a warning*)
	badCells = simplifyBadCell /@ DeleteCases[ expandedCells, properCellPattern|_add ];
	If[Length[badCells]>0, Message[Mechanism::badcells, badCells ] ];

	(*any vertices that got added as cells get taken care of here*)
	{  labels , newcoordinates } = If[ Length[coordinateCells] > 0,
		Transpose[ List @@@ coordinateCells] ,
		{ {}, {} }
	];

	newlabels = Join[
		oldlabels,
		Thread[ labels -> Range[ Length[oldcoordinates] + 1 , Length[oldcoordinates] + Length[newcoordinates] ] ]
	];

	{
		(* new coordinates *)
		ToPackedArray @ PadRight[Join[ oldcoordinates, newcoordinates /. coordinateRules[oldcoordinates] ]],
		(* cells *)
		sortCellType /@ joinCells[ Flatten @ {replaceCellIndices[ packCells[ goodCells ], Dispatch @ newlabels], oldcells } ],
		newlabels
	}
]


Mechanism::badcells = "Cells `1` cannot be parsed and will be ignored.";


unparseCells[ cells : packedCellPattern , head : _ ] := Flatten[ unparseCellType /@ Pick[ cells, Head/@cells, head ] ]

unparseCellType[ head_[ indices_ , {} ] ] := head /@ indices
unparseCellType[ head_[ indices_ , data_ ] ] :=
With[{
	dataRules = Thread[ dataForm[head] -> # ]& /@ Transpose[data]
},
	MapThread[ head[#1,#2]&, { indices, dataRules } ]
]


cellPattern[ r_ ] := With[ {groupedByHead = GatherBy[ Flatten[ recursiveCellPattern[ r ] ], Head ]},
	Head[#[[1]]][ If[ Head[#]===List&&Length[#]>1,Alternatives, Identity] @@ #[[All,1]] ]& /@ groupedByHead
]

recursiveCellPattern[ None ] := {None[None]}
recursiveCellPattern[ r_Alternatives ] := recursiveCellPattern /@ (List@@r)
recursiveCellPattern[ x_Blank ] /; Length[x]==0 := {_[_]}
recursiveCellPattern[ x_Blank ] := recursiveCellPattern[x[[1]][ _ ]]
recursiveCellPattern[ x_String ] := {x[_]}
recursiveCellPattern[ AnyJoint[ ind_ ] ] := recursiveCellPattern /@ {FreeJoint[ ind ], PinnedJoint[ ind ]}
recursiveCellPattern[ head_[ ind_Alternatives ] ] := recursiveCellPattern[ head[#] ]& /@ (List@@ind)
recursiveCellPattern[ head_Alternatives[ ind_ ] ] := recursiveCellPattern[ #[ind]]&/@ (List@@head)
recursiveCellPattern[ head_[ ind_ ] ] := {head[ indexPattern[ ind ] ]}
recursiveCellPattern[patt : _Pattern] := (Message[Mechanism::err, patt]; {})

(*anything that cannot be made sense of as a pattern for cells*)
recursiveCellPattern[ head : _Rule|_Symbol|_?NumericQ ] := (Message[Mechanism::err, head]; { None[None] })

indexPattern[ x_Blank ] := x
indexPattern[ r_Alternatives ] := indexPattern /@ r
indexPattern[ n_List ] := With[ { numbers = Range[Length[n]] }, Alternatives @@ Map[ RotateRight[n,#]&, numbers ] ]
indexPattern[ n : Except[_Alternatives|_List] ] := n

Mechanism::err = "`1` is not a properly formed cell pattern.";


casesCellType[ pattern_ , head_[ indices_ , data_ ] ] := Pick[ Range[Length[indices]], head/@indices , Alternatives @@ pattern ]
selectCellType[ f_ , head_[ indices_ , data_ ] ] := Pick[ Range[Length[indices]], f[head[#]]& /@ indices ]

identifyCellFromList[ headSpec_ , indexList_?VectorQ , head_[ indices_?VectorQ, data_ ] ] :=
With[ { table = Association @@ Thread[ Rule[indices , Range[Length[indices]] ] ]},
	DeleteMissing[ table /@ indexList ]
] /; MatchQ[head, headSpec]

identifyCellFromList[ headSpec_ , indexList : {___List} , head_[ indices : {___List}, data_ ] ] :=
With[ { table = Association @@ Thread[ Rule[ Sort /@ indices , Range[Length[indices]] ] ]},
	DeleteMissing[ table /@ (Sort /@ indexList) ]
]/; MatchQ[head, headSpec]
identifyCellFromList[ _ , indexList_, head_[ _, _ ] ] := {}

casesCellFromDataType[ dataSpec_ -> dataPattern_ , head_[ indices_, data_ ] ] := With[ { datalist = dataForm[head] },
With[ { dataIndex = dataSpec /. Thread[datalist -> Range[Length[datalist]]] },
	If[ IntegerQ[dataIndex], 
		Pick[ Range[Length[indices]], Normal@data[[ dataIndex ]] /. "Automatic"->Automatic, dataPattern ],
		{}
	]
]]
selectCellFromDataType[ dataSpec_ -> selector_ , head_[ indices_, data_ ] ] := With[ { datalist = dataForm[head] },
With[ { dataIndex = dataSpec /. Thread[datalist -> Range[Length[datalist]]] },
	If[ IntegerQ[dataIndex], 
		Pick[ Range[Length[indices]], selector /@ (data[[ dataIndex ]] /. "Automatic"->Automatic) ],
		{}
	]
]]


identifyCellFromList2[ headSpec_ , indexList_?VectorQ , head_[ indices_?VectorQ, data_ ] ] :=
With[ { table = Association @@ Thread[ Rule[indices , Range[Length[indices]] ] ]},
	{Pick[ Range[Length[indexList]], Not[MissingQ[#]]&/@# ],DeleteMissing[#]} & @ (table /@ indexList)
] /; MatchQ[head, headSpec]

identifyCellFromList2[ headSpec_ , indexList : {___List} , head_[ indices : {___List}, data_ ] ] :=
With[ { table = Association @@ Thread[ Rule[ Sort /@ indices , Range[Length[indices]] ] ]},
	{Pick[ Range[Length[indexList]], Not[MissingQ[#]]&/@# ],DeleteMissing[#]} & @(table /@ (Sort /@ indexList))
]/; MatchQ[head, headSpec]
identifyCellFromList2[ _ , indexList_, head_[ _, _ ] ] := {{},{}}


removeCells[ deletedCells : {___Integer}, head_[indices_, data_] ] :=
With[
{
	remainingCells = Complement[ Range[ Length[indices] ] , deletedCells ]
},
	If[ Length[remainingCells] == 0,
		{},
		head[
			indices[[remainingCells]],
			data[[All, remainingCells]]
		]
	]
]


takeCells[ remainingCells : {___Integer}, head_[indices_, data_] ] :=
	If[ Length[remainingCells] == 0,
		{},
		head[
			indices[[remainingCells]],
			data[[All, remainingCells]]
		]
	]


(*
ChangeCellData[ {c1,c2,...}, {head, dataType}, {data1, data2, ...}, cells ] replaces the old data (of type dataType) for cells indexed by c1, ... with data1, ...
ChangeCellData[ {c1,c2,...}, {head, dataType}, {data}, cells ] replaces the old data (of type dataType) for cells indexed by c1, ... all with data.
ChangeCellData[ {c1,c2,...}, {head, dataType}, dataFunc, cells ] replaces the old data (of type dataType) for cells indexed by c1, ... by applying dataFunc to the old data.
*)

changeCellDataInternal[ changingCells : {___Integer}, spec : {_ , _}, specifiedData_List, cells : packedCellPattern ] := 
	changeCellDataType[ changingCells, spec, specifiedData, # ]& /@ cells

changeCellDataType[ changingCells : {___Integer}, {headSpec_, dataSpec_}, specifiedData_ , headSpec_[ indices_ , data_ ] ] :=
With[ {
length = Length[indices],
newData = If[ ListQ[specifiedData] && Length[specifiedData]==1 && Length[changingCells]>1,  (*it is a list with one element but there are more cells*)
	ConstantArray[specifiedData, Length[changingCells]], 
	specifiedData
	],
	dataIndex = dataSpec /. Thread[dataForm[headSpec] -> Range[Length[dataForm[headSpec]]]]
},
	If[ IntegerQ[dataIndex],
		With[ { changedCells = Select[ changingCells, 0 < # <= length&] (*these are the cells within range*)},
			If[Length[changedCells]>0,
				headSpec[
					indices,
					ReplacePart[ data, dataIndex -> changeData[ 
							changedCells, 
							data[[ dataIndex ]], 
							(*if its a list, use it, if not map it*) If[ListQ[newData], newData, newData /@ data[[ dataIndex ]] ] 
							] ]
				],
				headSpec[ indices, data ]
			]
		],
		headSpec[indices,data]
	]
]

changeCellDataType[ changingCells : {___Integer}, {headSpec_, dataSpec_}, newData_ , spec : _[ _ , data_ ] ] := spec


cleanupData[data_List] := data[[-1]]
cleanupData[data : Except[_List]]:= data

changeData[ changedCells : {___Integer}, data_SparseArray, newdata_] :=
Module[ {
	processedData = cleanupData/@newdata /. Automatic -> "Automatic",
	processedIndices = List /@ changedCells,
	newRules
},
	newRules = Thread[ processedIndices -> processedData ];
	SparseArray[ Join[ newRules , FilterRules[ArrayRules[ data ], Except[newRules]] ] , Length[ data ] ]
]

changeData[ changedCells : {___Integer}, data : {__List}, newdata_ ] :=
Module[ {
	processedData = ArrayRules[ "data" /@ data ],
	processedIndices = Thread[ (List /@ changedCells) -> MapThread[ "data"[mergeDataList[#1,#2]]&, {data[[ changedCells ]], newdata /. Automatic -> "Automatic"} ] ]
},
	Normal[ SparseArray[ Join[ processedIndices, processedData] , Length[data] ] ][[All,1]]
]

changeData[ changedCells : {___Integer}, data_List, newdata_ ] :=
With[ {
	processedData = ArrayRules[ "data" /@ data ],
	processedIndices = Thread[ (List /@ changedCells) -> MapThread[ "data"[#2]&, {data[[ changedCells ]], newdata /. Automatic -> "Automatic"} ] ]
},
	Normal[ SparseArray[ Join[ processedIndices, FilterRules[processedData, Except[processedIndices]]] , Length[data] ] ][[All,1]]
]



mergeDataList[ data1_ , data2_  ] := Last /@ GatherBy[ Flatten[{data1, data2} ], directiveQ ]


mapCellsInternal[ f_, cells : packedCellPattern ] := mapCellType[f, #]& /@ cells
mapCellType[ f_, celltype : _[_,_] ] := parseCells[ f /@ unparseCells[celltype] ][[2]]


replaceCellsInternal[ f_, cells : packedCellPattern ] := replaceCellTypeInternal[f, #]& /@ cells
replaceCellTypeInternal[ f_, celltype : _[_,_] ] := parseCells[ unparseCells[celltype] /. f ][[2]]


(*formatting outputted lists of cells*)
$cellOutputFormats={"Threaded","Unthreaded", "Index"};
validOutputFormatQ[data_] := MatchQ[data, Alternatives @@ $cellOutputFormats]

outputCells[ pattern_, cells : packedCellPattern ] := outputCellType["Threaded", pattern, #]& /@ cells
outputCells[ outputFormat_ , pattern_, cells : packedCellPattern ] := outputCellType[outputFormat, pattern, #]& /@ cells

(*there is no data to display*)
outputCellType[ _, _, head_[indices_,{}] ] := head[indices]
(*matches no data*)
outputCellType[ _, None, head_[indices_, data_] ] := head[indices]

(*just output the indices*)
outputCellType[ "Index", _ , head_[indices_,data_]] := indices
(*only output data that matches a particular pattern*)
outputCellType[ "Unthreaded", pattern_, head_[indices_,data_] ] := 
	head[indices] -> FilterRules[ Thread[ dataForm[head] -> Normal[data] ], pattern] /. "Automatic" -> Automatic

outputCellType[ _, pattern_, head_[indices_, data_] ] := (*this is the default -- "Threaded"*)
With[
{
	dataRules = Transpose[ Thread /@ FilterRules[ Thread[ dataForm[head] -> data ], pattern] ] /. "Automatic"->Automatic
},
	head[indices] -> dataRules
]


replaceRules[ {}, appliedRules__ ] := {}

replaceRules[ rules_, appliedRules_ ] := replaceRules[ rules, appliedRules, 1 ]

replaceRules[ rules : {__Rule}, appliedRules_, 1 ] := 
With[ { flippedRules = Transpose[ List @@@ rules ] },
	Rule @@@ Transpose[ { Replace[ flippedRules[[1]] , appliedRules, {1} ], flippedRules[[2]] } ]
]

replaceRules[ rules : {__Rule}, appliedRules_, 2 ] := 
With[ { flippedRules = Transpose[ List @@@ rules ] },
	Rule @@@ Transpose[ { flippedRules[[1]], Replace[ flippedRules[[2]] , appliedRules, {1} ] } ]
]


removeOverlappingCoordinates[ head_[coordinateList_, mr_, cells_, labels_, rest_], None|0]:=
	head[
		ToPackedArray[coordinateList],
		mr,
		deleteDuplicateCells @ cells,
		labels,
		rest
	]

removeOverlappingCoordinates[ head_[coordinateList_, mr_, cells_, labels_ , rest_], precision : _?(NumericQ[N[#]] && N[#]>0 &) : 10^(-12)]:=
Module[
{
	numberedVertices=Transpose[{ Range @ Length @ coordinateList, coordinateList }],
	gatheredVertices,rules
},
	gatheredVertices=GatherBy[
		numberedVertices,
		(*they are the same if they are the same within the specified precision.*)
		Rationalize[N[#[[2]]], precision]&
	];
	rules=Dispatch @ Flatten[ (*two levels to thread through*)
		Thread /@ Thread[gatheredVertices[[All,All,1]] -> Range[Length[gatheredVertices]] ]
	];

	head[
		ToPackedArray[#[[1,2]]& /@ gatheredVertices],
		mr,
		deleteDuplicateCells @ replaceCellIndices[cells,rules],
		replaceRules[ labels, rules, 2 ],
		rest /. rules
	]
]


deleteDegenerateCellsFromMechanism[ head_[coordinates_, mr_, cells_, labels_, rest_] ] :=
	head[ coordinates, mr, deleteDegenerateCells[cells], DeleteDuplicates[Reverse[labels]], rest]


deleteImpossibleCellsFromMechanism[ head_[coordinates_, mr_, cells_, labels_, rest_] ] :=
	With[ {splitCells = deleteOutOfRangeCells[ Length[coordinates], cells]},
		If[Length[Flatten[splitCells[[2]]]]>0, Message[Mechanism::badcells, Flatten[splitCells[[2]]] ]];
		head[ coordinates, mr, splitCells[[1]] , labels, rest ]
	]


missingVertices[ numberOfVertices_ , cells_ ] := With[ 
{
	freeJoints = Cases[ cells, _FreeJoint|_PinnedJoint ]
},
	If[ Length[ freeJoints ] == 0, 
		Range[numberOfVertices],
		Complement[ Range[numberOfVertices], Flatten[ freeJoints[[All,1]] ] ]
	]
]


(*choose your own dimension*)
addMeshRegion[ head_[ coordinates_?MatrixQ , _ , cells : packedCellPattern , labels_ , rest_], Automatic, options_ ] :=
With[ {dim = chooseDimension[ head, coordinates ] },
	head[
		coordinates , 
		createMeshRegion[ head, PadRight[ coordinates, {Length[coordinates] , dim} ], cells , options, labels, rest], 
		cells,
		labels,
		rest
	]
]

addMeshRegion[ head_[ coordinates_?MatrixQ , _ , cells : packedCellPattern , labels_, rest_ ], dimSpec_, options_ ] :=
	head[
		coordinates ,
		createMeshRegion[ head, PadRight[ coordinates, {Length[coordinates], dimSpec} ], cells , options, labels, rest], 
		cells, 
		labels,
		rest
	]

addMeshRegion[ x_, __ ] := x

chooseDimension[ Origami, coordinates_ ] := If[ coordinates[[All,3]] . coordinates[[All,3]] < 10^(-12), 2, 3 ] /; Length[ coordinates[[1]] ] == 3
chooseDimension[ head_, coordinates_ ] := Length[ coordinates[[1]] ]


stripTextWrapper[labels_] := ReplaceAll[ labels , Text[x_,___] :> x]

createMeshRegion[ head_, coordinates_?(MatrixQ[#,NumericQ]&) , cells : packedCellPattern, options_ , labels_ : {}, rest_ : {} ] := With[ {
 displayCells = toDisplayCells[head, #]& /@ cells
},
	MeshRegion[ coordinates , Flatten[ displayCells[[All,1]] ],
		Flatten @ Join[{
		MeshCellLabel ->  Join[(*Point[#[[2]]]->#[[1]]& /@ labels,*) stripTextWrapper[ Flatten[ displayCells[[All,4]] , 1 ] ]],
		MeshCellStyle ->  Flatten[ displayCells[[All,2]] , 1 ],
		MeshCellShapeFunction ->  Flatten[ displayCells[[All,3]] , 1 ],
		Method->{CoplanarityTolerance->100, DeleteDuplicateCoordinates->False},
		options
		}]
	]
]
createMeshRegion[ head_, coordinates_ , cells : packedCellPattern, options__ ] := {}


cellMeshPrimitive[ RigidBar|Spring|TorsionalFold, _ ] := Line
cellMeshPrimitive[ FreeJoint | PinnedJoint ,_] := Point
cellMeshPrimitive[ Face | ElasticTriangle ,_] := Polygon
cellMeshPrimitive[ _ ,_] := None

toDisplayCells[mechType_, head_[ indices_, data_ ] ]:=
Module[ {
dataLocations = PositionIndex[dataForm[head]] , 
primitive = cellMeshPrimitive[ head, mechType ], primitives
},
	If[ primitive =!= None,
		primitives = primitive /@ indices;
		{
			primitives,
			toMeshCellStyle[ mechType, head, primitives, data , dataLocations["Style"] ],
			toMeshCellShapeFunction[ mechType, head, primitives, data , dataLocations["Shape"] ],
			toMeshCellLabel[ mechType, head, primitives, data , dataLocations["Label"] ]
		},
			
		{{},{},{},{}}
	]
]


defaultMeshStyle[ RigidBar|TorsionalFold, _ ] := {CapForm["Round"],Black}
defaultMeshStyle[ Spring ,_] := {Black}
defaultMeshStyle[ FreeJoint | PinnedJoint ,_] := {Black}
defaultMeshStyle[ Face ,_] := {GrayLevel[0.85]}
defaultMeshStyle[ ElasticTriangle ,_] := {RGBColor[{0.85,0.85,0.95}]}
defaultMeshStyle[ _ ,_] := {}

toMeshCellStyle[ mechType_, head_, prims_, data_ , {index_}]:= With[
{
	styles = data[[ index ]],
	defaultStyle = defaultMeshStyle[ head, mechType ]
},
	DeleteCases[ MapThread[ #1 -> Directive@@Flatten[ {defaultStyle , #2} ]& , {prims, styles} ] , _ -> _?(Length[#]==0&) ]
]


toMeshCellLabel[ mechType_, head_, prims_, data_, {index_} ] := With[
{
	labels = data[[ index ]]
},
	DeleteCases[ Thread[prims -> labels] , _ -> None ]
]


defaultMeshShapeFunction[ Spring , _] := Mechanisms`graphics`SpringShape[]
defaultMeshShapeFunction[ PinnedJoint , Linkage] := Mechanisms`graphics`PinnedJointShape[]
defaultMeshShapeFunction[ _ ,_] := "Automatic"

toMeshCellShapeFunction[ mechType_, head_, prims_, data_, {index_} ] := With[
{
	labels = Normal[data[[ index ]]] /. "Automatic" -> defaultMeshShapeFunction[ head, mechType ]
},
	cleanupShapeFunction /@ DeleteCases[ Thread[prims -> labels] , _ -> "Automatic" ]
]

cleanupShapeFunction[ cell_ -> None ] := cell -> None
cleanupShapeFunction[ rule : _ -> _Function ] := rule
cleanupShapeFunction[ cell_ -> shape_ ] := cell -> (shape[#1,#3,#2[[1]]]&)


Mechanism::meshfail="`1` has non-numeric coordinates.";


inputForm[m : mechanismPattern] := 
With[{
	graphicsRules={"Shape"->Automatic, "Style"->{}, "Label"->None},
	cells = cleanupInputFormCells /@ Flatten[ (unparseCellType /@ m[[3]]) /. "Automatic" -> Automatic]
},
	SequenceForm[Linkage][ MechanismPositions[m] , groupAllCells[ cells ] ]
]

cleanupInputFormCells[cell_[indices_]]:=cell[indices]
cleanupInputFormCells[ cell_[indices_, properties_] ] := With[{
	defaultProperties = Join[DefaultCellProperties[cell], {"Shape"->Automatic,"Label"->None,"Style"->{}}]
},
	cell[ indices, Sort[ Select[ properties , Not[MemberQ[defaultProperties, #]]& ] ] ]  /. c_[n_,{}] -> c[n]
]

groupAllCells[ cells_ ] := Flatten[groupCellsOfOneType /@ GatherBy[ cells , Head ]]
groupCellsOfOneType[ cells_ ] := groupIdenticalCells /@ Flatten[ GatherBy[#, If[Length[#]>1,Last[#], 0]&]& /@ GatherBy[ cells , Length ], 1]
groupIdenticalCells[ cells_ ] := If[ Length[cells[[1]]]>1, Head[cells[[1]]][cells[[All,1]],cells[[1,2]]], Head[cells[[1]]][cells[[All,1]]] ]


Options[Linkage] = Flatten[{OverlapPrecision -> 10^(-12) , Options[MeshRegion]}];

Linkage[ f : Linkage[ _?MatrixQ, _, packedCellPattern, labelPattern , _Association] , opt : OptionsPattern[] ] :=
With[ {meshOptions = FilterRules[{opt}, Options[MeshRegion] ]},
	addMeshRegion[
		deleteImpossibleCellsFromMechanism @ deleteDegenerateCellsFromMechanism @ removeOverlappingCoordinates[ f, OptionValue[OverlapPrecision] ],
		Automatic,
		meshOptions
	]
]

Linkage[ coordinateSpec_, cellSpec_ , opt : OptionsPattern[] ] :=
Module[
{
meshOptions = FilterRules[ {opt}, Options[MeshRegion] ],
intermediateParsing = parseCells[ {coordinateSpec, {}, {} }, {cellSpec} ],
numberOfCoordinates, coordinates, cells, labels
},
	numberOfCoordinates = Length[intermediateParsing[[1]]];
	{coordinates, cells, labels} = parseCells[ intermediateParsing, FreeJoint /@ missingVertices[numberOfCoordinates, intermediateParsing[[2]]] ];

	addMeshRegion[
		deleteImpossibleCellsFromMechanism @ deleteDegenerateCellsFromMechanism[
			removeOverlappingCoordinates[
				Linkage[ coordinates, {}, cells, labels, <||> ],
				OptionValue[OverlapPrecision]
			]
		],
		Automatic,
		meshOptions
	]
] /; LinkagePrecisionQ[ OptionValue[ OverlapPrecision ] ]

Mechanism::precision = "Precision `1` must be a non-negative number or None.";
LinkagePrecisionQ[ None|0 ] := True
LinkagePrecisionQ[ prec_?(NumericQ[#]&&#>0 &) ] := True
LinkagePrecisionQ[ prec_ ] := (Message[Mechanism::precision, prec]; False)


Linkage[coordinates_?MatrixQ, mr : _MeshRegion|{} , packedCellPattern, labelPattern, _Association ]["Methods"] := 
	{
	"MechanismType",
	"VertexCoordinates", 
	"MeshRegion", 
	"Cells", 
	"labels",
	"LabeledVertices", 
	"EmbeddingDimension", 
	"DisplayDimension",
	"VertexCount",
	"EdgeRules","FaceRules",
	"edges",
	"faces"
	}

(*direct accessors of the data*)
Linkage[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern, _Association ]["MechanismType"] := Linkage
Linkage[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association ]["VertexCoordinates"] := coordinates
Linkage[ coordinates_?MatrixQ, _, cells : packedCellPattern, labelPattern , _Association]["Cells"] := cells
Linkage[ coordinates_?MatrixQ, _, packedCellPattern, labels : labelPattern , _Association]["labels"] := labels
(*can we get a mesh?*)
Linkage[ coordinates_?MatrixQ, mr_MeshRegion, packedCellPattern, labelPattern , _Association]["MeshRegion"] := mr
Linkage[ coordinates_?MatrixQ, {}, cells : packedCellPattern, labels : labelPattern , rest_Association]["MeshRegion"] := 
With[{ mesh=createMeshRegion[ Linkage, coordinates, cells, {}, rest ]},
	If[MeshRegionQ[mesh],mesh, Message[Mechanism::meshfail,Linkage]; $Failed ]
]

Linkage[ coordinates_?MatrixQ, _ , packedCellPattern, labelPattern , rest_Association ]["addendum"] := rest
Linkage[ coordinates_?MatrixQ, mr_ , cells : packedCellPattern, labels : labelPattern , rest_Association ]["addendum", new_] := Linkage[coordinates,mr,cells,labels, new]

Linkage[ coordinates_?MatrixQ, mr_, cells : packedCellPattern, labels : labelPattern, rest_Association ]["exists", option_ ] := KeyExistsQ[ rest , option ]
Linkage[ coordinates_?MatrixQ, mr_, cells : packedCellPattern, labels : labelPattern, rest_Association ]["value", option_ ] := If[ KeyExistsQ[ rest , option], rest[option], {} ]

Linkage[ coordinates_?MatrixQ, _, packedCellPattern, labels : labelPattern , _Association]["LabeledVertices"] :=
	ReplacePart[ ConstantArray[None , Length[coordinates]], Reverse/@labels]

Linkage[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association]["EmbeddingDimension"] := Length[coordinates[[1]]]
Linkage[ coordinates_?MatrixQ, mr_MeshRegion, packedCellPattern, labelPattern , _Association]["DisplayDimension"] := Last[Dimensions[MeshCoordinates[mr]]]
Linkage[ coordinates_?MatrixQ, {}, cells : packedCellPattern, labels : labelPattern , _Association]["DisplayDimension"] := Length[coordinates[[1]]]

Linkage[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association]["VertexCount"] := Length[coordinates]

Linkage[ coordinates_?MatrixQ, _, cells : packedCellPattern, labelPattern , _Association]["edges"] := ToPackedArray @ Sort @ DeleteDuplicates[Sort /@ Flatten[Cases[cells,_Spring|_RigidBar|_Line][[All,1]],1]]
Linkage[ coordinates_?MatrixQ, _, cells : packedCellPattern, labelPattern , _Association]["faces"] := ToPackedArray @ DeleteDuplicatesBy[Flatten[Cases[cells,_Face|_ElasticFace|_Polygon][[All,1]],1],Sort]


Linkage[ coordinates_?MatrixQ, _ , cells : packedCellPattern, labels : labelPattern , _Association]["FaceRules"] := With[
{
	faces=DeleteDuplicatesBy[Flatten[Cases[cells,_Face|_ElasticFace|_Polygon][[All,1]],1],Sort]
},
	Dispatch[Join[({OrderlessPatternSequence@@#[[1]]} -> #[[2,1]])&/@Normal@PositionIndex[faces],{x:{__Integer}->Missing[x]}]]
]

Linkage[ coordinates_?MatrixQ, _, cells : packedCellPattern, labels : labelPattern , _Association]["EdgeRules"] := With[
{
	edges=DeleteDuplicates[Sort/@Flatten[Cases[cells,_Spring|_RigidBar|_Line][[All,1]],1]]
},
	Dispatch[Join[
		({#[[1]] -> #[[2,1]], Reverse[#[[1]]]->#[[2,1]]})& /@ Normal@PositionIndex[edges],
		{x_->Missing[x]}]]
]


Format[f : Linkage[ coordinates_?(MatrixQ[#,NumericQ]&), mr_, cells : packedCellPattern, labels : labelPattern , rest_Association] , StandardForm ] := 
	Mechanisms`graphics`PlotMechanism[f]
Format[f : Linkage[ coordinates_, mr_, cells : packedCellPattern, labelPattern , _Association] , StandardForm ] := 
With[{v=Length[coordinates]},
	Linkage[ Panel[ToString[v]<>If[v==1," Vertex"," Vertices"]] ]
]
Format[ f : Linkage[ coordinates_, mr_, cells : packedCellPattern, labelPattern , _Association] , InputForm ] := inputForm[f]

SetAttributes[Linkage,{NHoldAll}]


Options[Origami] = Flatten[{OverlapPrecision -> 10^(-12) , Options[MeshRegion]}];

(***
This is a kludge to fix ?Origami which returns an error from PadRight otherwise for reasons that are not entirely clear.
***)
mypad[ c_, {n1_?(#>0&), n2_} ] := PadRight[c, {n1,n2}]
mypad[ c_, _ ] := c
(******)

Origami[ f : Origami[ _?MatrixQ, _, packedCellPattern, labelPattern , _Association] , opt : OptionsPattern[] ] :=
With[ {meshOptions = FilterRules[{opt}, Options[MeshRegion] ]},
	addMeshRegion[
		deleteImpossibleCellsFromMechanism @ deleteDegenerateCellsFromMechanism @ removeOverlappingCoordinates[ f, OptionValue[OverlapPrecision] ],
		Automatic,
		meshOptions
	]
]

Origami[ coordinateSpec_, cellSpec_ , opt : OptionsPattern[] ] :=
Module[
{
meshOptions = FilterRules[ {opt}, Options[MeshRegion] ],
intermediateParsing = parseCells[ {coordinateSpec, {}, {} }, {cellSpec} ],
numberOfCoordinates, coordinates, cells, labels
},
	numberOfCoordinates = Length[intermediateParsing[[1]]];
	{coordinates, cells, labels} = parseCells[ intermediateParsing, FreeJoint /@ missingVertices[numberOfCoordinates, intermediateParsing[[2]]] ];

	addMeshRegion[
		deleteImpossibleCellsFromMechanism @ deleteDegenerateCellsFromMechanism[
			removeOverlappingCoordinates[
				Origami[ mypad[ coordinates , {Length[coordinates] , 3} ], {}, cells, labels, <||>],
				OptionValue[OverlapPrecision]
			]
		],
		Automatic,
		meshOptions
	]
] /; LinkagePrecisionQ[ OptionValue[ OverlapPrecision ] ]


Origami[coordinates_?MatrixQ, mr : _MeshRegion|{}, packedCellPattern, labelPattern , _Association]["Methods"] := 
	{
	"MechanismType",
	"VertexCoordinates", 
	"MeshRegion", 
	"components", 
	"labels", "LabeledVertices",
	"EmbeddingDimension", 
	"DisplayDimension",
	"VertexCount","EdgeRules","FaceRules",
	"edges",
	"faces"
	}

Origami[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association]["MechanismType"] := Origami

Origami[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association]["VertexCoordinates"] := coordinates

Origami[ coordinates_?MatrixQ, mr_MeshRegion, packedCellPattern, labelPattern , _Association]["MeshRegion"] := mr
Origami[ coordinates_?MatrixQ, {}, cells : packedCellPattern, labels : labelPattern , _Association]["MeshRegion"] := 
With[ {mesh=createMeshRegion[ Origami, PadRight[ coordinates, {Length[coordinates] , chooseDimension[ Origami, coordinates ]} ], cells, {} ]},
	If[MeshRegionQ[mesh],mesh, Message[Mechanism::meshfail,Origami]; $Failed ]
]

Origami[ coordinates_?MatrixQ, _, cells : packedCellPattern, labelPattern , _Association]["Cells"] := cells

Origami[ coordinates_?MatrixQ, _, packedCellPattern, labels : labelPattern , _Association]["labels"] := labels

Origami[ coordinates_?MatrixQ, _ , packedCellPattern, labelPattern , rest_Association ]["addendum"] := rest
Origami[ coordinates_?MatrixQ, mr_ , cells : packedCellPattern, labels : labelPattern , rest_Association ]["addendum", new_] := Origami[coordinates,mr,cells,labels,new]
Origami[ coordinates_?MatrixQ, mr_, cells : packedCellPattern, labels : labelPattern, rest_Association ]["exists", option_ ] := KeyExistsQ[ rest , option ]
Origami[ coordinates_?MatrixQ, mr_, cells : packedCellPattern, labels : labelPattern, rest_Association ]["value", option_ ] := If[ KeyExistsQ[ rest , option], rest[option], {} ]

Origami[ coordinates_?MatrixQ, _, packedCellPattern, labels : labelPattern , _Association]["LabeledVertices"] :=  ReplacePart[ ConstantArray[None , Length[coordinates]], Reverse/@labels]

Origami[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association]["EmbeddingDimension"] := Length[coordinates[[1]]]

Origami[ coordinates_?MatrixQ, mr_MeshRegion, packedCellPattern, labelPattern , _Association]["DisplayDimension"] := Last[Dimensions[MeshCoordinates[mr]]]
Origami[ coordinates_?MatrixQ, {}, cells : packedCellPattern, labels : labelPattern , _Association]["DisplayDimension"] := Last[Dimensions[ MeshCoordinates[ createMeshRegion[ Origami, PadRight[ coordinates, {Length[coordinates] , chooseDimension[ Origami, coordinates ]} ], cells, {} ] ] ] ]

Origami[ coordinates_?MatrixQ, _, packedCellPattern, labelPattern , _Association]["VertexCount"] := Length[coordinates]

Origami[ coordinates_?MatrixQ, _, cells : packedCellPattern, labelPattern , _Association]["edges"] := ToPackedArray @ Sort@DeleteDuplicates[Sort/@Flatten[Cases[cells,_Spring|_RigidBar|_Line][[All,1]],1]]
Origami[ coordinates_?MatrixQ, _, cells : packedCellPattern, labelPattern , _Association]["faces"] := ToPackedArray @ DeleteDuplicatesBy[Flatten[Cases[cells,_Face|_ElasticFace|_Polygon][[All,1]],1],Sort]


Origami[ coordinates_?MatrixQ, _ , cells : packedCellPattern, labels : labelPattern , _Association]["FaceRules"] := With[
{
	faces=DeleteDuplicatesBy[Flatten[Cases[cells,_Face|_ElasticFace|_Polygon][[All,1]],1],Sort]
},
	Dispatch[Join[({OrderlessPatternSequence@@#[[1]]} -> #[[2,1]])&/@Normal@PositionIndex[faces],{x:{__Integer}->Missing[x]}]]
]

Origami[ coordinates_?MatrixQ, _, cells : packedCellPattern, labels : labelPattern , _Association]["EdgeRules"] := With[
{
	edges=DeleteDuplicates[Sort/@Flatten[Cases[cells,_Spring|_RigidBar|_Line][[All,1]],1]]
},
	Dispatch[Join[
		({#[[1]] -> #[[2,1]], Reverse[#[[1]]]->#[[2,1]]})& /@ Normal@PositionIndex[edges],
		{x_->Missing[x]}]]
]


Format[f : Origami[ coordinates_?(MatrixQ[#,NumericQ]&), mr_, cells : packedCellPattern, labels : labelPattern , rest_Association] , StandardForm ] := 
	Quiet[Mechanisms`graphics`PlotMechanism[f, DisplayDimension -> 2], Mechanism::notflat]
Format[f : Origami[ coordinates_, mr_, cells : packedCellPattern, labelPattern , _Association] , StandardForm ] := 
With[{v=Length[coordinates]},
	Origami[ Panel[ToString[v]<>If[v==1," Vertex"," Vertices"]] ]
]

Format[ f : Origami[ coordinates_, mr_, cells : packedCellPattern, labelPattern , _Association] , InputForm ] := inputForm[f]

SetAttributes[Origami,{NHoldAll}]


meshCells[ mr_MeshRegion ] := Module[{i},
	Flatten[Table[
		Property[ MeshCells[ mr, {i, #} ], getProperties[ mr, i, # ] ]& /@ Range[ MeshCellCount[ mr, i ] ],
		{i,0,2}
	]]
]

getProperties[ mr_MeshRegion, d_, cell_ ] := # -> PropertyValue[ {mr, {d, cell}}, # ] & /@ Mechanisms`Private`$meshRegionProperties[[All,1]]


Options[ToLinkage]=Flatten[
	(*dictionary for convering vertices, edges, and polygons*)
	{
	Line -> RigidBar,
	Polygon -> Polygon,
	Point -> FreeJoint,

	(*other options*)
	Options[Linkage]}
	];

ToLinkage[m_Linkage] := m
ToLinkage[mr_MeshRegion , opt:OptionsPattern[]]:=
Linkage[
	MeshCoordinates[mr],
	DeleteCases[ meshCells[mr] /. {Point -> OptionValue[Point], Line -> OptionValue[Line], Polygon -> OptionValue[Polygon]}, Property[None[_],___]],
	FilterRules[{opt},Options[Linkage]]
]

ToLinkage[{g_Graph,data___}, opt:OptionsPattern[]]:=Linkage[
	GraphEmbedding[g,data],
	(Line[List@@#]& /@ EdgeList[g]) /. {Line -> OptionValue[Line]},
	FilterRules[{opt},Options[Linkage]]
]

ToLinkage[g_Graph, opt:OptionsPattern[]]:=Linkage[
	GraphEmbedding[g],
	(Line[List@@#]&/@EdgeList[g]) /. {Line -> OptionValue[Line]},
	FilterRules[{opt},Options[Linkage]]
]

(*from a list of regions*)
internalLinkageConvert[ reg_?RegionQ, {point_,line_,polygon_}, opt_ ] := With[{ p = CanonicalizePolyhedron[reg] },
	If[Head[p]===Polyhedron,
		Linkage[ PolyhedronCoordinates[p], {
			point /@ Range[Length[p[[1]]]],
			polygon /@ p[[2]],
			line /@ DeleteDuplicates[Sort/@Flatten[Partition[#,2,1,1]&/@p[[2]],1]]
			}, 
			opt
		],
		Missing[]
	] 
]/; RegionEmbeddingDimension[reg]==3

internalLinkageConvert[ reg_?RegionQ, {point_,line_,polygon_}, opt_ ] := With[{ p = CanonicalizePolygon[reg] },
	If[ Head[p]===Polygon,
		With[{
		coordinates = PolygonCoordinates[p],
		edges = Partition[p[[2]],2,1,1],
		faces = p[[2]]
		},
		Linkage[ coordinates, {
			point /@ Range[Length[coordinates]],
			line /@ edges,
			polygon[ faces ]
			}, 
			FilterRules[{opt}, Options[Linkage]] ]
		],
		Missing[]	
	] 
]/; RegionEmbeddingDimension[reg]==2

donothing[x_] := Nothing
ToLinkage[ reg : _?RegionQ|{__?RegionQ}, opt : OptionsPattern[] ] := With[
{ options = FilterRules[{opt}, Options[Linkage]] , rules = {OptionValue[Point], OptionValue[Line], OptionValue[Polygon] } /. None -> donothing },
	JoinMechanism[ DeleteMissing[internalLinkageConvert[#,rules, options]&/@Flatten[{reg}]] ]
]

ToLinkage::bad="Unable to turn `1` into a Linkage.";
ToLinkage[ obj_ , OptionsPattern[]]:="nothing" /; Message[ToLinkage::bad, Head[obj] ]


ToOrigami::be="Edges `1` appear to have more than one face.";


Options[ ToOrigami ] = Options[ToLinkage];

ToOrigami[f_Linkage, opt : OptionsPattern[]]:=
	Module[{o, badedges},
		o = Origami @@ f;
		badedges = Select[ Mechanisms`geometry`MechanismConnectivity[f , "edges"->"faces"], Length[#]>2&];
		If[Length[badedges]>0, Message[ToOrigami::be, badedges] ];

		o
]

ToOrigami[ dunno : Except[_Linkage] , opt : OptionsPattern[] ] := With[ {
	linkage=Quiet[ToLinkage[dunno, FilterRules[{opt}, Options[ToLinkage] ] ]]
},
	ToOrigami[linkage, opt ]
]


MechanismVertexQ[ m : mechanismPattern , vertexlist_ ] := With[{n = m["VertexCount"]},AllTrue[ vertexlist /. m[[4]] , Between[{1,n}]]]
MechanismEdgeQ[m : mechanismPattern , edgelist_ ] := AllTrue[{MatrixQ[edgelist], Length[edgelist[[1]]]==2,ContainsAll[ Sort/@m["edges"],Sort/@(edgelist/.m[[4]])]},TrueQ]
MechanismFaceQ[m : mechanismPattern , facelist_ ] := AllTrue[{ListQ[facelist],ContainsAll[ Sort/@m["faces"],Sort/@(facelist/.m[[4]]) ]},TrueQ]

ValidMechanismEdgeQ[m : mechanismPattern , edges_ ] := With[{edgelist=edges/.m[[4]]},AllTrue[{MatrixQ[edgelist], Length[edgelist[[1]]]==2,Min[edgelist]>0,Max[edgelist]<=m["VertexCount"]},TrueQ]]
ValidMechanismEdgeQ[pos_?MatrixQ , edgelist_ ] := AllTrue[{MatrixQ[edgelist], Length[edgelist[[1]]]==2,Min[edgelist]>0,Max[edgelist]<=Length[pos]},TrueQ]

ValidMechanismFaceQ[m : mechanismPattern , faces_ ] := With[{facelist=faces/.m[[4]]},AllTrue[{ ListQ[facelist], Min[facelist]>0,Max[facelist]<=m["VertexCount"]},TrueQ]]
ValidMechanismFaceQ[pos_?MatrixQ , facelist_ ] := AllTrue[{ListQ[facelist],Min[facelist]>0,Max[facelist]<=Length[pos]},TrueQ]


MechanismPositions[ m : mechanismPattern ] := m[[1]]


MechanismVertices[ m : mechanismPattern ] := Range[ m["VertexCount"] ]
MechanismVertices[ something_ ][ m : mechanismPattern ] := MechanismVertices[m, something]

MechanismVertices[ m : mechanismPattern, vertexList_?VectorQ ] := 
With[ {testList = vertexList /. m[[4]] , max = m["VertexCount"]},
	If[# < 0 || # > max || Not[IntegerQ[#]] , Missing["KeyAbsent", #] , #]& /@ testList
]
MechanismVertices[ m : mechanismPattern , f_ ] := With[ {testList = f[m] /. m[[4]]},
	If[ VectorQ[testList] , MechanismVertices[m , testList], Failure["FailedEvaluation", <| "Input"-> f|>] ]
]


MechanismEdges[ m : mechanismPattern] := m["edges"]

MechanismEdges[ something_ ][ m : mechanismPattern ] := MechanismEdges[m, something]

MechanismEdges[ m : mechanismPattern , f_ ] := With[ { testList = f[m] /. Dispatch[m[[4]]]}, 
	If[ MatrixQ[ testList], MechanismEdges[m, testList], Failure["FailedEvaluation", <| "Input"-> f|>]]
]


MechanismFaces[ m : mechanismPattern ] := m["faces"]

MechanismFaces[ something_ ][ m : mechanismPattern ] := MechanismFaces[m, something]

MechanismFaces[ m : mechanismPattern , f_ ] := With[ { testList = f[m] /. Dispatch[m[[4]]]}, 
	If[ VectorQ[ testList, VectorQ ], MechanismFaces[m, testList], Failure["FailedEvaluation", <| "Input"-> f|>]]
]


MechanismEdges[ m : mechanismPattern , edgeList_?MatrixQ ] := 
With[{ sortedEdges = Sort/@(edgeList /. Dispatch[m[[4]]]) , indexedEdges = PositionIndex[Sort/@m["edges"]] },
	ToPackedArray @ Flatten[ indexedEdges /@ sortedEdges ]
]

MechanismFaces[ m : mechanismPattern, faceList_?(VectorQ[#,VectorQ]&) ] :=
With[ {indexedFaces = PositionIndex[Sort/@m["faces"]], sortedFaces = Sort/@(faceList/.Dispatch[m[[4]]])},
	ToPackedArray @ Flatten[ indexedFaces /@ sortedFaces , 1 ]
]


MechanismVertexCells[ m : mechanismPattern , vertexList_ ] := MechanismVertexCells[ vertexList ][m]
MechanismVertexCells[ m : mechanismPattern ] := MechanismVertexCells[Range[m["VertexCount"]]][m]
MechanismVertexCells[ vertexList_?VectorQ ][m : mechanismPattern] := 
With[{cells = takeCells[ identifyCellFromList[ Head[#], vertexList /. Dispatch[m[[4]]], #] , #]&/@m[[3]]},
	Head[#][#[[1]]]& /@ Flatten[cells]
]
MechanismVertexCells[ f : Except[_List] ][m : mechanismPattern] := With[{ cells = f[m] },
	If[ Head[cells] === f, Failure["FailedEvaluation", <| "Input"-> f|>] , MechanismVertexCells[cells][m] ]
]

MechanismEdgeCells[ m : mechanismPattern , edgeList_ ] := MechanismEdgeCells[ edgeList ][m]
MechanismEdgeCells[ m : mechanismPattern ] := MechanismEdgeCells[m["edges"]][m]
MechanismEdgeCells[ edgeList_?MatrixQ ][m : mechanismPattern] := 
With[{cells = takeCells[ identifyCellFromList[ Head[#], edgeList /. Dispatch[m[[4]]], #] , #]&/@m[[3]]},
	Head[#][#[[1]]]& /@ Flatten[cells]
]
MechanismEdgeCells[ f : Except[_List] ][m : mechanismPattern] := With[{ cells = f[m] },
	If[ Head[cells] === f, Failure["FailedEvaluation", <| "Input"-> f|>] , MechanismEdgeCells[cells][m] ]
]

MechanismFaceCells[ m : mechanismPattern , faceList_ ] := MechanismFaceCells[ faceList ][m]
MechanismFaceCells[ m : mechanismPattern ] := MechanismFaceCells[m["faces"]][m]
MechanismFaceCells[ faceList_?(VectorQ[#, VectorQ]&)][ m : mechanismPattern ] :=
With[{ processedFaceList = DeleteCases[ faceList, _?(Length[#]<3&)] },
	With[{cells = takeCells[ identifyCellFromList[ Head[#], processedFaceList /. Dispatch[m[[4]]], #] , #]&/@m[[3]]},
		Head[#][#[[1]]]& /@ Flatten[cells]
	]
]
MechanismFaceCells[ f : Except[_List] ][m : mechanismPattern] := With[{ cells = f[m] },
	If[ Head[cells] === f, Failure["FailedEvaluation", <| "Input"-> f|>] , MechanismFaceCells[cells][m] ]
]


MechanismCellTypes[] := $MechanismCellTypes
MechanismCellTypes[ m : mechanismPattern ] := DeleteDuplicates[ Head /@ m[[3]] ]

MechanismCells[ m : mechanismPattern ] := Head[#][#[[1]]]& /@ m[[3]]

MechanismCells[ m : mechanismPattern , tag_String ] :=
With[{
	res = mechanismCellList["Threaded", m , tag, None, None]
},
	res[[1,1]] /; Head[res] =!= mechanismCellList
]

MechanismCells[ m : mechanismPattern , cellPattern : Except[_String] ] := 
	With[{
		res = mechanismCellList[ "Threaded" , m , cellPattern /. m[[4]], None , None]
	},
		res /; Head[res] =!= mechanismCellList
	]

MechanismCells[ m : mechanismPattern, cellPattern : Except[_String], dataSpec_] :=
	With[{ res = mechanismCellList[ "Threaded", m, cellPattern /. m[[4]], dataSpec, None ]},
		res /; Head[res] =!= mechanismCellList
	]

MechanismCells[ args__ ][m : mechanismPattern] := MechanismCells[m,args]


(* main routine

outputFormat = one of {"Threaded","Unthreaded", "Index"} from $cellOutputFormats
cellSpec is a pattern to match cells
dataSpec is a rule of the form dataType -> dataValue to match
outputSpec matches the rules to determine which should be listed
*)
mechanismCellList[ outputFormat_ , m_ , cellSpec_ , dataSpec_ , outputSpec_ ] :=
	outputCells[ outputFormat, outputSpec, filterCellsByData[m , dataSpec , filterCells[ m, cellSpec] ] ]


(*filter by the cell specification*)

(* {head , cell list} *)
filterCells[ m_ , {head_ , indices_List}] := Flatten[takeCells[ identifyCellFromList[ head, indices /. m[[4]], # ], # ] & /@ m[[3]] ]
(* if it isn't a list, assume it's a pattern *)
filterCells[ m_ , patt : Except[_List] ] :=
	With[{ pattern = cellPattern[patt] /. m[[4]] },
		Flatten[takeCells[ casesCellType[ pattern, # ], # ] & /@ m[[3]] ]
	]

filterCells[ m_ , patt_] := (Message[MechanismCells::cspec, patt]; {})


(*filter by the data specification*)
filterCellsByData[m_, None, cells_] := cells
filterCellsByData[m_, Blank[], cells_] := cells
filterCellsByData[m_ , spec_List, cells_] := Flatten[filterCellsByData[m, #, cells]& /@ spec]

filterCellsByData[m_, dataSpec_ -> f_Function, cells_] := Flatten[ takeCells[ selectCellFromDataType[ dataSpec -> f, #], # ]& /@ cells ]
filterCellsByData[m_, dataSpec_ -> patt_, cells_] := Flatten[ takeCells[ casesCellFromDataType[ dataSpec -> patt, #], # ]& /@ cells ]

filterCellsByData[ m_ , dataSpec : Except[_List|Blank[]|None] , cells_ ] := (Message[MechanismCells::dspec, dataSpec]; cells)


MechanismCells::err = "Patterns starting with Blank[] cannot be parsed.";
MechanismCells::dspec = "Data spec `1` cannot be parsed.";
MechanismCells::cspec = "Cell specification `1` should be in the form { cell , indices } or a cell pattern.";


(*new positions have been provided*)
newVertexPositions[ m_ , newPositions_?MatrixQ ] := 
	ReplacePart[ m, 1 -> newPositions ] /; m["VertexCount"] == Length[newPositions]
(*assume this is a list of replacement rules that is empty*)
newVertexPositions[ m_, {} ] := m
(*a list of replacement rules*)
newVertexPositions[ m_ , rules : {__Rule}|_Rule] := 
With[ {
	(*rewrite vertices using any labels*)
	vertices = Flatten[{rules}][[All,1]] /. m[[4]], 
	(*extract positions*)
	positions = Flatten[{rules}][[All,2]]
},
	ReplacePart[ m,
		1 -> ReplacePart[ 
				m["VertexCoordinates"] , 
				Thread[vertices -> positions]
			]
	] /; VectorQ[ vertices , IntegerQ ] && Max[vertices] <= m["VertexCount"]  && Min[vertices] > 0 && MatrixQ[ positions ] && Length[ positions[[1]] ] == m["EmbeddingDimension"]
]

newVertexPositions[ m_ , rules : {__Rule}|_Rule] := "nothing" /;
With[ {vertices = Flatten[{rules}][[All,1]], positions = Flatten[{rules}][[All,2]]},
	(*some vertices are out of bounds*)
	If[ Not[VectorQ[ vertices /. m[[4]] , IntegerQ ]] || Max[vertices] > m["VertexCount"]  || Min[vertices] <= 0, Message[PlaceVertices::vert , vertices]];
	(*not all positions have the same dimension*)
	If[ Not[MatrixQ[ positions ]], Message[PlaceVertices::pos, positions] ];
	If[ MatrixQ[ positions ] && Length[positions[[1]]] != m["EmbeddingDimension"], Message[PlaceVertices::pos, positions]];
	False
]
newVertexPositions[ m_ , newPositions_?MatrixQ ] := "nothing" /; (
	If[ m["VertexCount"] != Length[newPositions], Message[PlaceVertices::num, m["VertexCount"]] ];
	False
)
newVertexPositions[ m_, Except[_?MatrixQ | _Rule | {__Rule} | {} ]] := "nothing" /; Message[PlaceVertices::r]


PlaceVertices[ m : mechanismPattern , r_ ] := With[ { res = newVertexPositions[ m , r ]},
	If[ MechanismQ[ res ] , res , m]
]
PlaceVertices[ r_ ][ m : mechanismPattern ] := With[ { res = newVertexPositions[ m , r ]},
	If[ MechanismQ[ res ] , res , m]
]

PlaceVertices::vert = "Vertices `1` are not all valid vertex indices in mechansim.";
PlaceVertices::pos = "Positions `1` are not valid vertex coordinates.";
PlaceVertices::num = "Number of vertices should be `1`.";
PlaceVertices::r = "Argument is not a list of vertex positions or replacement rules for vertex positions.";


moveVertexPositions[ m_ , newPositions_?MatrixQ ] := 
	ReplacePart[ m, 1 -> (m["VertexCoordinates"] + newPositions) ] /; Dimensions[m["VertexCoordinates"]] == Dimensions[newPositions]
moveVertexPositions[ m_, {} ] := m
moveVertexPositions[ m_ , rules : {__Rule}|_Rule] := 
With[ {
	(*rewrite vertices using any labels*)
	vertices = Flatten[{rules}][[All,1]] /. m[[4]], 
	positions = Flatten[{rules}][[All,2]]
},
	ReplacePart[ m,
		1 -> ( m["VertexCoordinates"] + ReplacePart[ 
											ConstantArray[0, Dimensions[m["VertexCoordinates"]] ], 
											Thread[vertices -> positions]
										]
			)
	] /; VectorQ[ vertices , IntegerQ ] && Max[vertices] <= m["VertexCount"]  && Min[vertices] > 0 && MatrixQ[ positions ] && Length[ positions[[1]] ] == m["EmbeddingDimension"]
]
moveVertexPositions[ m_ , f_ ] := With[{ newPositions =  f @ m["VertexCoordinates"]},
	newVertexPositions[ m , newPositions ] /; MatrixQ[newPositions] && Dimensions[newPositions] == Dimensions[m["VertexCoordinates"]]
]

moveVertexPositions[ m_ , rules : {__Rule}|_Rule] := "nothing" /;
With[ {vertices = Flatten[{rules}][[All,1]], positions = Flatten[{rules}][[All,2]]},
	(*some vertices are out of bounds*)
	If[ Not[VectorQ[ vertices /. m[[4]] , IntegerQ ]] || Max[vertices] > m["VertexCount"]  || Min[vertices] <= 0, Message[DisplaceVertices::vert , vertices]];
	(*not all positions have the same dimension*)
	If[ Not[MatrixQ[ positions ]], Message[DisplaceVertices::pos, positions] ];
	If[ MatrixQ[ positions ] && Length[positions[[1]]] != m["EmbeddingDimension"], Message[DisplaceVertices::pos, positions]];
	False
]
moveVertexPositions[ m_ , newPositions_?MatrixQ ] := "nothing" /; (
	If[ m["VertexCount"] != Length[newPositions], Message[DisplaceVertices::num, m["VertexCount"]] ];
	False
)
moveVertexPositions[ m_, Except[_?MatrixQ | _Rule | {__Rule} | {} ]] := "nothing" /; Message[DisplaceVertices::r]


DisplaceVertices[ m : mechanismPattern , r_ ] := With[ { res = moveVertexPositions[ m , r ]},
	If[ MechanismQ[ res ] , res , m]
]
DisplaceVertices[ r_ ][ m : mechanismPattern ] := With[ { res = moveVertexPositions[ m , r ]},
	If[ MechanismQ[ res ] , res , m]
]
DisplaceVertices::vert = "Vertices `1` are not all valid vertex indices in mechansim.";
DisplaceVertices::pos = "Positions `1` are not valid vertex coordinate displacements.";
DisplaceVertices::num = "Number of vertices should be `1`.";
DisplaceVertices::r = "Argument is not a list of vertex displacements, a function that returns new vertex positions, or a list of replacement rules indicating vertex displacements.";


MapVertices[ m : mechanismPattern, ff__ ] := With[ {res = MapVertices[ff]@m}, res /; Head[res] =!= MapVertices ]

MapVertices[ f : Except[mechanismPattern] ][m : mechanismPattern] := 
With[{ newPositions = f /@ m[[1]]},
	If[ Not@MatrixQ[ newPositions, NumericQ ] , Message[MapVertices::num] ];
	ReplacePart[m, 1 -> newPositions]
]

MapVertices[ f : Except[mechanismPattern] , lst_?MatrixQ ][m : mechanismPattern] :=
With[{ newPositions = MapThread[f, Join[ {m[[1]]} , lst ] ] },
	If[ Not@MatrixQ[ newPositions, NumericQ ] , Message[MapVertices::num] ];
	ReplacePart[ m , 1 -> newPositions ]
] /; Length[m[[1]]]==Length[lst[[1]]]

MapVertices[ f : Except[mechanismPattern] , lst_?VectorQ ][m : mechanismPattern] :=
With[{ newPositions = MapThread[f, {m[[1]], lst} ] },
	If[ Not@MatrixQ[ newPositions, NumericQ ] , Message[MapVertices::num] ];
	ReplacePart[ m , 1 -> newPositions ]
] /; Length[m[[1]]]==Length[lst]

MapVertices[ m : mechanismPattern , f_ , lst_ ] := "nothing" /; Message[MapVertices::lst, m["VertexCount"] ]
MapVertices::lst = "Provided lists for threading do not have `1` elements.";
MapVertices::num = "Warning: new vertex positions are not numeric.";


MapCells[ f_ ][ m : mechanismPattern ] := 
Module[
{
	cells = unparseCells[m[[3]],_],
	newCells
},
	newCells = parseCells[ {m[[1]], {}, m[[4]]} , f /@ cells ];
	Head[m][ newCells[[1]], {}, newCells[[2]], newCells[[3]] , m[[5]] ]
]
MapCells[ m : mechanismPattern  , f_] := addMeshRegion[ MapCells[f][m], Automatic, {} ]


(*no data to process so do nothing*)
ChangeCellData[ anything_, {} ][ m : mechanismPattern ] := m


matrixCellHeads = Alternatives@@Join[angleCells, edgeCells];
vertexCellHeads = Alternatives@@Join[vertexCells,{AnyJoint}];
faceCellHeads = Alternatives@@faceCells;

modifyCellDataArguments[ matrixCellHeads , cellList_ ] := MatrixQ[cellList, IntegerQ]
modifyCellDataArguments[ faceCellHeads , cellList_List ] := Depth[cellList] == 3 && VectorQ[Flatten[cellList], IntegerQ ]
modifyCellDataArguments[ vertexCellHeads , cellList_ ] := VectorQ[cellList, IntegerQ]
modifyCellDataArguments[ _, _ ] := False


modifyCellDataFromList[ m_ , headSpec_ , cellList_ , dataSpec_ , dataList_ ] :=
	With[ {specifiedCells = identifyCellFromList2[ headSpec, cellList, #] },		
		changeCellDataType[specifiedCells[[2]] , {Head[#], dataSpec}, dataList[[specifiedCells[[1]]]], #]		
	]& /@ m[[3]]


ChangeCellData[ m : mechanismPattern , cells__ ] := ChangeCellData[cells][m]

(*thread over data*)
ChangeCellData[ cells_ , data : _Association|_List ][m : mechanismPattern] := Fold[ ChangeCellData[ cells , #2 ][#1]& , m , Normal@data ]
(*thread over cells*)
ChangeCellData[ cells_List, data_][m : mechanismPattern] := Fold[ ChangeCellData[ #2, data][#1]&, m, cells]

(*
thread over arguments of the form,

	cellSpec[{cell1, cells2,...}] -> <| dataSpec1 -> {data11, data12,...}, dataSpec2 -> {data21, data22, ...},... |>

but allow users to override the data specified if they want.
*)
ChangeCellData[ onelist_List ][m : mechanismPattern] := Fold[ ChangeCellData[#2][#1]&, m, onelist ]
ChangeCellData[ cells_ -> (data : _Association|_List) ][m : mechanismPattern] := Fold[ ChangeCellData[ cells , #2 ][#1]& , m , Normal@data ]
ChangeCellData[ cells_ -> (data : _Association|_List) , dataSpec_][m : mechanismPattern] := ChangeCellData[ cells , dataSpec ][m]


(*
call with a list of cells to modify

the data is either a list with the same length as cellSpec or not a list.
*)
ChangeCellData[ (headSpec : celltypePattern|_String|AnyJoint)[cellSpec_], dataSpec_ -> data_ ][m : mechanismPattern] :=
	With[{
		properCellSpec = cellSpec /. Dispatch[m[[4]]],
		properHeadSpec = headSpec /. AnyJoint -> FreeJoint|PinnedJoint
	},
		With[{
			properData = Which[ 
				ListQ[data] , data , 
				Head[data] === Function, data /@ properCellSpec,
				True, ConstantArray[data, Length[cellSpec]]
			]
		},
		If[ modifyCellDataArguments[headSpec, properCellSpec ] && Length[properData] == Length[cellSpec],		
			Head[m][
				m[[1]],
				{},
				modifyCellDataFromList[m, properHeadSpec, properCellSpec, dataSpec, properData],
				m[[4]],
				m[[5]]
			],
			
			If[ Not@modifyCellDataArguments[headSpec, properCellSpec ] , 
				If[ Head[headSpec]===String, 
					Message[ChangeCellData::tag, headSpec[cellSpec] ],
					Message[ChangeCellData::errcells, headSpec[cellSpec] ]
				]
			];
			If[ Length[properData] != Length[cellSpec] , Message[ChangeCellData::datalen, headSpec[cellSpec] ]];
			m
		]
	]]


(* use a function to identify data to modify *)
ChangeCellData[ something : Except[_AnyJoint|_List|_String[_]|celltypePattern[_]], data_ ][m : mechanismPattern ] := 
With[ {cellList = something[m]}, 
	If[
		Head[cellList] === something ,  Message[ChangeCellData::errcells, something]; m, 
		ChangeCellData[ cellList , data ][m]
	]
]
ChangeCellData[ something : _AnyJoint|celltypePattern[_] ][m : mechanismPattern ] := (Message[ChangeCellData::dataspec,something]; m)
ChangeCellData[ something : _String[_] ][m : mechanismPattern ] := (Message[ChangeCellData::tag,something]; m)

(*use a function to identify data to modify and what to modify it to*)
ChangeCellData[ something : Except[_List] ][m : mechanismPattern ] := 
With[ {cellList = something[m]}, 
	If[ Head[cellList] === List , ChangeCellData[ cellList ][m],  Message[ChangeCellData::errall, something]; m ]
]

ChangeCellData::dataspec="`1` requires a specification of what data to modify.";
ChangeCellData::tag="`1` cannot be a tagged cell. Tagged cells have no data to modify";
ChangeCellData::errcells="`1` must be of the form headSpec[{cell1, cell2, ...}] or evaluate to a list of cells when acting on a mechanism.";
ChangeCellData::errall="`1` must evaluate to a list of cells and a list of data to modify when acting on a mechanism.";


ChangeCellData[headSpec_[cellSpec_] , badrule_ ][m : mechanismPattern] := (
	If[Head[badrule] =!= Rule, Message[ChangeCellData::data, badrule]];
	m
  )

ChangeCellData::datalen = "The data provided is not the same length as the cells `1`.";
ChangeCellData::data = "The data to modify, `1`, is not of the form dataSpec -> newData.";


Options[JoinMechanism] = {OverlapPrecision -> 10^(-12)};

JoinMechanism[ meshes : __?MechanismQ|{__?MechanismQ}, opt : OptionsPattern[] ] :=
Module[{n, m = Flatten[{meshes}], meshOptions = FilterRules[{opt}, Options[MeshRegion]] },
	With[{ num = Drop[ Flatten[{{1}, #+1& /@ Accumulate[ Length /@ m[[All,1]] ] }, 1 ], -1] },
		addMeshRegion[
			deleteDegenerateCellsFromMechanism[
				removeOverlappingCoordinates[
					Head[m[[1]]][
						Flatten[m[[All,1]],1],
						{},
						joinCells[ Flatten @ MapThread[ replaceCellIndices[#1, n_Integer -> n + #2 - 1]&, { m[[All,3]], num }] ],
						Flatten @ MapThread[ replaceRules[ #1, n_Integer -> n + #2 - 1, 2 ]&, { m[[All,4]], num } ],
						Join @@ m[[All,5]] (*Need to improve this*)
					],
					OptionValue[OverlapPrecision]
				]
			],
			Automatic,
			meshOptions
		]
	] /; LinkagePrecisionQ[ OptionValue[OverlapPrecision] ] && sameHeadsQ[ m ]
]

Mechanism::comb = "Cannot combine Mechanisms of different types.";
sameHeadsQ[ expr_List ] := If[ SameQ[ Head /@ expr ], True, Message[Mechanism::comb]; False ]


makeListOfCells[ m_, (head : celltypePattern|_String)[cells_] ] := identifyCellFromList[ head, cells, #]& /@ m[[3]]
makeListOfCells[ m_ , (head : celltypePattern|_String)[cells_] -> anything_ ] := identifyCellFromList[ head, cells, #]& /@ m[[3]]

(*(*list of indices only*)
makeListOfCells[ m_ , cellSpec_?(VectorQ[#,IntegerQ]&) ] := identifyCellFromList[ Head[#], cellSpec, #]& /@ m[[3]]
*)

makeListOfCells[ m_ , cellSpec_List ] := MapThread[ Join, DeleteCases[ makeListOfCells[m,#]& /@ cellSpec, $Failed]]

makeListOfCells[ m_ , something : Except[_List|_Rule|_String[_]] ] := With[{ cells = something[m] }, 
	If[ Head[cells] =!= something, makeListOfCells[m, cells], $Failed]
]


SelectCells[ cellSpec_ ][m:mechanismPattern] :=
With[{loc=makeListOfCells[ m, cellSpec /. m[[4]]]},
	Which[
		loc === $Failed, Message[SelectCells::spec, cellSpec]; m,
		Length[loc]==0, Head[m][m[[1]], {}, {}, m[[4]],m[[5]]],
		True, Head[m][
			m[[1]],
			{},
			Flatten[ MapThread[ takeCells, {loc, m[[3]] } ] ],
			m[[4]],
			m[[5]]
		]
	]
]

SelectCells[m : mechanismPattern, patt_ ] := addMeshRegion[ SelectCells[patt][m], Automatic , {} ]

SelectCells::spec="Selection function `1` does not evaluate to a valid list of cells when applied to mechanism.";


DeleteCells[ cellSpec_ ][m:mechanismPattern] :=
With[{loc=makeListOfCells[ m, cellSpec /. m[[4]] ]},
	Which[
		loc === $Failed, Message[DeleteCells::spec, cellSpec]; m,
		Length[loc]==0, m,
		True, Head[m][
			m[[1]],
			{},
			Flatten[ MapThread[ removeCells, {loc, m[[3]] } ] ],
			m[[4]],
			m[[5]]
		]
	]
]

DeleteCells[m : mechanismPattern, patt_ ] := addMeshRegion[ DeleteCells[patt][m], Automatic , {} ]

DeleteCells::spec="Selection function `1` does not evaluate to a valid list of cells when applied to mechanism.";


Options[ AddCells] = Options[Linkage];

AddCells[ cells_ , opt : OptionsPattern[] ][ m : mechanismPattern ] := With[
{ parsed = parseCells[ { m[[1]], m[[3]], m[[4]] } , Flatten[{cells}]] },
	deleteDegenerateCellsFromMechanism[ removeOverlappingCoordinates[
		Head[m][parsed[[1]], {}, parsed[[2]], parsed[[3]], m[[5]]],
		OptionValue[OverlapPrecision]
	] ]
] /; LinkagePrecisionQ[ OptionValue[OverlapPrecision] ]

AddCells[ m : mechanismPattern, cells_, opt : OptionsPattern[] ] := addMeshRegion[ AddCells[ cells, opt ][m], Automatic, FilterRules[ {opt}, Options[MeshRegion]]]


DeleteVertices[f_][m:mechanismPattern] := With[{vertices=f[m]},
	If[ VectorQ[vertices], DeleteVertices[vertices][m] , Message[DeleteVertices::err, f]; m]
]
DeleteVertices[ vertices_?VectorQ ][m : mechanismPattern] :=
With[ { pattern = Alternatives @@ ( {___,#,___}|#& /@ vertices ) },
With[ { remainingCells = Flatten[ removeCells[ casesCellType[ {Head[#][pattern]} , # ], # ]& /@ m[[3]] ] },
With[ { remainingVertices = Complement[ Range[Length[m[[1]]]], vertices /. m[[4]] ] },
With[ { remappingRules = Thread[ remainingVertices -> Range[Length[remainingVertices]]] },
	Head[m][
		m[[1, remainingVertices]],
		{},
		replaceCellIndices[ remainingCells, remappingRules ],
		replaceRules[ m[[4]], remappingRules, 2 ],
		m[[5]] /. remappingRules
	]
]]]]

DeleteVertices::err = "`1` did not evaluate to a list of vertices when evaluated.";


DeleteVertices[ m : mechanismPattern, vertices_ ] := addMeshRegion[ DeleteVertices[vertices][m], Automatic , {}]


TagCells[ (s : _String)[ indexList_ ] ][ m : mechanismPattern ] := Head[m][ m[[1]], m[[2]], joinCells[ {packCells[ {s[indexList, {} ]} ], m[[3]] } ], m[[4]] , m[[5]] ]
TagCells[ m : mechanismPattern, (s : _String)[ indexList_ ]] := TagCells[s,indexList][m]


LabelVertices[ "Name" ][m : mechanismPattern ] := ChangeCellData[ AnyJoint[Range[m["VertexCount"]]], "Label" -> m["LabeledVertices"] ] @ m
LabelVertices[ "Index" ][ m : mechanismPattern ] := ChangeCellData[AnyJoint[Range[m["VertexCount"]]], "Label" -> "Index"]@m
LabelVertices[ None ][ m : mechanismPattern ] := ChangeCellData[AnyJoint[Range[m["VertexCount"]]], "Label" -> None]@m
LabelVertices[ rules : {__Rule}|_Rule ][m : mechanismPattern ] := With[{ruleList=Flatten[{rules}]},
	ChangeCellData[AnyJoint[ruleList[[All,1]] /. Dispatch[m[[4]]]], "Label" -> ruleList[[All,2]]] @ m
]
	
LabelVertices[ m : mechanismPattern , "Name" ] := ChangeCellData[ m, AnyJoint[Range[m["VertexCount"]]], "Label" -> m["LabeledVertices"] ]
LabelVertices[ m : mechanismPattern , "Index" ] := ChangeCellData[m, AnyJoint[Range[m["VertexCount"]]], "Label" -> "Index"]
LabelVertices[ m : mechanismPattern , None ] := ChangeCellData[m, AnyJoint[Range[m["VertexCount"]]], "Label" -> None]
LabelVertices[ m : mechanismPattern, rules : {__Rule}|_Rule ] :=
With[{ruleList = Flatten[{rules}]},
	ChangeCellData[m, AnyJoint[ruleList[[All,1]] /. Dispatch[m[[4]]]], "Label" -> ruleList[[All,2]]]
]


LabelVertices[ lst_List ][ m : mechanismPattern ] := ChangeCellData[AnyJoint[ Range[m["VertexCount"]] ], "Label"->lst] @ m /; Length[lst]==m["VertexCount"]
LabelVertices[ lst_List ][ m : mechanismPattern ] := "nothing" /; Message[LabelVertices::length, m["VertexCount"]]

LabelVertices[ m : mechanismPattern , lst_List ] := "nothing" /; Message[LabelVertices::length, m["VertexCount"]]
LabelVertices[ m : mechanismPattern, lst_List ] := ChangeCellData[m, AnyJoint[ Range[m["VertexCount"]] ], "Label"->lst] /; Length[lst]==m["VertexCount"]

LabelVertices[ _ ][ m : mechanismPattern ] := "nothing" /; Message[LabelVertices::bad]
LabelVertices[ m : mechanismPattern , _ ] := "nothing" /; Message[LabelVertices::bad]

LabelVertices::length="Length of labels does not match number of vertices, `1`.";
LabelVertices::bad="First argument should be a label, list of labels, or list of rules assigning labels to a vertex.";


ReplaceCells[ f_ ][ m : mechanismPattern ] := 
Module[
{
	cells = Property[Head[#][#[[1]]],#[[2]]]& /@ unparseCells[m[[3]],_],
	newCells
},
	newCells = parseCells[ {m[[1]], {}, m[[4]]} , cells /. f ];
	Head[m][ newCells[[1]], {}, newCells[[2]], newCells[[3]] , m[[5]] ]
]
ReplaceCells[ m : mechanismPattern  , f_] := addMeshRegion[ ReplaceCells[f][m], Automatic, {} ]


Options[TesselateMechanism]={OverlapPrecision->10^(-6)};


TesselateMechanism::counter="Number of cells must be positive integers corresponding to the number of basis elements.";
TesselateMechanism::dim="Basis must be `1` dimensional to match Mechanism.";
TesselateMechanism::num="Basis must be numerical with vectors of the same dimension.";
TesselateMechanism::basis="Basis must be a list of `1` numerical vectors.";

tesselationBasisQ[ m_, d_, basis_ ] := Which[
	Not[MatrixQ[basis,NumericQ]], Message[ TesselateMechanism::num]; False,
	Length[basis] != d, Message[ TesselateMechanism::basis, d ]; False,
	Last[Dimensions[basis]] != m["EmbeddingDimension"], Message[ TesselateMechanism::dim, m["EmbeddingDimension"] ]; False,
	True, True
]

tesselationCellCountsQ[ n1__Integer?Positive ] := True
tesselationCellCountsQ[ __ ] := (Message[TesselateMechanism::counter]; False)


translateLabels[ n_, {} ] := {}
translateLabels[n_, ruleList : {Rule[ _, _ ]..} ]:= Module[ {labels, indices, nstring} ,  
	{labels, indices} = Transpose[ List @@@ ruleList ];
	(*create a string of the form "[n1,n2,...]" with no spaces*)
	nstring=StringJoin["[",ToString/@Riffle[n,","],"]"];
	Rule @@@ Transpose[ { #@@n& /@ labels , indices } ]
]

translateCoordinates[ positions_, translationVector_ ] := positions + ConstantArray[translationVector, Length[positions]]


TesselateMechanism[ everything___][m : mechanismPattern] := TesselateMechanism[m, everything]


TesselateMechanism[m : mechanismPattern, basis_, n1 : Except[_List], opt : OptionsPattern[] ]:=
Module[
{
	positions = m["VertexCoordinates"],
	unitCellIndices = Range[0,n1-1], 
	newCoordinates, translatedMechanisms
},
	newCoordinates = translateCoordinates[ positions, basis # ]& /@ unitCellIndices;
	translatedMechanisms = MapThread[ Head[m][ #1, {}, m[[3]], translateLabels[#2, m[[4]] ] ]&, {newCoordinates, unitCellIndices} ];
	
	JoinMechanism[ translatedMechanisms, opt ]

] /; tesselationBasisQ[m, 1, {basis}] && tesselationCellCountsQ[n1,1]


TesselateMechanism[ m : mechanismPattern, basis_, {n1_, n2_}, opt : OptionsPattern[] ] :=
Module[
{
	positions = m["VertexCoordinates"],
	unitCellIndices = Flatten[Array[{#1-1,#2-1}&,{n1,n2}],1],
	newCoordinates, translatedMechanisms
},
	newCoordinates = translateCoordinates[ positions, # . basis ]& /@ unitCellIndices;
	translatedMechanisms = MapThread[ Head[m][#1, {}, m[[3]], translateLabels[#2, m[[4]] ], m[[5]]]&, {newCoordinates, unitCellIndices} ];
	
	JoinMechanism[ translatedMechanisms, opt ]
] /; tesselationBasisQ[m, 2, basis] && tesselationCellCountsQ[n1,n2]


TesselateMechanism[ m : mechanismPattern, basis_, {n1_, n2_, n3_}, opt : OptionsPattern[] ] :=
Module[
{
	positions = m["VertexCoordinates"],
	unitCellIndices = Flatten[Array[{#1-1,#2-1,#3-1}&,{n1,n2,n3}],2],
	newCoordinates, translatedMechanisms
},
	newCoordinates = translateCoordinates[ positions, # . basis ]& /@ unitCellIndices;
	translatedMechanisms = MapThread[ Head[m][#1, {}, m[[3]], translateLabels[#2, m[[4]] ], m[[5]]]&, {newCoordinates, unitCellIndices} ];
	
	JoinMechanism[ translatedMechanisms, opt ]
] /; tesselationBasisQ[m, 3, basis] && tesselationCellCountsQ[n1,n2,n3]


replaceAll[ f : mechanismPattern, rule_ ] := Head[f][ ReplaceAll[f[[1]],rule] ,f[[2]], replaceCellData[ f[[3]], rule ],f[[4]], f[[5]]]

ReplaceAll[ f_Linkage, rule_ ] ^:= replaceAll[ f, rule ]
ReplaceAll[ o_Origami, rule_] ^:= replaceAll[o, rule]


Precision[ f_Linkage ] ^:= Precision[ f["VertexCoordinates"] ]
Precision[ o_Origami ] ^:= Precision[ o["VertexCoordinates"] ]


Rationalize[ f_Linkage, dx___ ] ^:= ReplacePart[ f, 1 -> ToPackedArray[Rationalize[ f[[1]], dx ]] ]
Rationalize[ o_Origami, dx___ ] ^:= ReplacePart[ o, 1 -> ToPackedArray[Rationalize[ o[[1]], dx ]] ]


N[ f_Linkage, dx___ ] ^:= ReplacePart[ f, 1 -> ToPackedArray[N[ f[[1]], dx ]] ]
N[ o_Origami, dx___ ] ^:= ReplacePart[ o, 1 -> ToPackedArray[N[ o[[1]], dx ]] ]


AddOption[ rules : {__Rule}|_Rule , f_ : Flatten][m : mechanismPattern] := m["addendum", Merge[ {m["addendum"] , Association@@Flatten[{rules}] }, f]]

AddOption[m : mechanismPattern, assoc_Association, f_ : Flatten] := m["addendum", Merge[ {m["addendum"] , assoc}, f]]
AddOption[m : mechanismPattern, rules : {__Rule}, f_ : Flatten] := m["addendum", Merge[ {m["addendum"] , Association@@rules}, f]]
AddOption[m : mechanismPattern, rules : _Rule, f_ : Flatten] := m["addendum", Merge[ {m["addendum"] , Association[rules]}, f]]

Delete[ m_Origami, option_ ] ^:= m["addendum", Delete[ m["addendum"], Key[option] ]]
Delete[ m_Linkage, option_ ] ^:= m["addendum", Delete[ m["addendum"], Key[option] ]]

KeyExistsQ[ m_Origami , option_] ^:= KeyExistsQ[ m["addendum"], option ]
KeyExistsQ[ m_Linkage , option_] ^:= KeyExistsQ[ m["addendum"], option ]

Keys[ m_Origami ] ^:= Keys[m["addendum"]]
Keys[ m_Linkage ] ^:= Keys[m["addendum"]]
Values[ m_Origami ] ^:= Values[m["addendum"]]
Values[ m_Linkage ] ^:= Values[m["addendum"]]
Values[ m_Origami, h_ ] ^:= Values[m["addendum"],h]
Values[ m_Linkage , h_] ^:= Values[m["addendum"],h]

OptionValue[m_Linkage, option_] ^:= Lookup[ m["addendum"], option, {} ]
OptionValue[m_Origami, option_] ^:= Lookup[ m["addendum"], option, {} ]


DivideEdges::me = "The edges `1` are missing from the mechanism.";
DivideEdges::e = "`1` are not a list of edges.";
DivideEdges::l = "Labels `1` are not the same length as list of edges.";

DivideEdges[ m : mechanismPattern , proposedEdges_?MatrixQ , label_ : (ToString[Unique[]]<>":") ] :=
	addVertexToEdge[m ,proposedEdges /. Dispatch[m[[4]]], label] /; Length[proposedEdges[[1]]]==2
DivideEdges[ proposedEdges_?MatrixQ , label_ : (ToString[Unique[]]<>":") ][ m : mechanismPattern ] :=
	addVertexToEdge[m, proposedEdges /. Dispatch[m[[4]]], label] /; Length[proposedEdges[[1]]]==2

DivideEdges[ proposedEdges_ , label_ : (ToString[Unique[]]<>":") ][ m : mechanismPattern ] :=
	"nothing" /; Message[DivideEdges::e, proposedEdges]
DivideEdges[ m : mechanismPattern, proposedEdges_ , label_ : (ToString[Unique[]]<>":") ] :=
	"nothing" /; Message[DivideEdges::e, proposedEdges]

(*this code adds a vertex at the midpoint of an edge and makes sure faces are adjusted appropriately*)
addVertexToEdge[ m_ , proposedEdges_ , labelStyle_ ] :=
Module[
{
	edgeNumbers,missingEdges, edges,
	faces = Mechanisms`geometry`MechanismConnectivity[m, "edges" -> "faces"],
	labels, proposedLabels,
	positions = MechanismPositions[m],
	verticesToAdd, edgesToAdd, facesToAdd,
	edgesToDealWith , facesToDealWith
},
	edgeNumbers = MechanismEdges[ m, proposedEdges ];
	missingEdges = Cases[edgeNumbers,_Missing][[All,2]];
	(*if the labels are a list of the correct # of possible labels, we'll just use them*)
	proposedLabels = If[Head[labelStyle]===List,
		Which[
			Length[labelStyle] >= Length[edgeNumbers],
				Take[labelStyle,Length[edgeNumbers]],
			Length[labelStyle] == 0,
				MapThread[ #1<>":"<>ToString[#2]&, {ConstantArray[ToString[Unique[]],Length[edgeNumbers]], edgeNumbers}],
			True,
				(*oops -- wrong length*)
				Message[DivideEdges::l, labelStyle];
				(ToString[labelStyle[[1]]]<>ToString[#])& /@ edgeNumbers
		],
		(ToString[labelStyle]<>ToString[#])& /@ edgeNumbers
	];

	(*remove any reference to missing edges.*)
	If[Length[missingEdges]>0,
		Message[ SubdivideEdges::me, missingEdges];
		{edgeNumbers, edges, labels} = Transpose@Select[ Transpose[{edgeNumbers, proposedEdges,proposedLabels}], Not@MissingQ[#[[1]]]& ],
	
		edges = proposedEdges;
		labels = proposedLabels;
	];
	
	edgesToDealWith = DeleteCases[ mechanismCellList[ "Threaded", m, {_, edges}, None, _], _String[_] ];
	facesToDealWith = DeleteCases[ mechanismCellList[ "Threaded", m, {_, Flatten[ faces[[edgeNumbers]] ,1] }, None, _], _String[_] ];

	verticesToAdd = MapThread[ FreeJoint[#1 -> Mean[positions[[#2]]]]& , {labels, edges} ];
	edgesToAdd = subdivideAllEdges[#, labels]& /@ edgesToDealWith;
	facesToAdd = augmentFaces[#, labels, edges]& /@ facesToDealWith;	

	AddCells[{facesToAdd, edgesToAdd, verticesToAdd}] @ DeleteCells[ Flatten[{facesToDealWith[[All, 1]] , edgesToDealWith[[All, 1]]}] ] @ m
]

subdivideEachEdge[ {v1_,v2_},v3_] := {{v1,v3},{v3,v2}}
subdivideAllEdges[ head_[edges_] -> properties_ , labels_ ] :=
	MapThread[
		Property[head[subdivideEachEdge[#1,#2]],#3]&,
		{
			edges,
			labels,
			properties
		}
	]

(*these functions add vertices to the approprite faces*)
edgeRules[edges_,labels_] := 
Dispatch@Flatten[MapThread[
	{
	#1 -> Sequence[{#1[[1]],#2},{#2,#1[[2]]}],
	Reverse[#1] -> Sequence[{#1[[2]],#2},{#2,#1[[1]]}]
	}&,
	{edges, labels}
]]

augmentEachFace[faces_, label_,edges_] := ((Partition[#,2,1,1]& /@ faces)/.edgeRules[edges,label])
augmentFaces[ head_[faces_] -> properties_ , label_, edges_ ] :=
	MapThread[
		Property[ head[#1] , #2]&,
		{
			((Partition[#,2,1,1]& /@ faces) /. edgeRules[edges,label])[[All,All,1]],
			properties
		}
	]


DivideFaces[f : Except[_List]][m : mechanismPattern ] := With[ {edges = f[m]}, 
	If[ MatrixQ[edges] && Length[edges[[1]]]==2 , DivideFaces[edges][m], Message[DivideFaces::err, f]; m]
]
DivideFaces::err = "`1` did not evaluate to a list of edges when acting on mechanism.";

DivideFaces[ edgeList_?MatrixQ ][m : mechanismPattern ] := 
Module[
{
	cells = unparseCells[ m[[3]] , Face],
	FacelessM = DeleteCells[MechanismCells[_Face]] @ m,
	newCells
},
	newCells = parseCells[ {FacelessM[[1]], FacelessM[[3]], FacelessM[[4]]}, Fold[ (cutFace[#2] /@ #1) &, cells, edgeList /. Dispatch[m[[4]]] ] ];
	Head[m][ newCells[[1]], {}, newCells[[2]], newCells[[3]] , m[[5]] ]
]
DivideFaces[ m : mechanismPattern, edgeList_ ] := addMeshRegion[ DivideFaces[edgeList][m], Automatic, {} ]

cutFace[ {v1_,v2_}][Face[{a___,v1_,b__,v2_,c___}, prop_] ] := {Face[{v1,b,v2},prop],Face[{v2,c,a,v1},prop]}
cutFace[ {v2_,v1_}][Face[{a___,v1_,b__,v2_,c___}, prop_] ] := {Face[{v1,b,v2},prop],Face[{v2,c,a,v1},prop]}
cutFace[ _ ][f_] := f


(*a single face or edge is specified*)
SubdivideCells[ indices_?VectorQ , label_ : Unique[] ][ m : mechanismPattern ] :=
With[ {tmp = SubdivideCells[ {indices},label][m]},
	Head[tmp][ tmp[[1]], tmp[[2]],tmp[[3]], replaceRules[ tmp[[4]], {label[indices] -> label}] , tmp[[5]]]
]

(*a list of faces or edges is specified*)
SubdivideCells[ indices : {{_,__}...} , label_ : Unique[] ][ m : mechanismPattern ] := 
Module[
{
	cells = DeleteCases[ mechanismCellList[ "Threaded", m, {_, indices}, None, _], _String[_] ]
},
	AddCells[ subdivideCellsInternal[ m[[1]], # , label] & /@ cells ] @ DeleteCells[ cells[[All,1]] ] @ m
]
(*use a function to identify a list of cells*)
SubdivideCells[ f : Except[_List], label_ : Unique[] ][ m : mechanismPattern ] := With[ {cells = f[m]}, 
	If[ Head[cells]===f, Message[SubdivideCells::err, f]; m, SubdivideCells[cells, label][m] ]
]

SubdivideCells::err="`1` did not evaluate to a list of cells to subdivide when acting on mechanism.";

SubdivideCells[ m : mechanismPattern, indices_, label_ : Unique[] ] := With[{out=addMeshRegion[SubdivideCells[indices, label][m], Automatic, {} ]},
	out /; MechanismQ[out]
]


(*an edge cell*)
subdivideCellsInternal[ coordinates_ , Rule[ head_[indices_?MatrixQ ], data_ ] , label_] := With[
{ newVertices = label /@ indices, newVertexCoordinates = Mean[coordinates[[#]]]&/@indices},
	{
		MapThread[FreeJoint[ #1 -> #2 ]& , {newVertices, newVertexCoordinates} ],
		(*new edges*)
		MapThread[ head[ {{#1[[1]],#2},{#2, #1[[2]]}}, #3]&, { indices, newVertices, data } ]
	}
] /; Length[indices[[1]]]==2

(*a face cell*)
subdivideCellsInternal[ coordinates_, Rule[ head_[ indices : {{_,_,__}...} ], data_ ] , label_] := With[
{
	newVertices = label /@ indices, newVertexCoordinates = Mean[ coordinates[[#]] ]&/@indices
},
	{
		MapThread[ FreeJoint[ #1 -> #2 ]&, {newVertices, newVertexCoordinates} ],
		(*new Faces*)
		MapThread[ head[ splitFace[ #1, #2 ] , #3]&  , { indices , newVertices , data } ]
	}
]
splitFace[ indices_ , newVertex_ ] := {newVertex, #[[1]], #[[2]] } & /@ Partition[ indices , 2, 1, 1]


TriangulateFaces[ m : mechanismPattern ] :=
Module[
{
	cells = unparseCells[ m[[3]] , Face],
	newm = DeleteCells[ MechanismCells[_Face] ] @ m,
	coordinates = m[[1]],
	newcells
},
	newcells = parseCells[ {newm[[1]],newm[[3]],newm[[4]]}, decomposeFace[ coordinates, # ]& /@ cells ];
	addMeshRegion[ Head[m][newcells[[1]], {}, newcells[[2]], newcells[[3]], m[[5]]], Automatic, {} ]
]


decomposeFace[ coordinates_, Face[{i_,j_,k_}, prop_] ] := Face[{i,j,k}, prop]
decomposeFace[ coordinates_, Face[ i_ , prop_] ] := With[{diag = findShortestDiagonal[ coordinates, i ]},
	{TorsionalFold[diag],decomposeFace[ coordinates, # ] & /@ cutFace[diag][Face[i, prop]]}
]
decomposeFace[ coordinates_, other_ ] := other

findShortestDiagonal[ coordinates_, vertices : {__Integer} ] :=
With[ {diagonals = polygonDiagonals[ vertices ]},
	MinimalBy[ Transpose[ { diagonals , Mechanisms`geometry`DisplacementLength[ coordinates, diagonals ] } ] , N[Last[#]]& ][[1,1]]
]
polygonDiagonals[ vertices_ ] := With[ {guesses = Tuples[ Range[Length[vertices]], 2 ], l = Length[vertices]},
	DeleteDuplicatesBy[ Map[ vertices[[#]]&, Select[ guesses, Between[ Abs[ #[[1]] - #[[2]] ],  {2, Length[vertices]-2} ] & ], {2} ], Sort]
]


Linkage["Examples"]:={PinnedFourBarLinkage, PolygonalLinkage, ChainLinkage, WattLinkage,ConnellyServatiusLinkage,Connelly2ndOrderRigidLinkage . PeaucellierLinkage};


Linkage[ PinnedFourBarLinkage[ {width_ , height_} ] ] := Linkage[{{0,0},{0,height},{width,height},{width,0}},{RigidBar[{{1,2},{2,3},{3,4}}],PinnedJoint[{1,4}]}]
Linkage[ PinnedFourBarLinkage|PinnedFourBarLinkage[] ] := Linkage[{{0,0},{0,1},{1,1},{1,0}},{RigidBar[{{1,2},{2,3},{3,4}}],PinnedJoint[{1,4}]}]

Linkage[ ChainLinkage[n_Integer?Positive, {start_?(VectorQ[#,NumericQ]&), end_?(VectorQ[#,NumericQ]&)}] ] := 
	Linkage[
		Join[{start,end},start + (end-start) #/n &/@ Range[n]],
		{RigidBar/@Partition[Range[3,n+1],2,1],RigidBar[{1,3}],RigidBar[{2,n+1}]}
	] /; Length[start] == Length[end]

Linkage[PolygonalLinkage[n_Integer?Positive]] := Linkage[CirclePoints[n],RigidBar/@Partition[Range[n],2,1,1]]

Linkage[ WattLinkage|WattLinkage[] ] := Linkage[ {{0,0},{1,0},{1+Cos[Pi/4],Sin[Pi/4]},{2+Cos[Pi/4],Sin[Pi/4]}}, {RigidBar[{{1,2},{2,3},{3,4}}], PinnedJoint[1],PinnedJoint[4]} ]
Linkage[ WattLinkage[middle_] ] := Linkage[ {{0,0},{1,0},{1+middle Cos[Pi/4],middle Sin[Pi/4]},{2+middle Cos[Pi/4],middle Sin[Pi/4]}}, {RigidBar[{{1,2},{2,3},{3,4}}], PinnedJoint[1],PinnedJoint[4]} ]

Linkage[ ConnellyServatiusLinkage|ConnellyServatiusLinkage[] ] := Linkage[
	{{-2-1/Sqrt[2],0},{-1-1/Sqrt[2],0},{-1-1/(2 Sqrt[2]),1/(2 Sqrt[2])},{-1,1/Sqrt[2]},{0,1/Sqrt[2]},{-1-1/Sqrt[2],1/Sqrt[2]},{2+1/Sqrt[2],0},{1+1/Sqrt[2],0},{1/4 (4+Sqrt[2]),1/(2 Sqrt[2])},{1,1/Sqrt[2]},{1+1/Sqrt[2],1/Sqrt[2]}},
	{
	RigidBar[{{1,2},{2,3},{2,6},{3,4},{3,6},{3,9},{4,5},{4,6},{7,8},{8,9},{8,11},{9,10},{9,11},{10,5},{10,11}}],
	PinnedJoint[{1,5,7}]
	}
]
Linkage[Connelly2ndOrderRigidLinkage|Connelly2ndOrderRigidLinkage[]] := PlaceVertices[
	Linkage[
	{{0,0,0},{0,1,0},{0,0,1},{1,0,0},{1,1,0},{0,1,0.001},{1,0,0.001}},
	 {
	RigidBar[{{1,2},{1,3},{1,4},{1,6},{1,7},{2,3},{2,5},{2,7},{3,4},{3,5},{4,5},{4,6},{5,6},{5,7},{6,7}}],
	PinnedJoint[1],
	Property[PinnedJoint[2],"ConstraintFunction"->(#[[{1,3}]]&) ],
	Property[PinnedJoint[3],"ConstraintFunction"->(#[[1]]&)]
	}] ,
	{{0,0,0},{0,1,0},{0,0,1},{1,0,0},{1,1,0},{0,1,0},{1,0,0}}
]


Linkage[PeaucellierLinkage|PeaucellierLinkage[]] := Linkage[
	{{0,0},{1,0},{2,0},{5/2,1/2},{3,0},{5/2,-1/2}},
	{
	RigidBar[{{1,6},{1,4}}],RigidBar[{2,3}],RigidBar[{3,4,5,6,3}], PinnedJoint[{1,2}],
	Property[FreeJoint[5], {"Style" -> Blue, "Shape" -> FreeJointShape["Diameter" -> 0.06] }]
	}
]


Linkage[Pantograph[width_ : 1/2]]:=
With[{w = Clip[width,{0,1}]},
	Linkage[{{0,0},{1/2,1/2},{1,0},{1/4,1/4},{1/2,1/2} + w {1,-1}/Sqrt[2],{1/4,1/4} + w {1,-1}/Sqrt[2]},
		{RigidBar[{{1,2},{2,3}}],StraightJoint[{1,2,3}],StraightJoint[{2,3,4}],RigidBar[{4,6}],RigidBar[{6,5}],PinnedJoint[1]}
	]
]


Linkage[KagomeUnitCell[size : _?NumericQ : 1]] := 
	Linkage[
		size*{{-(Sqrt[3]/2),-(1/2)},{0,1},{Sqrt[3]/2,-(1/2)},{Sqrt[3],-2},{(3 Sqrt[3])/2,-(1/2)}},
		{FreeJoint[{1,2,3,4,5}],RigidBar[{{1,3},{2,1},{3,2},{3,4},{4,5},{5,3}}],Face[{{1,3,2},{3,4,5}}]}
	]


Linkage[SarrusLinkage[ inputPolygon_Polygon ] ] := 
With[ {p = CanonicalizePolygon[inputPolygon]},
	With[{
		coord = p[[1]]-ConstantArray[ Mean[p[[1]]], Length[p[[1]]] ],
		midfaces = Partition[ Riffle[# + 2 Length[p[[2]]]& /@  p[[2]], RotateLeft[#+3 Length[p[[2]]]& /@ p[[2]]]], 2 ]
		},
	With[{
		norm = 0 Cross[ Cross[#[[1]],#[[2]]], #[[1]]-#[[2]]]& /@ Partition[{#[[1]],#[[2]],0}&/@coord,2,1,1]
	},
		Linkage[
			Join[ {#[[1]],#[[2]],-1/2}& /@ coord, {#[[1]],#[[2]],1/2}& /@ coord , -norm + ({#[[1]],#[[2]],0}& /@ coord) ,  norm + ({#[[1]],#[[2]],0}& /@ coord) ], 
			{
			Face[p[[2]]], Face[ (#+Length[p[[2]]]&) /@ p[[2]]],
			Map[Face , Flatten/@Transpose[{Partition[p[[2]],2,1,1], Reverse /@ midfaces}] ],
			Map[Face , Flatten/@Transpose[{midfaces, Reverse /@ Partition[ #+ Length[p[[2]]]& /@ p[[2]] , 2, 1, 1]}] ]
			},
			OverlapPrecision->0
		]
]]] /; RegionEmbeddingDimension[inputPolygon] == 2


Origami[ "Examples" ] := { BirdsFoot, SingleVertex, RandlettBirdOrigami, WaterBombBase, MiuraOriCell, SteffanPolyhedron };


Origami[ BirdsFoot|BirdsFoot[] ] := Origami[ SingleVertex[ {Pi/4, 3 Pi/4 ,3 Pi /4, Pi/4} ]]
Origami[ BirdsFoot[a_?NumericQ] ] := Origami[ SingleVertex[ {a,  Pi - a ,Pi - a, a} ] ] /; 0 < a < Pi


Origami[ SingleVertex[an_] ] ^:= 
Origami[
	Join[
		{{0,0}},
		{ Cos[#],Sin[#] }& /@ Join[ {0}, Drop[Accumulate[ an ],-1] ]
	],
	Face[ {1,#[[1]],#[[2]]} ]& /@ Partition[ Range[2,1+Length[an]], 2, 1 , 1]
] /; VectorQ[ an, NumericQ] && Length[an] >= 3


Origami[ RandlettBirdOrigami|RandlettBirdOrigami[] ] := 
	Origami[
		N@{{0,0,0},{1.414278593427568`,-0.00012107343015166361`,0},{1.4142678318232762`,1.4140274916158289`,0},{0.00011927863201000033`,1.414016642177331`,0},{1.4142692917736754`,1.227825699827347`,0},{1.3131744350755659`,1.211870419723824`,0},{1.2781932400501788`,1.2779508631318839`,0},{0.9659583817161155`,0.9657127724823382`,0},{1.0728360008415996`,0.7312622802432727`,0},{0.47189742974276605`,0.9427579377876374`,0},{0.353962452288944`,0.7077633593785156`,0},{1.2121120814828474`,1.312933079920714`,0},{1.2280642010424148`,1.4140260798657769`,0},{0.731505784488571`,1.0725852346780647`,0},{0.7073110670506855`,0.3537763181270138`,0},{0.9430090748133337`,0.47164965094818173`,0},{0.7074588006059522`,0.7069478151898358`,0},{1.4142724979918373`,0.8060679230868013`,0},{0.8063082321157269`,1.4140228586178498`,0},{0.23507732779834628`,1.1102230246251565`*^-16,0},{0.0001931022705954355`,0.2355241969949885`,0}},
		{
		Face[{{15,20,1},{1,17,15},{11,17,1},{1,21,11},{18,2,16},{16,9,18},{16,2,15},{15,2,20},{13,3,12},{12,3,7},{7,3,6},{6,3,5},{21,4,11},{11,4,10},{10,4,19},{19,14,10},{6,5,18},{18,9,6},{8,7,6},{6,9,8},{12,7,8},{8,14,12},{14,8,17},{17,10,14},{17,8,9},{9,16,17},{11,10,17},{19,13,12},{12,14,19},{16,15,17}}],
		"faces" /@ {{1,11},{1,15},{6,8},{6,18},{8,12},{9,17},{10,19},{12,19},{14,17},{16,18}}
		}
	]

Origami[ RandlettBirdOrigami[ "Folded" ] ] :=
	Origami[
		{{0.5216212272644043`,0.0041301921010017395`,-0.5215774178504944`},{-0.6376347541809082`,0.4420289695262909`,-0.16293174028396606`},{-0.435793399810791`,-0.10257021337747574`,0.4356272220611572`},{0.16264325380325317`,0.442157119512558`,0.6371942758560181`},{-0.4927003085613251`,0.07479492574930191`,0.4173307418823242`},{-0.4104839861392975`,0.11236074566841125`,0.36908411979675293`},{-0.4352164566516876`,0.0874059870839119`,0.43510642647743225`},{-0.22010493278503418`,-0.2338118851184845`,0.22003494203090668`},{-0.13188940286636353`,-0.15577159821987152`,-0.008406173437833786`},{0.11944180727005005`,0.1096508726477623`,0.06939235329627991`},{0.047771066427230835`,-0.13527639210224152`,0.09195645153522491`},{-0.3691454231739044`,0.11233522742986679`,0.410442054271698`},{-0.4174804091453552`,0.07477816939353943`,0.49260756373405457`},{0.00845295935869217`,-0.15610502660274506`,0.13212451338768005`},{-0.09123314917087555`,-0.13514138758182526`,-0.04728326201438904`},{-0.06939570605754852`,0.11028251051902771`,-0.11917997896671295`},{-0.18727263808250427`,0.1310577541589737`,0.1871875524520874`},{-0.41846323013305664`,-0.254423052072525`,0.16566649079322815`},{-0.1659073531627655`,-0.25454390048980713`,0.4185855984687805`},{0.3550601601600647`,-0.1361958533525467`,-0.4324187636375427`},{0.43267032504081726`,-0.13634231686592102`,-0.35442548990249634`}},
		{
		 Face[{{15,20,1},{1,17,15},{11,17,1},{1,21,11},{18,2,16},{16,9,18},{16,2,15},{15,2,20},{13,3,12},{12,3,7},{7,3,6},{6,3,5},{21,4,11},{11,4,10},{10,4,19},{19,14,10},{6,5,18},{18,9,6},{8,7,6},{6,9,8},{12,7,8},{8,14,12},{14,8,17},{17,10,14},{17,8,9},{9,16,17},{11,10,17},{19,13,12},{12,14,19},{16,15,17}}],
		 "faces" /@ {{1,11},{1,15},{6,8},{6,18},{8,12},{9,17},{10,19},{12,19},{14,17},{16,18}}
		}
	]


Origami[ WaterBombBase|WaterBombBase[] ] :=
	Origami[
		{{1/2,1/2},{0,0},{1/2,1/4},{1,0},{3/4,1/2},{1,1},{1/2,3/4},{0,1},{1/4,1/2},{1/2,0},{1,1/2},{1/2,1},{0,1/2}},
		{
		Face[{
		{1,2,3},{1,3,4},{1,4,5},{1,5,6},{1,6,7},{1,7,8},{1,8,9},{1,9,2},
		{2,10,3},{3,10,4},{5,4,11},{5,11,6},{7,6,12},{7,12,8},{9,8,13},{13,2,9}
		}]
		}
	]


Origami[ MiuraOriCell[x_?NumericQ] ]  /; -1/2 < x < 1/2 :=
	Origami[
		{
		{3/4,1/2},{0,0},{1/2+x,0},{1,0},{5/4,1/2},{1,1},{1/2+x,1},{0,1},{1/4,1/2}
		},
		{
		Face[{{1,9,2,3},{1,3,4,5},{1,5,6,7},{1,7,8,9}}]
		}
	]

Origami[ MiuraOriCell[ x_?NumericQ , "Triangulated" ] ]  /; -1/2 < x < 1/2 :=
		Origami[
		{
		{3/4,1/2},{0,0},{1/2+x,0},{1,0},{5/4,1/2},{1,1},{1/2+x,1},{0,1},{1/4,1/2}
		},
		{
		Face[{{1,9,3},{9,2,3},{1,3,4},{1,4,5},{1,5,6},{1,6,7},{1,7,9},{7,8,9}}],
		"faces"/@{{1,4},{1,6},{9,7},{9,3}}
		}
	]
Origami[ MiuraOriCell[x_, ___ ] ] := "nothing" /; Message[MiuraOriCell::offset,x]

MiuraOriCell::offset = "Offset `1` is not strictly between -1/2 and 1/2.";


Origami[ SteffanPolyhedron|SteffanPolyhedron[] ] := Origami[ SteffanPolyhedron[0] ]
Origami[ SteffanPolyhedron[t_?NumericQ] ] := Module[{ m, p, e, l, f,  en, pos},
	p = {{0,0,0},{-12,0,0},{1/24,-17 Sqrt[287]/24,0},
		{-3,4 Cos[t],4 Sin[t]},{-5,-6,-7/2},{7/2,1/10,-9},{-5,-5,-8},
		{-34/10,-97/10,-91/10},{-4,-3,-1/2}};
	e = {{3,1}, {1,2},{1,4},{1,6},{2,3}, {2,4},{4,5},{2,5},{4,6},{1,6},{2,7},{3,7},{5,6},{6,7},{5,7},{3,8},{6,8},{7,8},{3,9},{1,9},{6,9}};
	l = { 12, 12, 5, 10, 17, 10, 11, 10, 12, 10,12,12,12,10,5, 10,12, 5, 10,5,12 };
	f = {{1,2,3},{7,3,2},{1,4,2},{2,4,5},{2,5,7},{1,6,4},{4,6,5},{5,6,7},{6,8,7},{6,9,8},{1,9,6},{3,7,8},{3,8,9},{1,3,9}};

	m = ChangeCellData[MechanismFaceCells, "Style"->Opacity[0.5]] @ ChangeCellData[ RigidBar[e], "EquilibriumLength" -> l ] @ Origami[ p, Face[f] ];
	{en, pos} = Mechanisms`rigidity`MinimizeMechanismEnergy[ m , MaxIterations->10^5, Constraints->{Mechanisms`rigidity`EuclideanMotionConstraints[{1,2,3}]}];
	PlaceVertices[ m, pos ]
]


End[];

EndPackage[];


BeginPackage["Mechanisms`geometry`"];


(* 
	A snippet of code to test or a working C compiler, modified from
	https://mathematica.stackexchange.com/questions/39837/check-whether-a-working-ccompiler-is-installed
*)
If[Quiet[Check[TrueQ[Compile[{}, 0, CompilationTarget -> "C"][] == 0], False]],
  $MechanismCompilationTarget = "C",
  $MechanismCompilationTarget = "MVM"
];


ZeroLengthEdgeQ::usage="ZeroLengthEdgeQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)], ZeroLengthEdgeQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\)] returns True if \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) has any 0 length edges.";

MechanismCellTest::usage="MechanismCellTest[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {{\!\(\*
StyleBox[SubscriptBox[\"v\", \"11\"],\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[SubscriptBox[\"v\", \"12\"],\nFontSlant->\"Italic\"]\), ..}, {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(21\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(22\)]\), ..}, ...} , \!\(\*
StyleBox[\"geometric\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"computation\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"test\",\nFontSlant->\"Italic\"]\) ] returns a list of cell indices such \!\(\*
StyleBox[\"test\",\nFontSlant->\"Italic\"]\) applied to \!\(\*
StyleBox[\"geometric\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"computation\",\nFontSlant->\"Italic\"]\) is True.
MechanismCellTest[{{\!\(\*
StyleBox[SubscriptBox[\"v\", \"11\"],\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[SubscriptBox[\"v\", \"12\"],\nFontSlant->\"Italic\"]\), ..}, {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(21\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(22\)]\), ..}, ...} , \!\(\*
StyleBox[\"geometric\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"computation\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"test\",\nFontSlant->\"Italic\"]\) ] can be applied to a mechanism.";


$MechanismCompilationTarget::usage = "Returns \"C\" if a C compiler was detected or \"MVM\" otherwise.";

Infinitesimal::usage = "Infinitesimal[ \!\(\*
StyleBox[\"name\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"order\",\nFontSlant->\"Italic\"]\) ] represents an Infinitesimal of name and at a particular order.";


DisplacementRules::usage = "DisplacementRules[\!\(\*
StyleBox[\"displacements\",\nFontSlant->\"Italic\"]\)] returns a list of rules to assign vertex displacements to their values.
DisplacementRules[ {\!\(\*SubscriptBox[
StyleBox[\"positions\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] returns a list of rules for each set of \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\).
DisplacementRules[ \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\) ] returns displacement rules from a periodic mechanism data structure.
DisplacementRules[ \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"k\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] returns displacement rules from a periodic mechanism with a different set of reciprocal wave vectors {\!\(\*SubscriptBox[
StyleBox[\"k\",\nFontSlant->\"Italic\"], \(\[Placeholder]\)]\), ...}.";

PositionRules::usage = "PositionRules[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns rules setting the positions of mechanism m.
PositionRules[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\) ] returns a list of rules assigning vertex positions to their values.
PositionRules[ {\!\(\*SubscriptBox[
StyleBox[\"positions\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] returns a list of rules for each set of positions.
PositionRules[ \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\) ] returns position rules from a periodic mechanism data structure.
PositionRules[ \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"lattice\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"vectors\",\nFontSlant->\"Italic\"]\) ] returns position rules from a periodic mechanism with a different set of lattice vectors.";

PositionConstraints::usage="PositionConstraints[ \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"lattice\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"vectors\",\nFontSlant->\"Italic\"]\) ] returns a set of constraints associated with periodic data provided given lattice vectors.";

OrthogonalizeDisplacements::usage="OrthogonalizeDisplacements[ {\!\(\*SubscriptBox[
StyleBox[\"displacement\",\nFontSlant->\"Italic\"], \(1\)]\), ...} ] returns an orthogonalized set of vertex displacements
OrthogonalizeDisplacements[ {\!\(\*SubscriptBox[
StyleBox[\"displacement\",\nFontSlant->\"Italic\"], \(1\)]\), ...}, \!\(\*
StyleBox[\"tolerance\",\nFontSlant->\"Italic\"]\) ]  uses \!\(\*
StyleBox[\"tolerance\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)to orthogonalize.";

VertexCoordinatesQ::usage= "VertexCoordinatesQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) are valid coordinates for mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)." ;
VertexCoordinateListQ::usage= "VertexCoordinateListQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) are a list of valid positions for mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)." ;
NumericCoordinatesQ::usage= "NumericCoordinatesQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) are valid numerical coordinates for mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)." ;
NumericMachinePrecisionCoordinatesQ::usage= "NumericMachinePrecisionCoordinatesQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"pos\",\nFontSlant->\"Italic\"]\) are valid numerical, machine precision coordinates for mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";


MechanismConnectivity::usage = "MechanismConnectivity[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(2\)]\) ] returns a list cells of type \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(2\)]\) connected to each cell of type \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(1\)]\). 
MechanismConnectivity[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*
StyleBox[\"test\",\nFontSlant->\"Italic\"]\)] returns a list of cells of type \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(1\)]\) when \!\(\*
StyleBox[\"test\",\nFontSlant->\"Italic\"]\) applied to MechanismConnectivity[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(2\)]\)] is True.

Possible choices of \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(1\)]\) are \"vertices\", \"edges\", or \"faces\". Possible types for \!\(\*SubscriptBox[
StyleBox[\"s\",\nFontSlant->\"Italic\"], \(2\)]\) are \"vertices\", \"edges\", \"faces\", \"ordered edges\", or \"ordered faces\".";

MechanismOrientedQ::usage = "MechanismOrientedQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns True if all Faces in a mechanism are oriented with their neighbors.";

BoundaryVertices::usage="BoundaryVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns a list of oriented boundary vertices belonging to boundary components { \!\(\*
StyleBox[SubscriptBox[\"c\", \"1\"],\nFontSlant->\"Italic\"]\), ...}.
A boundary is defined as the boundary of a set of faces.";
BoundaryEdges::usage="BoundaryEdges[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns a list of oriented boundary edges {{\!\(\*SubscriptBox[\(v\), \(11\)]\), \!\(\*SubscriptBox[\(v\), \(12\)]\)},{\!\(\*SubscriptBox[\(v\), \(21\)]\),\!\(\*SubscriptBox[\(v\), \(11\)]\)},...}.
A boundary is defined as the boundary of a set of faces.";
BoundaryFaces::usage="BoundaryFaces[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns a list of oriented boundary components {{\!\(\*SubscriptBox[\(f\), \(1\)]\), \!\(\*SubscriptBox[\(f\), \(\(2\)\(,\)\)]\)...}, ...}.";
InteriorVertices::usage="InteriorVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns a list of interior vertices.";
InteriorEdges::usage="InteriorEdges[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns a list of interior edges.";

MechanismDisplayDimension::usage=
"MechanismDisplayDimension[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns the display dimension of a Mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).
MechanismDisplayDimension[ \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\) ][ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ], MechanismDisplayDimension[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\)] changes the display dimension of a mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) to \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\).";

MechanismEmbeddingDimension::usage=
"MechanismEmbeddingDimension[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns the embedding dimension of a Mechanism m.
MechanismEmbeddingDimension[ \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\) ][ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ], MechanismEmbeddingDimension[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\)] changes the embedding dimension of mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) to \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\).";


SaveToFOLD::usage="SaveToFOLD[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"filename\",\nFontSlant->\"Italic\"]\)] saves a FOLD file from mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";
LoadFromFOLD::usage=
"LoadFromFOLD[\!\(\*
StyleBox[\"filename\",\nFontSlant->\"Italic\"]\)] loads a Mechanism from a FOLD. Use option \"Face\" to choose how to treat a polygon.";


PeriodicIdentification::usage=
"PeriodicIdentification[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns a PeriodicIdentificationData object if a mechanism has periodic data attached to it.
PeriodicIdentification[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"f\",\nFontSlant->\"Italic\"], \(1\)]\) \[RightArrow] \!\(\*SubscriptBox[
StyleBox[\"func\",\nFontSlant->\"Italic\"], \(1\)]\),..} ] applies transformation functions \!\(\*SubscriptBox[
StyleBox[\"func\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"func\",\nFontSlant->\"Italic\"], \(2\)]\), ... and creates a list of vertices identified via those transformations.
PeriodicIdentification[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"z\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"z\",\nFontSlant->\"Italic\"], \(2\)]\),...}, {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\), ...}] identifies vertices under translation vectors {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\), ...} and returns rules identifying VertexDisplacement objects up to corresponding factors of {\!\(\*SubscriptBox[
StyleBox[\"z\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"z\",\nFontSlant->\"Italic\"], \(2\)]\),...}.
PeriodicIdentification[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\), ...}] identifies vertices under translation vectors {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\), ...} and returns rules identifying VertexDisplacement objects.";

PeriodicIdentificationData::usage="PeriodicIdentificationData is a structure for periodic Mechanisms.";
PeriodicIdentificationDataQ::usage="PeriodicIdentificationDataQ[ \!\(\*
StyleBox[\"pi\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"pi\",\nFontSlant->\"Italic\"]\) is a PeriodicIdentificationData structure.
PeriodicIdentificationDataQ[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pi\",\nFontSlant->\"Italic\"]\) ] returns True if \!\(\*
StyleBox[\"pi\",\nFontSlant->\"Italic\"]\) is a PeriodicIdentificationData structure that can correspond to Mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\).";

MechanismUnitCell::usage=
"MechanismUnitCell[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] reduces a periodic mechanism to a smallest unit cell that has periodic data attached to it.
MechanismUnitCell[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"vector\",\nFontSlant->\"Italic\"], \(2\)]\), ...}] reduces a Mechanism to the smallest unit cell that can be tesselated periodically according to the basis of vectors provided.
It relies on PeriodicIdentification[] but unfortunately renumbers vertices.";
DeleteDanglingVertices::usage="DeleteDanglingVertices is an option for MechanismUnitCell[] to determine whether disconnected vertices should be deleted.";

LabelPeriodicVertices::usage="LabelPeriodicVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"style\",\nFontSlant->\"Italic\"]\) ], LabelPeriodicVertices[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"periodic\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\) ] labels a mechanism consistent with its periodic data using a text style.";

MakePeriodic::usage="MakePeriodic[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"basis\",\nFontSlant->\"Italic\"]\)], MakePeriodic[\!\(\*
StyleBox[\"basis\",\nFontSlant->\"Italic\"]\)][\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] makes a mechanism periodic using provided basis vectors. This attaches automatic periodicity constraints to the mechanism.";
PeriodicMechanismQ::usage="PeriodicMechanismQ[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns True if a mechanism is periodic.";


DisplacementVector::usage=
"DisplacementVector[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"edge\",\nFontSlant->\"Italic\"]\) ] returns the vector pointing along an oriented edge.
DisplacementVector[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), { \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns list of displacement vectors.";

DisplacementLength::usage=
"DisplacementLength[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"edge\",\nFontSlant->\"Italic\"]\) ] returns the length of an edge.
DisplacementLength[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), { \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns lengths of a list of edges.";

DisplacementLengthSquared::usage=
"DisplacementLengthSquared[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"edge\",\nFontSlant->\"Italic\"]\) ] returns the squared length of an edge.
DisplacementLengthSquared[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), { \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns squared lengths of a list of edges.";

vectorAngle::usage=
"vectorAngle[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)}] returns the angle at vertex 2 spanned by the other two points.
vectorAngle[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the vertex angles anong a list of vertex triples.";

TurningAngle::usage=
"TurningAngle[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)}] returns the turning angle at vertex 2 spanned by the other two points.
TurningAngle[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the turning angles anong a list of vertex triples.";

NormalVector::usage=
"NormalVector[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)} ] returns the vector normal to the plane spanned by the three points.
NormalVector[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns vectors normal to the plane spanned by the list of triples.
NormalVector[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"polygon\",\nFontSlant->\"Italic\"]\) ] returns the vector normal to a polygon.
NormalVector[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"polygon\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"polygon\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the vectors normal to a list of polygons.";

FaceArea::usage=
"FaceArea[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)} ] returns the area of the Face spanned by the three points.
FaceArea[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the area of the Face spanned by the list of triples.
FaceArea[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"polygon\",\nFontSlant->\"Italic\"]\) ] returns area of a polygon.
FaceArea[ \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"polygon\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"polygon\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the areas of a list of polygons.";

PlaneAngle::usage=
"PlaneAngle[\!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)} ] returns the oriented angle at vertex v2 spanned by the other two vertices.
PlaneAngle[\!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"triple\",\nFontSlant->\"Italic\"], \(2\)]\), ...}] returns the oriented angles at for each triple of verticles.";

TorsionalFoldAngle::usage=
"TorsionalFoldAngle[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"edge\",\nFontSlant->\"Italic\"]\) ] returns the TorsionalFold angle along an edge.
TorsionalFoldAngle[ m, \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), { \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"edge\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the TorsionalFold angle of a list of edges.";

DiscreteGaussianCurvature::usage=
"DiscreteGaussianCurvature[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"vertex\",\nFontSlant->\"Italic\"]\) ] returns the discrete Gaussian curvature of vertex.
DiscreteGaussianCurvature[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ] returns the discrete Gaussian curvature of a list of vertices.
DiscreteGaussianCurvature[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"metric\",\nFontSlant->\"Italic\"]\), {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\), ...} ] uses a metric to explicitly compute the Gaussian curvature at each vertex.";

AlignMechanism::usage="AlignMechanism[ \!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(2\)]\) ] returns a list of positions that best align the second Mechanism to the first.
\!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(1\)]\) and \!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(2\)]\) can be either be a Mechanism, a list of positions, { \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"vertices\",\nFontSlant->\"Italic\"]\) }, or {\!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"vertices\",\nFontSlant->\"Italic\"]\)}.
If vertices are included, only the specified vertices will be used to determine the transformation.";

CongruentMechanismQ::usage="CongruentMechanismQ[ \!\(\*
StyleBox[\"tol\",\nFontSlant->\"Italic\"]\) ][ \!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(2\)]\) ] returns True if the first and second mechsnisms are congruent up to a given tolerance \!\(\*
StyleBox[\"tol\",\nFontSlant->\"Italic\"]\).
\!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(1\)]\) and \!\(\*SubscriptBox[
StyleBox[\"mSpec\",\nFontSlant->\"Italic\"], \(2\)]\) can be either be a Mechanism, a list of positions, { \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"vertices\",\nFontSlant->\"Italic\"]\) }, or {\!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"vertices\",\nFontSlant->\"Italic\"]\)}.
If vertices are included, only the specified vertices will be used to determine the transformation.";


Begin["`Private`"];

Needs["Mechanisms`"];


listParameters[expr_]:=DeleteDuplicates[(Extract[expr,#]&)/@Position[List@@expr,Infinitesimal[_,_]]]


(*
	This basically does what Series[] does in a somewhat dumber way.
	It won't handle limits as nicely as Series[] but it typically presents results that look
	more useful for analytic expressions.
*)
expandExpression[expr_,param_]:=Module[
{i,tmp},
	Total[Table[(tmp@@param)^i D[expr,{param,i}]/(i!),{i,0,param[[2]]}]/.param->0]/.tmp->Infinitesimal
]
expandExpression[expr_?NumericQ]:=expr
expandExpression[expr_]:=With[{params=listParameters[expr]},
	Fold[expandExpression,expr,Reverse@params]
]


orderPairs[{}]:={}
orderPairs[pairList_?(MatrixQ[#,IntegerQ]&)]:=
	orderPairsTopologicalSort[Graph[UndirectedEdge@@@pairList]]/; Dimensions[pairList][[2]]==2

orderPairs[pairList_,correspondingList_]:=
With[
{
association=Dispatch@Thread[pairList->correspondingList]
},
	orderPairs[pairList]/.association
]/; Length[pairList]==Length[correspondingList]


(* this does a topological sort on a graph *)
orderPairsTopologicalSort[g_?AcyclicGraphQ]:=Partition[TopologicalSort[DirectedEdge@@@EdgeList[g]],2,1]
orderPairsTopologicalSort[g_Graph]:=List@@@(First@FindCycle[g,Infinity,1])


rotateTo[s_List,v_]:=With[{pos=FirstPosition[s,v]},If[MissingQ[pos],s,RotateLeft[s,pos[[1]]-1]]]
rotateTo[h_[s_List],v_]:=h[rotateTo[s,v]]


orderFaces[FaceList_,v_Integer]:=orderPairs[{#[[2]],Last[#]}&/@FaceList,FaceList]


MechanismConnectivity["Methods"]:={{"vertices","edges","faces"}->{"vertices","edges","faces","ordered faces","ordered edges"}};


MechanismConnectivity[ m_?MechanismQ, "faces" -> "vertices" ] := m["faces"]
MechanismConnectivity[ m_?MechanismQ, "edges" -> "vertices" ] := m["edges"]


MechanismConnectivity[ m_?MechanismQ, "vertices" -> "faces" ] := With[
{ Faces = rotateThroughFaces[ MechanismConnectivity[m, "faces" -> "vertices" ] ] },
	GatherBy[(*unpacks*)
		Join[(*unpacks*)
			Transpose[{Range[Length[ m["VertexCoordinates"] ] ]}], (*make a list of vertices in order of the form {{1},{2},...}*)
			Faces
		],
	First][[All,2;;]]
]

rotateThroughFaces[{}]:={}
(*all faces are the same length*)
rotateThroughFaces[Faces_?MatrixQ]:=Flatten[NestList[RotateLeft[#,{0,1}]&,Faces,Last[Dimensions[Faces]]-1],1]
(*faces are different length*)
rotateThroughFaces[Faces_]:=With[
{
	groupedFaces = GatherBy[Faces, Length]
},
	Flatten[ rotateThroughFaces /@ groupedFaces, 1 ]
]


MechanismConnectivity[ m_?MechanismQ, "faces" -> "edges" ] :=
With[{cells = MechanismConnectivity[m,"faces"->"vertices"]},
	facesTOedges[cells]
]

facesTOedges[cells2_?MatrixQ] := With[{cells=Transpose[cells2]},
	Flatten[Partition[Transpose[Join[cells,{cells[[1]]}]],{1,2},1],{3}][[1]]
]
facesTOedges[cells_] := Partition[ #, 2, 1, 1]&/@cells


(*unpacks*)
MechanismConnectivity[m_?MechanismQ, "edges" -> "faces" ]:=With[
{ edges = MechanismConnectivity[ m, "edges" -> "vertices" ], faces = MechanismConnectivity[ m, "faces" -> "vertices" ] },
	GatherBy[Flatten[{edges,rotateCells[faces]},1],Sort[#[[1;;2]]]&][[All,2;;]]
]

Options[rotateCells]={"Flatten"->True};
rotateCells[cells_ , OptionsPattern[]]:=With[
{sortedCells=GatherBy[cells,Length]},
	Flatten[NestList[RotateLeft[#,{0,1}]&,#,Length[#[[1]]]-1]&/@sortedCells,2]
] /; OptionValue["Flatten"]

rotateCells[cells_ , OptionsPattern[]]:=With[
{sortedCells=GatherBy[cells,Length]},
	First[NestList[RotateLeft[#,{0,1}]&,#,Length[#[[1]]]-1]&/@sortedCells]
]


(*unpacks*)
MechanismConnectivity[ m_?MechanismQ, "vertices" -> "edges" ] :=
With[ {edges = Join[ MechanismConnectivity[ m, "edges" -> "vertices" ],{#,#}&/@Range[m["VertexCount"]]]},
	DeleteCases[SortBy[GatherBy[Flatten[{edges,Reverse[edges,{2}]},1],First],First],{a_,a_},{2}]
]


(*Unpacks lists.*)
MechanismConnectivity[m_?MechanismQ, "edges" -> "ordered faces" ]:=
With[
{
test1=MechanismConnectivity[m,"vertices"->"faces"],
edges=Transpose[ MechanismConnectivity[m, "edges" -> "vertices" ] ]
},
	ToPackedArray@MapThread[
		Join[#1,#2]&,
		{
		MapThread[Cases[#1,{__,#2}]&,{test1[[edges[[1]]]],edges[[2]]}],
		MapThread[Cases[#1,{_,#2,__}]&,{test1[[edges[[1]]]],edges[[2]]}]
		}
	]
]


(*
Unpacks lists.
*)
MechanismConnectivity[m_?MechanismQ, "vertices" -> "ordered faces"]:=With[
{unorderedFace=MechanismConnectivity[m,"vertices"->"faces"]},
	MapThread[orderFaces,{unorderedFace,Range[Length[unorderedFace]]}]
]


MechanismConnectivity[m_?MechanismQ, "vertices" -> "ordered edges"]:= MechanismConnectivity[m,"vertices"->"ordered faces"][[All,All,1;;2]]


MechanismConnectivity[ m_?MechanismQ , "vertices" -> end_String , test_ ]:=
With[{data = MechanismConnectivity[ m, "vertices" -> end]},
	With[{selector = test /@ data},
		If[ VectorQ[ selector, BooleanQ], Pick[ Range[m["VertexCount"]], selector], Message[MechanismConnectivity::test, test, end]; {} ]
	] /; Head[data] =!= MechanismConnectivity
]

MechanismConnectivity[ m_?MechanismQ , start_String -> end_String , test_ ]:=
With[{data = MechanismConnectivity[ m, start -> end]},
	With[{selector = test /@ data},
		If[ VectorQ[ selector, BooleanQ], Pick[ m[start], selector], Message[MechanismConnectivity::test, test, end]; {} ]
	] /; Head[data] =!= MechanismConnectivity
]

MechanismConnectivity::test = "Applying `1` to list of `2` did not yield boolean values.";


MechanismConnectivity::badcombo="Methods `1` -> `2` are not recognized in this combination.";
MechanismConnectivity[m_?MechanismQ , Rule[a_,b_]]:="nothing" /; Message[MechanismConnectivity::badcombo,a,b]


BoundaryEdges[m_?MechanismQ] :=
Module[
{
	FacePairs=MechanismConnectivity[m,"edges" -> "faces"],
	edges=MechanismConnectivity[m, "edges" -> "vertices"],
	boundary
},
	boundary=Pick[ edges, Length /@ FacePairs, 1 ];
	If[ Length[boundary]==0,
		{},
		Map[List@@#&,FindCycle[Graph[boundary],Infinity,All],{2}]
	]
]


BoundaryVertices[m_?MechanismQ] := Map[ First@@#& , BoundaryEdges[m] , {2} ]


BoundaryFaces[m_?MechanismQ]:=
Module[{i},
	With[{
		boundary = BoundaryVertices[m],
		Faces = MechanismConnectivity[m, "faces" -> "vertices" ]
		},
		Table[
			Select[ Faces, ContainsAny[boundary[[i]],#]& ],
			{i,1,Length[boundary]}
		]
	]
]


InteriorEdges[mr_?MechanismQ]:=
With[{testfunction = (#>1&)},
	Pick[
		MechanismConnectivity[ mr, "edges" -> "vertices"],
		testfunction /@ Length /@ MechanismConnectivity[mr, "edges" -> "faces"]
	]
]


InteriorVertices[mr_?MechanismQ]:=
Complement[
	DeleteDuplicates[ Flatten[InteriorEdges[mr]] ],
	Flatten @ BoundaryVertices[mr]
]


MechanismOrientedQ[mr_?MechanismQ]:=
	AllTrue[
		DeleteCases[ MechanismConnectivity[mr,"edges"->"faces"] , {_} ],
		facePairOrientedQ
	]
MechanismOrientedQ[_]:=False


facePairOrientedQ[{v1_,v2_}]:=With[
{
	eg2=Take[RotateLeft[v2,#],2]&/@Range[Length[v2]],
	eg1=Reverse[Take[RotateLeft[v1,#],2]]&/@Range[Length[v1]]
},
	ContainsAny[eg1,eg2]
]
facePairOrientedQ[v1_,v2_]:=With[
{
	eg2=Take[RotateLeft[v2,#],2]&/@Range[Length[v2]],
	eg1=Reverse[Take[RotateLeft[v1,#],2]]&/@Range[Length[v1]]
},
	ContainsAny[eg1,eg2]
]


MechanismEmbeddingDimension[ m_?MechanismQ ]:= m["EmbeddingDimension"]
MechanismEmbeddingDimension[ d : 2|3 ][ m_?MechanismQ ] :=
With[ {oldPositions = m["VertexCoordinates"]},
	ReplacePart[m, 1 -> PadRight[ oldPositions, {Length[oldPositions],d} ] ]
]

MechanismEmbeddingDimension::dim = "Dimension `1` should be 2 or 3.";
MechanismEmbeddingDimension[ d_ ][ m_?MechanismQ ] := "nothing" /; Message[ MechanismEmbeddingDimension::dim, d ]

MechanismEmbeddingDimension[ Rule[ m_?MechanismQ, d_] ] := MechanismEmbeddingDimension[d][m]


MechanismDisplayDimension[ m_?MechanismQ ] := m["DisplayDimension"]

MechanismDisplayDimension [ d: 2|3 ][m_?MechanismQ] := 
With[ {res = Mechanisms`Private`addMeshRegion[m,d,{}]}, res /; MechanismQ[res] ]

MechanismDisplayDimension::dim = "Dimension `1` should be 2 or 3.";
MechanismDisplayDimension[ d_ ][ m_?MechanismQ ] := "nothing" /; Message[ MechanismDisplayDimension::dim, d ]

MechanismDisplayDimension[ Rule[ m_?MechanismQ, d_ ] ] := MechanismDisplayDimension[d][m]


RegionEmbeddingDimension[o_Linkage] ^:= MechanismEmbeddingDimension[o]
RegionEmbeddingDimension[o_Origami] ^:= MechanismEmbeddingDimension[o]

RegionDimension[o_Linkage] ^:= Which[ Length[MechanismFaces[o]]>0, 2, Length[MechanismEdges[o]]>0, 1, True, 0 ]
RegionDimension[o_Origami] ^:= Which[ Length[MechanismFaces[o]]>0, 2, Length[MechanismEdges[o]]>0, 1, True, 0 ]


VertexCoordinatesQ[ coord_ ] := AllTrue[ {MatrixQ[coord], Length[coord[[1]]]==2 || Length[coord[[1]]]==3}, TrueQ ]
VertexCoordinatesQ[ m_?MechanismQ, coord_ ] := AllTrue[ {MatrixQ[coord], Length[coord] == m["VertexCount"]}, TrueQ ]


VertexCoordinateListQ[ coord_ ] := AllTrue[ {ArrayQ[coord], ArrayDepth[coord]==3 , Length[coord[[1,1]]]==2 || Length[coord[[1,1]]]==3}, TrueQ ]
VertexCoordinateListQ[ m_?MechanismQ, coord_ ] := AllTrue[ {ArrayQ[coord], ArrayDepth[coord]==3 , Length[coord[[1]]]==m["VertexCount"]}, TrueQ ]


NumericCoordinatesQ[ coord_ ] := AllTrue[ {MatrixQ[coord, NumericQ], Length[coord[[1]]]==2 || Length[coord[[1]]]==3},TrueQ ]
NumericCoordinatesQ[ m_?MechanismQ, coord_ ] := AllTrue[ {MatrixQ[coord,NumericQ], Length[coord] == m["VertexCount"]}, TrueQ ]


NumericMachinePrecisionCoordinatesQ[ coord_ ] := 
	AllTrue[ {
			MatrixQ[coord, MachineRealQ],
			Length[coord[[1]]]==2 || Length[coord[[1]]]==3
			},
			TrueQ
	]
NumericMachinePrecisionCoordinatesQ[ m_?MechanismQ, coord_ ] :=
	AllTrue[ {MatrixQ[coord,MachineRealQ], Length[coord] == m["VertexCount"]}, TrueQ ]


OrthogonalizeDisplacements[ displacements_?VertexCoordinateListQ, tol : _?NumericQ : 10^(-8) ] :=
With[{dim = Dimensions[displacements][[3]], tolsq = tol^2},
	Partition[#, dim]& /@ Select[ Orthogonalize[ Flatten /@ displacements, Tolerance -> tol ], # . # > tolsq & ]
]


OrthogonalizeDisplacements::notdispl="Not a list of valid vertex displacements of the same dimension.";
OrthogonalizeDisplacements::tol="Tolerance must be numeric.";

OrthogonalizeDisplacements[displacements_,___]:="nothing"/;Message[OrthogonalizeDisplacements::notdispl]
OrthogonalizeDisplacements[displacements_,_]:="nothing"/;Message[OrthogonalizeDisplacements::tol]


$coordinateSymbols[3]={"x","y","z"};
$coordinateSymbols[2]={"x","y"};

VertexPosition[n : {__Integer}, d_] := VertexPosition[#,d]& /@ n
VertexPosition[n_Integer, d : {__String}|{__Integer}] := VertexPosition[n,#]&/@d
VertexPosition[n_Integer, All[ d_Integer ] ] := VertexPosition[n,#]& /@ $coordinateSymbols[d]
VertexPosition[n_Integer, m_Integer] := VertexPosition[n, $coordinateSymbols[3][[m]]]
VertexPosition[m_?MechanismQ, d_] := VertexPosition[#,d]& /@ Range[m["VertexCount"]]
VertexPosition[m_?MechanismQ] := VertexPosition[m, All[ m["EmbeddingDimension"] ] ]
VertexPosition[m_?MechanismQ, n : {__Integer} ] := VertexPosition[ n, All[ m["EmbeddingDimension"] ] ]

VertexDisplacement[n : {__Integer},d_]:=VertexDisplacement[#,d]&/@n
VertexDisplacement[n_Integer,d : {__String}|{__Integer}]:=VertexDisplacement[n,#]&/@d
VertexDisplacement[n_Integer,All[d_Integer]]:=VertexDisplacement[n,#]&/@$coordinateSymbols[d]
VertexDisplacement[n_Integer,m_Integer]:=VertexDisplacement[n,$coordinateSymbols[3][[m]]]
VertexDisplacement[m_?MechanismQ,d_]:=VertexDisplacement[#,d]&/@Range[m["VertexCount"]]
VertexDisplacement[m_?MechanismQ]:=VertexDisplacement[m,All[m["EmbeddingDimension"]]]
VertexDisplacement[m_?MechanismQ, n : {__Integer} ] := VertexDisplacement[ n, All[ m["EmbeddingDimension"] ] ]


VertexPosition[ p_PeriodicIdentificationData ] := p["VertexPosition"]
VertexDisplacement[ p_PeriodicIdentificationData ] := p["VertexDisplacement"]


PositionRules[ p_PeriodicIdentificationData ] := p["PositionRules"]
PositionRules[ p_PeriodicIdentificationData , latticeVectors_?MatrixQ ] :=
	p["LatticeVectors"->latticeVectors]["PositionRules"] /; Dimensions[latticeVectors] == Dimensions[p["LatticeVectors"]]

PositionRules::lat="Lattice vectors should have dimensions `1`.";
PositionRules[ p_PeriodicIdentificationData , latticeVectors_ ] := "nothing" /; Message[PositionRules::lat,Dimensions[p["LatticeVectors"]]]

PositionRules[ m_?MechanismQ ] := PositionRules[ m["VertexCoordinates"] ]
PositionRules[ positions_?VertexCoordinatesQ ] := With[{
	arbitraryPositions = Array[ VertexPosition, Dimensions[positions] ]
},
	Flatten[MapThread[Rule, {arbitraryPositions, positions}, 2]]
]
PositionRules[ positions_?VertexCoordinateListQ ] := With[{
	arbitraryPositions = Array[VertexPosition, Dimensions[positions][[2;;]] ]
},
	Flatten /@ MapThread[ Rule, { ConstantArray[ arbitraryPositions, Length[positions] ], positions } , 3 ]
]

PositionRules[ pos_ ] := "nothing" /; Message[PositionRules::pos]
PositionRules::pos = "Argument should either be a mechanism, vertex positions {pt1, pt2,...}, or a list of vertex positions { {pt1, ...}, ...} .";


PositionConstraints[ p_PeriodicIdentificationData , latticeVectors_?MatrixQ ] :=
	p["LatticeVectors"->latticeVectors]["Constraints"] /; Dimensions[latticeVectors] == Dimensions[p["LatticeVectors"]]

PositionConstraints::lat="Lattice vectors should have dimensions `1`.";
PositionConstraints[ p_PeriodicIdentificationData , latticeVectors_ ] := "nothing" /; Message[PositionConstraints::lat,Dimensions[p["LatticeVectors"]]]


DisplacementRules[ p_PeriodicIdentificationData ] := p["DisplacementRules"]
DisplacementRules[ p_PeriodicIdentificationData , wavevectors_?VectorQ ] := (p["DisplacementRules"] /. Thread[p["labels"]->wavevectors]) /; Length[wavevectors]==Length[p["labels"]]

DisplacementRules::wavevectors="You need `1` wave vectors to be provided";
DisplacementRules[ p_PeriodicIdentification, _] := "nothing" /; Message[DisplacementRules::wavevector,Length[pi["labels"]]]

DisplacementRules[ positions_?VertexCoordinatesQ ] := With[{
	arbitraryPositions = Array[ VertexDisplacement, Dimensions[positions] ]
},
	Flatten[MapThread[Rule, {arbitraryPositions, positions}, 2]]
]
DisplacementRules[ positions_?VertexCoordinateListQ] := With[{
	arbitraryPositions = Array[VertexDisplacement, Dimensions[positions][[2;;]] ]
},
	Flatten /@ MapThread[ Rule, { ConstantArray[ arbitraryPositions, Length[positions] ], positions } , 3 ]
]

DisplacementRules[ pos_ ] := "nothing" /; Message[DisplacementRules::pos]
DisplacementRules::pos = "Argument should either be vertex positions {pt1, pt2,...}, or a list of vertex positions { {pt1, ...}, ...} .";


periodicEdges[ m_, pi_] :=
Module[{
	labels = pi["labels"],
	edges =  {{#[[1]],0},{#[[2]],0}}& /@ Sort /@ MechanismEdges[m] ,
	mirroredEdges, x
},
	mirroredEdges = (translateCell /@  SortBy[First] /@ (edges //. pi["IdentificationRules"])) /. Thread[labels->IdentityMatrix[Length[labels]]];
	collapseCell @ Select[  GatherBy[ Thread[edges ->   mirroredEdges] , Abs[Last[#]]& ], Length[#]>1& ]
]

periodicFaces[ m_, pi_] :=
Module[{
	labels = pi["labels"],
	faces =  Map[ {#,0}&, MechanismFaces[m], {2} ],
	mirroredFaces, x
},
	mirroredFaces = (translateCell /@ SortBy[First] /@ (faces //. pi["IdentificationRules"])) /. Thread[labels->IdentityMatrix[Length[labels]]];
	collapseCell @ Select[  GatherBy[ Thread[faces ->   mirroredFaces] , Abs[Last[#]]& ], Length[#]>1& ]
]

collapseCell =  Map[First,Map[#[[All,1]]&, # ,{3}],{2}]&;
translateCell[ cell_List ] := With[{element = cell[[1,2]]}, {#[[1]], #[[2]]-element}& /@ cell]


reduceCell[ pi_ , cells_List ] := Transpose /@ translateCell /@ (
	Map[ {#,0}&, cells, {2} ] //. pi["IdentificationRules"] /. 0 -> {0,0} /. Thread[pi["labels"] -> IdentityMatrix[Length[pi["labels"]]]]
)


Options[PeriodicIdentification] = {OverlapPrecision->10^(-12)};

PeriodicIdentification[ m_?MechanismQ ] := SelectFirst[Flatten[Values[m]],Head[#]===PeriodicIdentificationData&]

PeriodicIdentification[ m_?MechanismQ , basis_ , opt : OptionsPattern[] ] :=
With[{
	labels = Array[Unique[]&, Length[basis]] , 
	posBasis = newPositionDimension[Head[m],{MechanismPositions[m] , basis}]
	},
	With[{res=periodicIdentificationInternal[ posBasis, labels, OptionValue[OverlapPrecision] ] },
		res /; Head[res] =!= periodicIdentificationInternal
	] /; periodicIdentificationArgumentsQ[m, posBasis, labels, OptionValue[OverlapPrecision]]
]

(*figure out what dimension to put the basis in*)
(*Linkage: basis dimension is larger than embedding dimension*)
newPositionDimension[ Linkage , {positions_ , basis_?(MatrixQ[#,NumericQ]&)} ] :=
	{PadRight[positions, {Length[positions],Length[basis[[1]]]}], basis} /; Length[basis[[1]]]> Length[positions[[1]]]
(*Origami: basis dimension is larger than embedding dimension*)
newPositionDimension[ Origami, {positions_,basis_?(MatrixQ[#,NumericQ]&)}] :=
	{positions, PadRight[basis,{Length[basis],Length[positions[[1]]]}]} /; Length[basis[[1]]]< Length[positions[[1]]]
(*default is nothing*)
newPositionDimension[_ , x_] := x

periodicIdentificationArgumentsQ[ m_, {positions_, basis_}, labels_ ,  tolerance_] := 
And[
	If[ Length[positions[[1]]] >= Length[basis] , True, Message[PeriodicIdentification::numbasis, Length[positions[[1]]]]; False],
	If[MatrixQ[basis,NumericQ], True, Message[PeriodicIdentification::basis2]; False],
	If[MatrixQ[basis] && Chop[Det[ N[basis] . Transpose[N[basis]] ]] != 0, True, Message[PeriodicIdentification::basis3]; False],
	If[NumericQ[tolerance] && tolerance >= 0, True, Message[PeriodicIdentification::tol, tolerance]; False],
	If[0 < Length[basis] <= 3, True, Message[PeriodicIdentification::basis]; False],
	If[ Length[positions[[1]]] == Length[basis[[1]]], True, Message[PeriodicIdentification::dim]; False]
]

PeriodicIdentification::tol="OverlapPrecision `1` must be a positive number.";
PeriodicIdentification::basis2="Basis should be a list of linearly independet, numerical vectors of the same dimension.";
PeriodicIdentification::basis3="Basis is not linearly independent to machine precision.";
PeriodicIdentification::basis="There should be between 1 and 3 basis elements.";
PeriodicIdentification::dim="Dimension of basis and mechanism are incompatible.";
PeriodicIdentification::numbasis = "The number of basis vectors specified cannot exceed `1`.";


periodicIdentificationInternal[ {pos_ , latticeVectors_}, labels_  , tol_ ] :=
Module[{ 
	pi
	},
	PeriodicIdentificationData[
		labels,
		latticeVectors,
		pi = simplifyPeriodicRules[ Length[pos], positionDifferences[pos, labels, latticeVectors, tol] ],
		Range[Length[pos]] //. pi[[All,1]]
	]
]

simplifyPeriodicRules[ l_, rules_ ] :=  
With[{ newrules = {#[[1,1]],n_} :> {#[[1,2]],n+#[[2]]} & /@ rules },
	DeleteCases[ MapThread[
		{#1 -> #2[[1]], #2[[2]]}&,
		{Range[l], Thread[{Range[l],0}] //. newrules}
	], {_,0}]
]


listMutualVertexDisplacements[ pos_ , test_] :=  Select[
	Transpose[ {Rule @@@ Tuples[Range[Length[pos]],2],#[[1]]-#[[2]]&/@ Tuples[pos,2]}],
	test[#[[2]]]&
	]

positionDifferences[ pos_ , labels_ , latticeVectors_ , tol_] :=
Module[{
	inv = latticeInverse[latticeVectors],
	integerTestQ = (# . #&)[ #-Round[#] ] <= tol^2&,
	uniqueMutualVertexDisplacements = Select[ listMutualVertexDisplacements[ pos, # . # > tol^2 &], #[[1,1]] > #[[1,2]]& ]
},
	{#[[1]], labels . Round[#[[2]]]}& /@ Select[ { #[[1]], inv . #[[2]] }& /@ uniqueMutualVertexDisplacements, integerTestQ[#[[2]]]&]
]

latticeInverse[ basis_?MatrixQ ] := Chop[Inverse[Transpose @ basis]] /; SameQ@@Dimensions[basis]
latticeInverse[ basis_?MatrixQ ] := With[{
	newbasis = Select[ Orthogonalize[ Join[basis, IdentityMatrix[Length[basis[[1]]]]] ], # . # >0&]
},
	Chop[Take[Inverse[ Transpose @ newbasis],Length[basis]]]
] /; (#[[2]] > #[[1]]&)[Dimensions[basis]]
latticeInverse[_]:=$Failed


(* 
	overlappingVertices returns a list of which vertices in the first set of positions can be
	identified in the second set.
	
	overlappingVertices[positions 1, positions 2] returns a list of which vertices listed in 1 can be found in 2.
*)
overlappingVertices[positions1_?MatrixQ, positions2_?MatrixQ, tol : _?NumericQ : 10^(-5)] := 
Module[
{ nearestList, selectorList },
	(*
	get the points in list 1 that are closest to each of the points in list 2
	*)
	nearestList = Nearest[ Thread[positions1 -> Range[ Length[positions1] ]], positions2 ][[All,1]] ;

	(*get the actual overlapping points according to the provided tolerance*)
	selectorList = (# . #<tol^2&) /@ ( positions2-positions1[[ nearestList ]] ) ;

	Pick[ Thread[nearestList -> Range[ Length @ positions1] ], selectorList ]

] /; Dimensions[positions1] == Dimensions[positions2]


PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["Methods"] := 
{"Identification","UniqueVertices","LatticeVectors","labels","IdentificationRules",
"EmbeddingDimension","Constraints","VertexPosition","PositionRules","VertexDisplacements","DisplacementRules"}
SetAttributes[PeriodicIdentificationData,NHoldAll];


PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["Identification"] := maps[[All,1]]
PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["UniqueVertices"] := DeleteDuplicates[uniquevertices]

PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["LatticeVectors"] := latticeVectors
PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["LatticeVectors" -> basis_?MatrixQ] := 
	PeriodicIdentificationData[labels, basis, maps, uniquevertices] /; Dimensions[basis] == Dimensions[latticeVectors]

PeriodicIdentificationData[labels_, latticeVectors_, maps_,uniquevertices_]["labels"] := labels
PeriodicIdentificationData[labels_, latticeVectors_, maps_,uniquevertices_]["labels" -> newLabels_?VectorQ] :=
	PeriodicIdentificationData[newLabels, latticeVectors, maps /. Thread[labels->newLabels], uniquevertices] /; Length[newLabels] == Length[labels]

PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["IdentificationRules"] := With[{
	starts = maps[[All,1,1]], ends = maps[[All,1,2]], unitcells = maps[[All,2]]
},
	MapThread[ ({#1,n_} :> {#2, n + #3})& , {starts, ends, unitcells}]
]

PeriodicIdentificationData[labels_, latticeVectors_, maps_,uniquevertices_]["EmbeddingDimension"] := Length[latticeVectors[[1]]]
PeriodicIdentificationData[labels_, latticeVectors_, maps_,uniquevertices_]["EmbeddingDimension" -> newDim_] :=
	PeriodicIdentificationData[labels, PadRight[latticeVectors, {Length[latticeVectors], newDim}] , maps, uniquevertices]

PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["Constraints"] :=
	With[ {data = maps /. Thread[labels -> latticeVectors ] , dim = Length[latticeVectors[[1]]]},
		Flatten[Thread /@ ( ( VertexPosition[ #[[1,1]], All[dim]] == VertexPosition[#[[1,2]],All[dim]] + #[[2]] )& /@ data)]
	]
PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["PositionRules"] := 
	With[ {data = maps /.Thread[labels -> latticeVectors ] , dim = Length[latticeVectors[[1]]]},
		Flatten[Thread /@ ( ( VertexPosition[ #[[1,1]], All[dim]] -> VertexPosition[#[[1,2]],All[dim]] + #[[2]] )& /@ data)]
	]
PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["VertexPosition"] := 
	With[ {data = maps /.Thread[labels -> latticeVectors ] , dim = Length[latticeVectors[[1]]]},
		VertexPosition[Range[Length[uniquevertices]],All[dim]] //. Flatten[Thread /@ ( ( VertexPosition[ #[[1,1]], All[dim]] -> VertexPosition[#[[1,2]],All[dim]] + #[[2]] )& /@ data)]
	]

PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["DisplacementRules"] := 
	With[ {data = maps /.Thread[labels -> latticeVectors ] , dim = Length[latticeVectors[[1]]]},
		Flatten[Thread /@ ( ( VertexDisplacement[ #[[1,1]], All[dim]] -> (Times @@ (labels^#[[2]]) VertexDisplacement[#[[1,2]],All[dim]]) )& /@ data)]
	]
PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]["VertexDisplacement"] := 
	With[ {data = maps /.Thread[labels -> latticeVectors ] , dim = Length[latticeVectors[[1]]]},
		VertexDisplacement[Range[Length[uniquevertices]],All[dim]] //. Flatten[Thread /@ ( ( VertexDisplacement[ #[[1,1]], All[dim]] -> Times @@ (labels^#[[2]]) VertexDisplacement[#[[1,2]],All[dim]] )& /@ data)]
	]


Format[PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_]] :=
	PeriodicIdentificationData[
		Panel @ Column[{
			"V = " <> ToString[Length[DeleteDuplicates[uniquevertices]]],
			Style[ latticeVectors, Italic ]}]
	]


PeriodicIdentificationDataQ[ PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_] ] :=
	AllTrue[
		Length[labels] == Length[latticeVectors],
		TrueQ
	]

PeriodicIdentificationDataQ[ m_?MechanismQ, PeriodicIdentificationData[labels_, latticeVectors_, maps_, uniquevertices_] ] :=
	AllTrue[
		{
		Length[uniquevertices] == m["VertexCount"],
		Length[labels] == Length[latticeVectors]
		}, 
		TrueQ
	]

PeriodicIdentificationDataQ[ m_?MechanismQ, _ ] := False
PeriodicIdentificationDataQ[ _ ] := False


mechanismDeleteDanglingVertices[m_Origami] := mechanismDeleteDanglingVertices[m,"faces"]
mechanismDeleteDanglingVertices[m_Linkage] := mechanismDeleteDanglingVertices[m,"edges"]

mechanismDeleteDanglingVertices[m_?MechanismQ, type: "faces"|"edges"]:=With[
{vertexSelector=Transpose[ { Range[m["VertexCount"]], Length /@ MechanismConnectivity[m,"vertices"->type]} ]},
	DeleteVertices[m, Select[vertexSelector,#[[2]]<1&][[All,1]] ]
]


Options[MechanismUnitCell] = {DeleteDanglingVertices -> True};

MechanismUnitCell[m_?MechanismQ, opt : OptionsPattern[]] := With[{pi=Select[Flatten[Values[m]],Head[#]===PeriodicIdentificationData&]}, 
	If[Length[pi]>0, MechanismUnitCell[m, First@pi, opt ] , Message[MechanismUnitCell::notperiodic]; m]
]

MechanismUnitCell[m_?MechanismQ, basis_?(MatrixQ[N[#],NumericQ]&), OptionsPattern[] ]:=
	With[{res=mechanismUnitCellInternal[m,PeriodicIdentification[m,basis], OptionValue[DeleteDanglingVertices]]},
		res /; Head[res] =!=mechanismUnitCellInternal
	] /; If[ Length[basis[[1]]] == MechanismEmbeddingDimension[m], True, Message[MechanismUnitCell::dim]; False]

MechanismUnitCell[m_?MechanismQ, pi_, OptionsPattern[] ] :=
With[{res = mechanismUnitCellInternal[m,pi, OptionValue[DeleteDanglingVertices]]},
	res /; Head[res] =!= mechanismUnitCellInternal
]

mechanismUnitCellInternal[ m_, pi_?PeriodicIdentificationDataQ, vertices_?BooleanQ ] := 
With[{
	facesToDelete = Flatten[Rest/@periodicFaces[m,pi],1],
	edgesToDelete = Flatten[Rest/@periodicEdges[m,pi],1]
},
	If[vertices, mechanismDeleteDanglingVertices[#], #]& @ DeleteCells[m, MechanismCells[Alternatives@@Join[ _ /@ edgesToDelete , _ /@ facesToDelete]]]
]

(*mechanismUnitCellInternal[m_?MechanismQ, basis_?MatrixQ, _]:="nothing" /; Message[MechanismUnitCell::num]*)
mechanismUnitCellInternal[m_?MechanismQ, _ , _?(Not[BooleanQ[#]]&)]:="nothing" /; Message[MechanismUnitCell::dang]

MechanismUnitCell::dim="Dimension of primitive vectors does not match mechanism.";
MechanismUnitCell::dang="Option DeleteDanglingVertices must be a Boolean.";
MechanismUnitCell::notperiodic="Mechanism has no periodic identification attached.";


LabelPeriodicVertices[ m_?MechanismQ , pi_, inputStyle_ : None] := With[{
	map = pi["Identification"], style = If[ inputStyle === None, #&, Style[#,inputStyle]& ]
},
	ChangeCellData[
		ChangeCellData[FreeJoint[ map[[All,1]] ], "Label" -> (style/@ map[[All,2]]) ] @ m,
		FreeJoint[ map[[All,2]] ], "Label" -> map[[All,2]]
	]
] /; PeriodicIdentificationDataQ[m,pi]


LabelPeriodicVertices[ m_?MechanismQ , inputStyle_ : None] := With[
{
	constraints = Select[ m["value", Mechanisms`rigidity`Constraints], PeriodicIdentificationDataQ ]
},
	If[ Length[constraints] == 0, 
		m,
		LabelPeriodicVertices[m, constraints[[1]] , inputStyle]
	]
]


Options[MakePeriodic] = {Options[MechanismUnitCell], "Label" -> False};

MakePeriodic[ m_?MechanismQ , basis_, opt : OptionsPattern[]] := MakePeriodic[basis,opt] @ m

MakePeriodic[ basis_?(MatrixQ[N[#],NumericQ]&) , opt : OptionsPattern[]][m_?MechanismQ] :=
Module[{
	unitcell = MechanismUnitCell[m, basis, FilterRules[{opt},Options[MechanismUnitCell]]], pi
},
	pi = PeriodicIdentification[unitcell, basis];
	If[ PeriodicIdentificationDataQ[pi] && MechanismQ[unitcell], 
		If[TrueQ[OptionValue["Label"]], LabelPeriodicVertices , #&] @ AddOption[unitcell, Mechanisms`rigidity`Constraints -> pi],
		m
	]
] /; If[ Length[basis[[1]]] == MechanismEmbeddingDimension[m], True, Message[MechanismUnitCell::dim]; False]


PeriodicMechanismQ[m_?MechanismQ] := AnyTrue[Flatten[Values[m]],Head[#]===PeriodicIdentificationData&]


geometryValidEdgesQ[ positions_ , edgeList_?(MatrixQ[#, IntegerQ]&) ] := And[
	Length[ edgeList[[1]] ] == 2,
	Max[ edgeList ] <= Length[positions],
	Min[ edgeList ] > 0
]
geometryValidEdgesQ[ _ , _ ] := False


geometryValidTriplesQ[ positions_ , tripleList_?(MatrixQ[#,IntegerQ]&) ] := And[
	Length[ tripleList[[1]] ] == 3,
	Max[ tripleList ] <= Length[positions],
	Min[ tripleList ] > 0
]
geometryValidTriplesQ[_, _] := False


geometryValidFacesQ[ positions_, faces_List ] := And[
	And @@ (VectorQ[#,IntegerQ]& /@ faces),
	Min[faces]>0,
	Max[faces] <= Length[positions],
	AllTrue[ Length/@faces, #>2& ]
]
geometryValidFacesQ[ _, _ ] := False


(*multiple positions*)
numericalListQ[positions_?VertexCoordinateListQ] := And @@ (NumericMachinePrecisionCoordinatesQ /@ positions)
numericalListQ[ _ ] := False


DisplacementVector[ __ , {} ] := {}
DisplacementVector[ m_?MechanismQ , edgeList_ ] :=
	With[{res=DisplacementVector[ m["VertexCoordinates"], edgeList /. m["labels"] ]}, res /; Head[res] =!= DisplacementVector ]
DisplacementVector[ m_?MechanismQ , positions_ , edgeList_ ] :=
	With[{res=DisplacementVector[ positions, edgeList /. m["labels"] ]}, res /; Head[res] =!= DisplacementVector ]

(*single positions*)
(*MachineReal[] positions use a compiled version*)
DisplacementVector[ positions_?NumericMachinePrecisionCoordinatesQ , edgeList_ ] :=
	displacementVectorCompiled[][ToPackedArray[positions],ToPackedArray[edgeList]] /; geometryValidEdgesQ[ positions, edgeList ]
(*everything else*)
DisplacementVector[ positions_?VertexCoordinatesQ , edgeList_ ] :=
	displacementVectorInternal[ positions , edgeList ] /; geometryValidEdgesQ[positions, edgeList]

(*Multiple positions provided that are MachineReal[]*)
DisplacementVector[ positions_?numericalListQ , edgeList_ ] :=
	displacementVectorCompiledMultiple[][ToPackedArray[positions],ToPackedArray[edgeList]] /; geometryValidEdgesQ[positions[[1]], edgeList]
(*everything else*)
DisplacementVector[ positions_?VertexCoordinateListQ , edgeList_ ] :=
	displacementVectorInternalMultiple[ positions , edgeList ] /; geometryValidEdgesQ[positions[[1]], edgeList]

DisplacementVector[ positions_ , edgeList_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[gometryValidEdgesQ[positions,edgeList]], Message[DisplacementVector::edges, edgeList] ];
	If[ VertexCoordinateListQ[ positions ] && Not[gometryValidEdgesQ[positions,edgeList]] , Message[DisplacementVector::edges, edgeList] ];
	If[ Not[MechanismQ[positions]] && (Not[ VertexCoordinatesQ[positions] ] || Not[ VertexCoordinateListQ[ positions ] ]), Message[DisplacementVector::pos, positions] ];
	False
)

DisplacementVector::pos = "Positions `1` provided are not valid.";
DisplacementVector::edges = "Edges `1` are not a list of integer pairs.";


displacementVectorInternal[positions_,edgeList_]:=
With[{flippedEdgeList=Transpose[edgeList]},
	positions[[flippedEdgeList[[2]]]]-positions[[flippedEdgeList[[1]]]]
]

displacementVectorCompiled[]:=
	displacementVectorCompiled[]=Compile[{{positions,_Real,2},{edgeList,_Integer,2}},
		With[{flippedEdgeList=Transpose[edgeList]},
			positions[[flippedEdgeList[[2]]]]-positions[[flippedEdgeList[[1]]]]
		]
	]

displacementVectorInternalMultiple[positions_,edgeList_]:=
With[{flippedEdgeList=Transpose[edgeList]},
	Map[#[[flippedEdgeList[[2]]]]-#[[flippedEdgeList[[1]]]]&, positions]
]

displacementVectorCompiledMultiple[]:=
	displacementVectorCompiledMultiple[]=Compile[{{positions,_Real,3},{edgeList,_Integer,2}},
		With[{flippedEdgeList=Transpose[edgeList]},
			Map[#[[flippedEdgeList[[2]]]]-#[[flippedEdgeList[[1]]]]&, positions]
		]
	]


DisplacementLength[__, {} ] :={}
DisplacementLength[ m_?MechanismQ, edgeList_ ] := With[ {res = DisplacementLength[ m["VertexCoordinates"], edgeList /. m["labels"]] },
	res /; Head[res] =!= DisplacementLength
]
DisplacementLength[ m_?MechanismQ, positions_ , edgeList_ ] := With[ {res = DisplacementLength[ positions, edgeList /. m["labels"] ] },
	res /; Head[res] =!= DisplacementLength
]

DisplacementLength[ positions_?NumericMachinePrecisionCoordinatesQ , edgeList_ ] :=
	displacementLengthCompiled[ Length[ positions[[1]] ] ][ToPackedArray[positions],ToPackedArray[edgeList]] /; geometryValidEdgesQ[positions, edgeList]

DisplacementLength[ positions_?VertexCoordinatesQ , edgeList_ ] :=
	displacementLengthAnalytic[ positions , edgeList ] /; geometryValidEdgesQ[positions, edgeList]

(*Multiple positions provided that are MachineReal[]*)
DisplacementLength[ positions_?numericalListQ , edgeList_ ] :=
	(displacementLengthCompiled[ Length[ positions[[1]] ] ][#,ToPackedArray[edgeList]]& /@ ToPackedArray[positions]) /; geometryValidEdgesQ[positions[[1]], edgeList]
(*everything else*)
DisplacementLength[ positions_?VertexCoordinateListQ , edgeList_ ] :=
	(displacementLengthAnalytic[ # , edgeList ]& /@ positions) /; geometryValidEdgesQ[positions[[1]], edgeList]

DisplacementLength[ positions_ , edgeList_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[gometryValidEdgesQ[positions,edgeList]], Message[DisplacementLength::edges, edgeList] ];
	If[ VertexCoordinateListQ[ positions ] && Not[gometryValidEdgesQ[positions,edgeList]] , Message[DisplacementLength::edges, edgeList] ];
	If[ Not[MechanismQ[positions]] && (Not[ VertexCoordinatesQ[positions] ] || Not[ VertexCoordinateListQ[ positions ] ]), Message[DisplacementLength::pos, positions] ];
	False
)

DisplacementLength::pos = "Positions `1` provided are not valid.";
DisplacementLength::edges = "Edges `1` are not a list of integer pairs.";


displacementLengthCompiled[d_Integer] := displacementLengthCompiled[d]=
Compile[
{{pos,_Real,2},{edges,_Integer,2}},
	Module[{i,j},
		Table[
			With[{
			index1=Compile`GetElement[edges,i,1],
			index2=Compile`GetElement[edges,i,2]
			},
			Sqrt[Sum[(Compile`GetElement[pos,index1,j]-Compile`GetElement[pos,index2,j])^2,{j,1,d}]]
			],
		{i,1,Length[edges]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]

displacementLengthAnalytic[positions_,edgeList_] := expandExpression[Sqrt[(# . #&) /@ displacementVectorInternal[positions,edgeList]]]


DisplacementLengthSquared[__, {} ] :={}
DisplacementLengthSquared[ m_?MechanismQ, edgeList_ ] := With[ {res = DisplacementLengthSquared[ m["VertexCoordinates"], edgeList /. m["labels"]] },
	res /; Head[res] =!= DisplacementLengthSquared
]
DisplacementLengthSquared[ m_?MechanismQ, positions_ , edgeList_ ] := With[ {res = DisplacementLengthSquared[ positions, edgeList /. m["labels"]] },
	res /; Head[res] =!= DisplacementLengthSquared
]

DisplacementLengthSquared[ positions_?NumericMachinePrecisionCoordinatesQ , edgeList_ ] :=
	displacementLengthSquaredCompiled[ Length[ positions[[1]] ] ][ToPackedArray[positions],ToPackedArray[edgeList]] /; geometryValidEdgesQ[positions, edgeList]

DisplacementLengthSquared[ positions_?VertexCoordinatesQ , edgeList_ ] :=
	displacementLengthSquaredAnalytic[ ToPackedArray[positions],ToPackedArray[edgeList]] /; geometryValidEdgesQ[positions, edgeList]

(*Multiple positions provided that are MachineReal[]*)
DisplacementLengthSquared[ positions_?numericalListQ , edgeList_ ] :=
	(displacementLengthSquaredCompiled[ Length[ positions[[1,1]] ] ][#,ToPackedArray[edgeList]]& /@ ToPackedArray[positions]) /; geometryValidEdgesQ[positions[[1]], edgeList]
(*everything else*)
DisplacementLengthSquared[ positions_?VertexCoordinateListQ , edgeList_ ] :=
	(displacementLengthSquaredAnalytic[ # , edgeList ]& /@ positions) /; geometryValidEdgesQ[positions[[1]], edgeList]

DisplacementLengthSquared[ positions_ , edgeList_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[gometryValidEdgesQ[positions,edgeList]], Message[DisplacementLengthSquared::edges, edgeList] ];
	If[ VertexCoordinateListQ[ positions ] && Not[gometryValidEdgesQ[positions,edgeList]] , Message[DisplacementLengthSquared::edges, edgeList] ];
	If[ Not[MechanismQ[positions]] && (Not[ VertexCoordinatesQ[positions] ] || Not[ VertexCoordinateListQ[ positions ] ]), Message[DisplacementLengthSquared::pos, positions] ];
	False
)

DisplacementLengthSquared::pos = "Positions `1` provided are not valid.";
DisplacementLengthSquared::edges = "Edges `1` are not a list of integer pairs.";


displacementLengthSquaredCompiled[d_Integer]:=displacementLengthSquaredCompiled[d]=
Compile[
{{pos,_Real,2},{edges,_Integer,2}},
	Module[{i,j},
		Table[
			With[{
			index1=Compile`GetElement[edges,i,1],
			index2=Compile`GetElement[edges,i,2]
			},
			Sum[(Compile`GetElement[pos,index1,j]-Compile`GetElement[pos,index2,j])^2,{j,1,d}]
			],
		{i,1,Length[edges]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]
displacementLengthSquaredAnalytic[positions_,edgeList_]:= expandExpression[Map[# . # &, displacementVectorInternal[positions,edgeList]]]


TurningAngle[ __ , {}] := {}
TurningAngle[ m_?MechanismQ, tripleList_ ] := With[ {res = TurningAngle[ m["VertexCoordinates"], tripleList /. m["labels"] ]},
	res /; Head[res] =!= TurningAngle
]
TurningAngle[ m_?MechanismQ, positions_ , tripleList_ ] := With[ {res = TurningAngle[ positions, tripleList /. m["labels"]]},
	res /; Head[res] =!= TurningAngle
]

TurningAngle[ positions_?NumericMachinePrecisionCoordinatesQ , tripleList_ ] :=
	turningAngleCompiled[ Length[positions[[1]]] ][ ToPackedArray[positions], ToPackedArray[tripleList] ] /; geometryValidTriplesQ[ positions, tripleList ]
TurningAngle[ positions_?VertexCoordinatesQ , tripleList_ ] :=
	turningAngleAnalytic[ Length[positions[[1]]] , ToPackedArray[positions], ToPackedArray[tripleList] ] /; geometryValidTriplesQ[ positions, tripleList ]
TurningAngle[ positions_?numericalListQ , tripleList_ ] :=
	(turningAngleCompiled[ Length[positions[[1,1]]] ][ #, ToPackedArray[tripleList] ]& /@ ToPackedArray[positions]) /; geometryValidTriplesQ[ positions[[1]], tripleList ]
TurningAngle[ positions_?VertexCoordinateListQ , tripleList_ ] :=
	turningAngleAnalytic[ Length[positions[[1,1]]] , #, ToPackedArray[tripleList] ]& /@ positions /; geometryValidTriplesQ[ positions[[1]], tripleList ]

TurningAngle[ positions_ , tripleList_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[geometryValidTriplesQ[positions,tripleList]], 
		Message[TurningAngle::triples, tripleList]
	];
	If[ VertexCoordinateListQ[ positions ] && Not[geometryValidTriplesQ[positions[[1]],tripleList]] , Message[TurningAngle::triples, tripleList] ];
	If[ Not[MechanismQ[positions]] && (Not[ VertexCoordinatesQ[positions] ] || Not[ VertexCoordinateListQ[ positions ] ]), Message[TurningAngle::pos, positions] ];
	False
)

TurningAngle::pos = "Positions `1` provided are not valid.";
TurningAngle::triples = "Triples `1` are not a list of integer triplets.";


turningAngleCompiled[3]:=turningAngleCompiled[3]=
Compile[
{{pos,_Real,2},{triplets,_Integer,2}},
	Module[{i,in},
		Table[With[{
			p1x=Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,1],1],
			p1y=Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,1],2],
			p1z=Compile`GetElement[pos,Compile`GetElement[triplets,i,2],3]-Compile`GetElement[pos,Compile`GetElement[triplets,i,1],3],
			p2x=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1],
			p2y=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2],
			p2z=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],3]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],3]
		},
			in=(p1x p2x+p1y p2y+p1z p2z)/(Sqrt[p1x^2+p1y^2+p1z^2] Sqrt[p2x^2+p2y^2+p2z^2]);
			Which[in>1, 0, in < -1 , Pi, True, ArcCos[in] ]
		], {i,1,Length[triplets]}]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]

turningAngleCompiled[2]:=turningAngleCompiled[2]=
Compile[
{{pos,_Real,2},{triplets,_Integer,2}},
	Module[{i},
		Table[With[{
			p1x=Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,1],1],
			p1y=Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,1],2],
			p2x=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1],
			p2y=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2]
		},
			ArcTan[p1x p2x + p1y p2y,p1x p2y - p2x p1y]
		],{i,1,Length[triplets]}]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]


(*
this funny construction here works better during expansions because of the branch cuts of ArcCos[]

The problem arises in Series[ArcCos[1-xx^2],{xx,0,2}] which requires the choice of a branch. This last part
hasn't been solved but at least the answer comes out faster. The rest of the branch cut issues
are handled automatically in expandExpression[], which does what it can to make imaginary components zero.

There should be a better way to handle this but this seems to work in most cases.
*)
turningAngleAnalytic[3,data_,tripleList_]:=
With[
{
	cosvectorAngle3D=Function[{p1,p2},
		With[
			{x=p1[[1]],y=p1[[2]],z=p1[[3]],xx=p2[[1]],yy=p2[[2]],zz=p2[[3]]},
			(x xx+y yy+z zz)/(Sqrt[x^2+y^2+z^2] Sqrt[xx^2+yy^2+zz^2])
		]
	]
},
	(expandExpression@With[{pts=data[[#]]},ArcCos[expandExpression@cosvectorAngle3D[pts[[2]]-pts[[1]],pts[[3]]-pts[[2]]]]])&/@tripleList
]

turningAngleAnalytic[2,data_,tripleList_]:=
With[
{
	vectorAngle2D=Function[{p1,p2},
		With[
			{x=p1[[1]],y=p1[[2]],xx=p2[[1]],yy=p2[[2]]},
			ArcTan[x xx + y yy,x yy - xx y]	
		]
	]
},
	(expandExpression@With[{pts=data[[#]]},vectorAngle2D[pts[[2]]-pts[[1]],pts[[3]]-pts[[2]]]])&/@tripleList
]


Options[NormalVector]={"Normalize"->True};

normalizeQ[ x_ ] := If[ BooleanQ[x], True, Message[NormalVector::norm]; False ]
NormalVector::norm="Option \"normalize\" must be either True or False.";

NormalVector[__, {} ] := {}
NormalVector[ m_?MechanismQ, faces : Except[_Rule] , opt : OptionsPattern[] ] := 
With[ {res = NormalVector[ m["VertexCoordinates"], faces /. m["labels"], opt ]},
	res /; Head[res] =!= NormalVector
]
NormalVector[ m_?MechanismQ, positions_ , faces : Except[_Rule] , opt : OptionsPattern[] ] := With[ 
{res = NormalVector[ positions, faces /. m["labels"], opt ]},
	res /; Head[res] =!= NormalVector
]

NormalVector[ positions_?NumericMachinePrecisionCoordinatesQ, faces_ , OptionsPattern[] ] :=
	normalVectorCompiled[ OptionValue["Normalize"], Length[positions[[1]]] ][
		ToPackedArray[positions], 
		ToPackedArray[PadRight[faces, {Length[faces], 3}]] 
	] /; geometryValidFacesQ[ positions , faces] && normalizeQ[OptionValue["Normalize"]]
NormalVector[ positions_?VertexCoordinatesQ, faces_ , OptionsPattern[] ] :=
	normalVectorAnalytic[ OptionValue["Normalize"], Length[positions[[1]]], 
		positions,
		faces
	] /; geometryValidFacesQ[ positions , faces] && normalizeQ[OptionValue["Normalize"]]
NormalVector[ positions_?numericalListQ, faces_ , OptionsPattern[] ] :=
	normalVectorCompiled[ OptionValue["Normalize"], Length[positions[[1,1]]] ][
		#, 
		ToPackedArray[PadRight[faces, {Length[faces], 3}]] 
	]& /@ ToPackedArray[positions] /; geometryValidFacesQ[ positions , faces] && normalizeQ[OptionValue["Normalize"]]
NormalVector[ positions_?VertexCoordinateListQ, faces_ , OptionsPattern[] ] :=
	normalVectorAnalytic[ OptionValue["Normalize"], Length[positions[[1,1]]] ,
		#, 
		ToPackedArray[PadRight[faces, {Length[faces], 3}]] 
	]& /@ positions /; geometryValidFacesQ[ positions , faces] && normalizeQ[OptionValue["Normalize"]]

NormalVector[ positions_ , faces_ , OptionsPattern[] ] := "nothing" /; (
	If[ Not[BooleanQ[ OptionValue["Normalize"] ] ], Message[NormalVector::normalize] ]; 
	If[ VertexCoordinatesQ[positions] && Not[geometryValidFacesQ[positions,faces]], Message[NormalVector::faces, faces] ];
	If[ VertexCoordinateListQ[ positions ] && Not[geometryValidFacesQ[positions,faces]] , Message[NormalVector::faces, faces] ];
	If[ Not[MechanismQ[positions]] && Not[ VertexCoordinatesQ[positions] ] && Not[ VertexCoordinateListQ[ positions ] ], Message[NormalVector::pos, positions] ];
	False
)

NormalVector::normalize = "Option \"Normalize\" should be Boolean.";
NormalVector::pos = "Positions `1` provided are not valid.";
NormalVector::faces = "Faces `1` are not a list of faces.";


normalVectorCompiled[True,3]:=normalVectorCompiled[True,3]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
	Module[{i},
		Table[
			With[
			{
				x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				z=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],3]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3],
				xx=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				yy=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				zz=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],3]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3]
			},
			{
				(-yy z+y zz)/Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2],
				(xx z-x zz)/Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2],
				(-xx y+x yy)/Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2]
			}
			],
			{i,1,Length[Faces]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]
normalVectorCompiled[False,3]:=normalVectorCompiled[False,3]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
	Module[{i},
		Table[
			With[
			{
				x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				z=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],3]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3],
				xx=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				yy=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				zz=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],3]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3]
			},
			{
				(-yy z+y zz),
				(xx z-x zz),
				(-xx y+x yy)
			}
			],
			{i,1,Length[Faces]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]
normalVectorCompiled[True,2]:=normalVectorCompiled[True,2]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
	Module[{i},
		Table[
			With[
			{
				x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				xx=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				yy=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2]
			},
				Sign[-xx y+x yy]
			],
			{i,1,Length[Faces]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]
normalVectorCompiled[False,2]:=normalVectorCompiled[False,2]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
	Module[{i},
		Table[
			With[
			{
				x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				xx=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				yy=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2]
			},
				-xx y+x yy
			],
			{i,1,Length[Faces]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]

normalVectorAnalytic[True (* normalized *),3, positions_, triples_]:=
With[
{
	data=positions,
	NormalVector3D=Function[
		{p1,p2},
		With[
			{
			x=p1[[1]],y=p1[[2]],z=p1[[3]],xx=p2[[1]],yy=p2[[2]],zz=p2[[3]]
			},
			{
			(-yy z+y zz)/Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2],
			(xx z-x zz)/Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2],
			(-xx y+x yy)/Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2]
			}
		]
	]
},
	With[{p=data[[#]]},expandExpression@NormalVector3D[p[[3]]-p[[2]],p[[1]]-p[[2]]]]&/@triples
] 

normalVectorAnalytic[False (* normalized *),3, positions_, triples_]:=
With[
{
	data=positions,
	unNormalVector3D=Function[
		{p1,p2},
		With[
			{
			x=p1[[1]],y=p1[[2]],z=p1[[3]],xx=p2[[1]],yy=p2[[2]],zz=p2[[3]]
			},
			{
			-yy z+y zz,
			xx z-x zz,
			-xx y+x yy
			}
		]
	]
},
	With[{p=data[[#]]},expandExpression@unNormalVector3D[p[[3]]-p[[2]],p[[1]]-p[[2]]]]&/@triples
] 


FaceArea[__, {} ] := {}
FaceArea[ m_?MechanismQ, faces_] := 
With[ {res = FaceArea[ m["VertexCoordinates"], faces /. m["labels"] ]},
	res /; Head[res] =!= NormalVector
]
FaceArea[ m_?MechanismQ, positions_ , faces_ ] := With[ 
{res = NormalVector[ positions, faces /. m["labels"] ]},
	res /; Head[res] =!= NormalVector
]

FaceArea[ positions_?NumericMachinePrecisionCoordinatesQ, faces_ ] :=
	Total@faceAreaCompiled[ Length[positions[[1]]] ][
		ToPackedArray[positions], 
		# 
	]& /@ tc[faces] /; geometryValidFacesQ[ positions , faces]
FaceArea[ positions_?VertexCoordinatesQ, faces_ ] :=
	Total@faceAreaAnalytic[ Length[positions[[1]]], 
		positions,
		#
	]&/@tc[faces] /; geometryValidFacesQ[ positions , faces]
FaceArea[ positions_ , faces_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[geometryValidFacesQ[positions,faces]], Message[FaceArea::faces, faces] ];
	If[ Not[MechanismQ[positions]] && (Not[ VertexCoordinatesQ[positions] ] || Not[ VertexCoordinateListQ[ positions ] ]), Message[FaceArea::pos, positions] ];
	False
)

FaceArea::pos = "Positions `1` are not possible vertex positions.";
FaceArea::faces = "Faces `1` are not a list of valid faces.";


(*break faces up into triangles*)
tc=Compile[{{Face,_Integer,1}},
	With[{v1=First[Face],rest=Rest[Face]},
		Map[ Join[{v1},#]&,Partition[rest,2,1] ]
	],
	RuntimeAttributes->{Listable}
];


faceAreaCompiled[3]:=faceAreaCompiled[3]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
	Module[{i},
		Table[
			With[
			{
				x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				z=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],3]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3],
				xx=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				yy=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				zz=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],3]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3]
			},
				Sqrt[(-yy z+y zz)^2+(xx z-x zz)^2+(-xx y+x yy)^2]
			],
			{i,1,Length[Faces]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]

faceAreaCompiled[2]:=faceAreaCompiled[2]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
	Module[{i},
		Table[
			With[
			{
				x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
				xx=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
				yy=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2]-Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2]
			},
				Abs[-xx y+x yy]
			],
			{i,1,Length[Faces]}
		]
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]

faceAreaAnalytic[3, positions_, triples_]:=
With[
{
	data=positions,
	unNormalVector3D=Function[
		{p1,p2},
		With[
			{
			x=p1[[1]],y=p1[[2]],z=p1[[3]],xx=p2[[1]],yy=p2[[2]],zz=p2[[3]]
			},
			Sqrt[(-yy z+y zz)^2+(xx z-x zz)^2+(-xx y+x yy)^2]
		]
	]
},
	With[{p=data[[#]]},expandExpression@unNormalVector3D[p[[3]]-p[[2]],p[[1]]-p[[2]]]]&/@triples
] 

faceAreaAnalytic[2, positions_, triples_]:=
With[
{
	data=positions,
	unNormalVector3D=Function[
		{p1,p2},
		With[
			{
			x=p1[[1]],y=p1[[2]],xx=p2[[1]],yy=p2[[2]]
			},
			Sqrt[(-xx y+x yy)^2]
		]
	]
},
	With[{p=data[[#]]},expandExpression@unNormalVector3D[p[[3]]-p[[2]],p[[1]]-p[[2]]]]&/@triples
] 


PlaneAngle[ __ , {}] := {}
PlaneAngle[ m_?MechanismQ, tripleList_ ] := With[ {res = PlaneAngle[ m["VertexCoordinates"], tripleList /. m["labels"] ]},
	res /; Head[res] =!= PlaneAngle
]
PlaneAngle[ m_?MechanismQ, positions_ , tripleList_ ] := With[ {res = PlaneAngle[ positions, tripleList /. m["labels"]]},
	res /; Head[res] =!= PlaneAngle
]

PlaneAngle[ positions_?NumericMachinePrecisionCoordinatesQ , tripleList_ ] :=
	planeAngleCompiled[ Length[positions[[1]]] ][ ToPackedArray[positions], ToPackedArray[tripleList] ] /; geometryValidTriplesQ[ positions, tripleList ]
PlaneAngle[ positions_?VertexCoordinatesQ , tripleList_ ] :=
	planeAngleAnalytic[ Length[positions[[1]]] , ToPackedArray[positions], ToPackedArray[tripleList] ] /; geometryValidTriplesQ[ positions, tripleList ]
PlaneAngle[ positions_?numericalListQ , tripleList_ ] :=
	(planeAngleCompiled[ Length[positions[[1,1]]] ][ #, ToPackedArray[tripleList] ]& /@ ToPackedArray[positions]) /; geometryValidTriplesQ[ positions[[1]], tripleList ]
PlaneAngle[ positions_?VertexCoordinateListQ , tripleList_ ] :=
	planeAngleAnalytic[ Length[positions[[1,1]]] , #, ToPackedArray[tripleList] ]& /@ positions /; geometryValidTriplesQ[ positions[[1]], tripleList ]

PlaneAngle[ positions_ , tripleList_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[geometryValidTriplesQ[positions,tripleList]], Message[PlaneAngle::triples, tripleList] ];
	If[ VertexCoordinateListQ[ positions ] && Not[geometryValidTriplesQ[positions,tripleList]] , Message[PlaneAngle::triples, tripleList] ];
	If[ Not[MechanismQ[positions]] && (Not[ VertexCoordinatesQ[positions] ] || Not[ VertexCoordinateListQ[ positions ] ]), Message[PlaneAngle::pos, positions] ];
	False
)

PlaneAngle::pos = "Positions `1` provided are not valid.";
PlaneAngle::triples = "Triples `1` are not a list of integer triplets.";


planeAngleCompiled[3]:=planeAngleCompiled[3]=
Compile[
{{pos,_Real,2},{triplets,_Integer,2}},Module[{i},
	Table[
		With[{
		x=Compile`GetElement[pos,Compile`GetElement[triplets,i,1],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1],
		y=Compile`GetElement[pos,Compile`GetElement[triplets,i,1],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2],
		z=Compile`GetElement[pos,Compile`GetElement[triplets,i,1],3]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],3],
		xx=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1],
		yy=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2],
		zz=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],3]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],3]
		},
		ArcTan[x xx+y yy+z zz,Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2]]
		],
	{i,1,Length[triplets]}
	]],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]
planeAngleCompiled[2]:=planeAngleCompiled[2]=Compile[
{{pos,_Real,2},{triplets,_Real,2}},Module[{i},
	Table[With[{
		x=Compile`GetElement[pos,Compile`GetElement[triplets,i,1],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1],
		y=Compile`GetElement[pos,Compile`GetElement[triplets,i,1],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2],
		xx=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],1]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],1],
		yy=Compile`GetElement[pos,Compile`GetElement[triplets,i,3],2]-Compile`GetElement[pos,Compile`GetElement[triplets,i,2],2]
	},
			ArcTan[x xx+y yy,(xx y-x yy)^2]
	],{i,1,Length[triplets]}
	]
],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]


planeAngleAnalytic[3,positions_,tripleList_]:=
With[
{
	data=positions,
	angleFunc=Function[{p1,p2},
		With[
			{x=p1[[1]],y=p1[[2]],z=p1[[3]],xx=p2[[1]],yy=p2[[2]],zz=p2[[3]]},
			ArcTan[x xx+y yy+z zz,Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2]]
		]
	]
},
	With[{pts=data[[#]]},expandExpression@angleFunc[pts[[1]]-pts[[2]],pts[[3]]-pts[[2]]]]&/@tripleList
]


planeAngleAnalytic[2,positions_,tripleList_]:=
With[
{
	data=positions,
	angleFunc=Function[{p1,p2},
		With[
			{x=p1[[1]],y=p1[[2]],xx=p2[[1]],yy=p2[[2]]},
			ArcTan[x xx+y yy,(xx y-x yy)^2]
		]
	]
},
	With[{pts=data[[#]]},expandExpression@angleFunc[pts[[1]]-pts[[2]],pts[[3]]-pts[[2]]]]&/@tripleList
]


TorsionalFoldAngle[ m_?MechanismQ , _ , {} ] := {}

TorsionalFoldAngle[ m_?MechanismQ, edges_ ] := 
With[ {res=TorsionalFoldAngle[m, m["VertexCoordinates"], edges ]},
	res /; Head[res] =!= TorsionalFoldAngle
]

TorsionalFoldAngle[ m_?MechanismQ , positions_?NumericMachinePrecisionCoordinatesQ , edges_ ] :=
	If[ Length[positions[[1]]]==2, ConstantArray[0, Length[edges] ] ,
		torsionalFoldAngleCompiled[][ positions , turnEdgesIntoFaces[ m , edges] ]
	] /; VertexCoordinatesQ[ m , positions ] && geometryValidEdgesQ[positions,edges]
TorsionalFoldAngle[ m_?MechanismQ , positions_ , edges_ ] :=
	If[ Length[positions[[1]]]==2, ConstantArray[0, Length[edges] ] ,
		torsionalFoldAngleAnalytic[ positions , turnEdgesIntoFaces[ m , edges] ]
	] /; VertexCoordinatesQ[ m , positions ] && geometryValidEdgesQ[positions,edges]

TorsionalFoldAngle[ m_?MechanismQ, positions_?numericalListQ, edges_ ] :=
	If[ Length[positions[[1,1]]]==2,
		ConstantArray[ 0, {Length[positions], Length[edges] }],
		With[ {quads = turnEdgesIntoFaces[ m, edges] }, torsionalFoldAngleCompiled[][ # , quads]& /@ positions ]
	] /; VertexCoordinatesQ[ m, positions[[1]] ] && geometryValidEdgesQ[positions[[1]],edges]
TorsionalFoldAngle[ m_?MechanismQ, positions_?VertexCoordinateListQ, edges_ ] :=
	If[ Length[positions[[1,1]]]==2,
		ConstantArray[ 0, {Length[positions], Length[edges] }],
		With[ {quads = turnEdgesIntoFaces[ m, edges] }, torsionalFoldAngleAnalytic[][ # , quads]& /@ positions ]
	] /; VertexCoordinatesQ[ m, positions[[1]] ] && geometryValidEdgesQ[positions[[1]],edges]

turnEdgesIntoFaces[ m_, edges_ ] := 
Module[{ edgeIndices = MechanismEdges[m, edges] , faces = MechanismConnectivity[m, "edges" -> "ordered faces"]},
	If[ Length[Cases[edgeIndices,_Missing][[All,2]]] > 0, (*some edges don't exist*)
		Message[TorsionalFoldAngle::notedge, Cases[edgeIndices,_Missing][[All,2]]]; 
		(*remove non-existant edges*)
		edgeIndices = DeleteMissing[edgeIndices]
	];

	(*edges abutting one face are on the boundary*)
	If[ AnyTrue[Length/@faces[[edgeIndices]],#==1&], Message[TorsionalFoldAngle::boundary, MechanismEdges[m][[ Pick[ edgeIndices, Length/@faces[[edgeIndices]], 1] ]]]];
	(*edges abutting more than 2 faces are not supported*)
	If[ AnyTrue[Length/@faces[[edgeIndices]],#>2&], Message[TorsionalFoldAngle::notbin, MechanismEdges[m][[ Pick[ edgeIndices, (#>2&)/@Length/@faces[[edgeIndices]] ] ]]]];

	(*send in only the edges abutting two faces.*)
	listQuadruples[ faces[[ Pick[ edgeIndices, Length/@faces[[edgeIndices]], 2 ] ]] ]
]

TorsionalFoldAngle[ m_?MechanismQ , positions_ , edges_ ] := "nothing" /; (
	If[ VertexCoordinatesQ[positions] && Not[ geometryValidEdgesQ[ positions, edges ] ], Message[TorsionalFoldAngle::syn] ];
	If[ ListQ[positions] && VertexCoordinatesQ[positions[[1]]] && Not[ geometryValidEdgesQ[ positions[[1]], edges ] ], Message[TorsionalFoldAngle::syn] ];
	If[ Not[ VertexCoordinatesQ[ m , positions ]] && Not[ VertexCoordinateListQ[positions]] , Message[TorsionalFoldAngle::pos, positions] ];
	False
)

TorsionalFoldAngle::syn = "Edges must be pairs of vertices.";
TorsionalFoldAngle::notedge = "`1` are not valid edges.";
TorsionalFoldAngle::boundary = "Edges `1` are on the boundary.";
TorsionalFoldAngle::notbin = "Edges `1` are not between a unique pair of faces.";
TorsionalFoldAngle::pos = "Positions `1` do not correspond to mechanism.";


listQuadruples[faces_] :=
	ToPackedArray[
		If[Length[#]==2,
			{#[[2,1]],#[[2,2]],#[[1,2]],Last@#[[2]]},
			{#[[1,1]],#[[1,2]],0,0}
		]&/@faces
	]


torsionalFoldAngleCompiled[]:=torsionalFoldAngleCompiled[]=
Compile[
{{pos,_Real,2},{Faces,_Integer,2}},
Table[
	If[Compile`GetElement[Faces,i,3]==0,
	0,
	With[
		{
		p1x=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],1],
		p1y=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],2],
		p1z=Compile`GetElement[pos,Compile`GetElement[Faces,i,1],3],
		p2x=Compile`GetElement[pos,Compile`GetElement[Faces,i,2],1],
		p2y=Compile`GetElement[pos,Compile`GetElement[Faces,i,2],2],
		p2z=Compile`GetElement[pos,Compile`GetElement[Faces,i,2],3],
		p3x=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],1],
		p3y=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],2],
		p3z=Compile`GetElement[pos,Compile`GetElement[Faces,i,3],3],
		p4x=Compile`GetElement[pos,Compile`GetElement[Faces,i,4],1],
		p4y=Compile`GetElement[pos,Compile`GetElement[Faces,i,4],2],
		p4z=Compile`GetElement[pos,Compile`GetElement[Faces,i,4],3]
		},
		ArcTan[(p1y (p2x-p3x)+p2y p3x-p2x p3y+p1x (-p2y+p3y)) (-p2y p4x+p1y (-p2x+p4x)+p1x (p2y-p4y)+p2x p4y)+(p1z (p2x-p3x)+p2z p3x-p2x p3z+p1x (-p2z+p3z)) (-p2z p4x+p1z (-p2x+p4x)+p1x (p2z-p4z)+p2x p4z)+(p1z (p2y-p3y)+p2z p3y-p2y p3z+p1y (-p2z+p3z)) (-p2z p4y+p1z (-p2y+p4y)+p1y (p2z-p4z)+p2y p4z),Sqrt[(p1x-p2x)^2+(p1y-p2y)^2+(p1z-p2z)^2] (-p1x p2z p3y+p1x p2y p3z+p2z p3y p4x-p2y p3z p4x+p1x p2z p4y-p2z p3x p4y-p1x p3z p4y+p2x p3z p4y+p1z (p2x p3y-p3y p4x+p2y (-p3x+p4x)-p2x p4y+p3x p4y)+(-p1x p2y+p2y p3x+p1x p3y-p2x p3y) p4z+p1y (p2z p3x-p2x p3z-p2z p4x+p3z p4x+p2x p4z-p3x p4z))]
	]],
	{i,1,Length[Faces]}
],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]

torsionalFoldAngleAnalytic[positions_,quadrupleList_]:=
	With[
	{
	p1x=positions[[#[[1]],1]],p1y=positions[[#[[1]],2]],p1z=positions[[#[[1]],3]],
	p2x=positions[[#[[2]],1]],p2y=positions[[#[[2]],2]],p2z=positions[[#[[2]],3]],
	p3x=positions[[#[[3]],1]],p3y=positions[[#[[3]],2]],p3z=positions[[#[[3]],3]],
	p4x=positions[[#[[4]],1]],p4y=positions[[#[[4]],2]],p4z=positions[[#[[4]],3]]
	},
	expandExpression@ArcTan[(p1y (p2x-p3x)+p2y p3x-p2x p3y+p1x (-p2y+p3y)) (-p2y p4x+p1y (-p2x+p4x)+p1x (p2y-p4y)+p2x p4y)+(p1z (p2x-p3x)+p2z p3x-p2x p3z+p1x (-p2z+p3z)) (-p2z p4x+p1z (-p2x+p4x)+p1x (p2z-p4z)+p2x p4z)+(p1z (p2y-p3y)+p2z p3y-p2y p3z+p1y (-p2z+p3z)) (-p2z p4y+p1z (-p2y+p4y)+p1y (p2z-p4z)+p2y p4z),Sqrt[(p1x-p2x)^2+(p1y-p2y)^2+(p1z-p2z)^2] (-p1x p2z p3y+p1x p2y p3z+p2z p3y p4x-p2y p3z p4x+p1x p2z p4y-p2z p3x p4y-p1x p3z p4y+p2x p3z p4y+p1z (p2x p3y-p3y p4x+p2y (-p3x+p4x)-p2x p4y+p3x p4y)+(-p1x p2y+p2y p3x+p1x p3y-p2x p3y) p4z+p1y (p2z p3x-p2x p3z-p2z p4x+p3z p4x+p2x p4z-p3x p4z))]
	]&/@quadrupleList


DiscreteGaussianCurvature[ m_?MechanismQ , {} ] := {}
DiscreteGaussianCurvature[ m_?MechanismQ , _, {} ] := {}

DiscreteGaussianCurvature[ m_?MechanismQ, vertexList_ ] := With[ {res=DiscreteGaussianCurvature[m , m["VertexCoordinates"], vertexList]},
	res /; Head[res] =!= DiscreteGaussianCurvature
]

DiscreteGaussianCurvature[ m_?MechanismQ, positions_?NumericMachinePrecisionCoordinatesQ , vertexList_?(VectorQ[ #, IntegerQ ]&) ] :=
	discreteGaussianCurvatureCompiled[][ ToPackedArray[positions] , getTriplesCompiled[m][[vertexList]] ] /; VertexCoordinatesQ[ m, positions] && Min[vertexList] > 0 && Max[vertexList] <= Length[positions] && Length[positions[[1]]] == 3
DiscreteGaussianCurvature[ m_?MechanismQ, positions_ , vertexList_?(VectorQ[ #, IntegerQ ]&) ] :=
	discreteGaussianCurvatureAnalytic[ positions , getTriplesAnalytic[m][[vertexList]] ] /; VertexCoordinatesQ[ m, positions] && Min[vertexList] > 0 && Max[vertexList] <= Length[positions] && Length[positions[[1]]] == 3
DiscreteGaussianCurvature[ m_?MechanismQ, positions_?numericalListQ, vertexList_?(VectorQ[ #, IntegerQ]&) ] :=
With[ {triples = getTriplesCompiled[m][[vertexList]]},
	discreteGaussianCurvatureCompiled[][ # , triples ]& /@ ToPackedArray[positions]
] /; VertexCoordinatesQ[ m, positions] && Min[vertexList] > 0 && Max[vertexList] <= Length[positions] && Length[positions[[1]]] == 3
DiscreteGaussianCurvature[ m_?MechanismQ, positions_?numericalListQ, vertexList_?(VectorQ[ #, IntegerQ]&) ] :=
With[{triples = getTriplesAnalytic[m][[vertexList]]},
	discreteGaussianCurvatureAnalytic[ # , triples ]& /@ positions/; VertexCoordinatesQ[ m, positions] && Min[vertexList] > 0 && Max[vertexList] <= Length[positions] && Length[positions[[1]]] == 3
]

DiscreteGaussianCurvature[ m_?MechanismQ , positions_, vertexList_ ] := "nothing" /; (
	If[ Not[ VertexCoordinatesQ[ m, positions ] ] || Not[ VertexCoordinateListQ[ m, positions ] ], Message[DiscreteGaussianCurvature::pos, positions] ];
	If[ Not[VectorQ[ vertexList, IntegerQ ]] || Min[vertexList] <= 0 , Message[DiscreteGaussianCurvature::vert, vertexList] ];
	False
)

DiscreteGaussianCurvature::pos = "Positions `1` do not correspond to mechanism.";
DiscreteGaussianCurvature::vert = "Vertices `1` are not all valid.";


getTriplesAnalytic[m_] :=  ToPackedArray[MechanismConnectivity[ m, "vertices" ->"ordered faces"][[All,All,{-1,1,2}]]]
getTriplesCompiled[m_] :=  PadRight[ToPackedArray[MechanismConnectivity[ m, "vertices" ->"ordered faces"][[All,All,{1,2,-1}]]]]


discreteGaussianCurvatureCompiled[]:=discreteGaussianCurvatureCompiled[]=
Compile[{{pos,_Real,2},{triplets,_Integer,3}},
	Module[{i,j},Table[2 Pi-Sum[
		If[Compile`GetElement[triplets,j,i,1]==0,
			0,
			With[{
			x=Compile`GetElement[pos,Compile`GetElement[triplets,j,i,3],1]-Compile`GetElement[pos,Compile`GetElement[triplets,j,i,1],1],
			y=Compile`GetElement[pos,Compile`GetElement[triplets,j,i,3],2]-Compile`GetElement[pos,Compile`GetElement[triplets,j,i,1],2],
			z=Compile`GetElement[pos,Compile`GetElement[triplets,j,i,3],3]-Compile`GetElement[pos,Compile`GetElement[triplets,j,i,1],3],
			xx=Compile`GetElement[pos,Compile`GetElement[triplets,j,i,2],1]-Compile`GetElement[pos,Compile`GetElement[triplets,j,i,1],1],
			yy=Compile`GetElement[pos,Compile`GetElement[triplets,j,i,2],2]-Compile`GetElement[pos,Compile`GetElement[triplets,j,i,1],2],
			zz=Compile`GetElement[pos,Compile`GetElement[triplets,j,i,2],3]-Compile`GetElement[pos,Compile`GetElement[triplets,j,i,1],3]
			},
			ArcTan[x xx+y yy+z zz,Sqrt[(xx y-x yy)^2+(xx z-x zz)^2+(yy z-y zz)^2]]
			]
		],
		{i,1,Length[Compile`GetElement[triplets,j]]}(* Sum *)
	],{j,1,Length[triplets]}] (* Table *)
	],
	RuntimeOptions->"Speed",
	CompilationTarget->$MechanismCompilationTarget
]


discreteGaussianCurvatureAnalytic[ pos_, triples_]:=
	(expandExpression@(2 Pi-Total[PlaneAngle[pos,#]]))& /@ triples


FindGeometricTransform[pts_, m_Origami, r___ ] ^:= FindGeometricTransform[ pts, m["VertexCoordinates"], r ]
FindGeometricTransform[m1_Origami, m2_Origami, r___] ^:= FindGeometricTransform[ m1["VertexCoordinates"], m2["VertexCoordinates"], r]

FindGeometricTransform[pts_, m_Linkage, r___ ] ^:= FindGeometricTransform[ pts, m["VertexCoordinates"], r ]
FindGeometricTransform[m1_Linkage, m2_Linkage, r___] ^:= FindGeometricTransform[ m1["VertexCoordinates"], m2["VertexCoordinates"], r]


Options[AlignMechanism]=Options[FindGeometricTransform];

AlignMechanism[ from_, to_, opt : OptionsPattern[] ] := 
With[{fromPos = convertToAlign[ from ], toPos = convertToAlign[ to ]},
	With[{ transform = alignTransform[ fromPos, toPos, {opt} ] },
		transform[ toPos[[1]] ] /; transform =!= $Failed
	] /; fromPos =!= $Failed && toPos =!= $Failed
]


(*convert the arguments appropriately*)
convertToAlign[ m1_?MechanismQ ] := { m1["VertexCoordinates"], All}
convertToAlign[ { m1_?MechanismQ , v : {__Integer} } ] := {m1["VertexCoordinates"], v} /; Max[v] <= m1["VertexCount"] && Min[v]>0
convertToAlign[ {m1_?MechanismQ, v_ } ] := (Message[AlignMechanism::oob, v]; $Failed )

convertToAlign[ pos_?NumericCoordinatesQ ] := {pos,All}
convertToAlign[ {pos_?NumericCoordinatesQ, v : {__Integer} } ] := {pos,v} /; Max[v] <= Length[pos] && Min[v] > 0
convertToAlign[ {pos_?NumericCoordinatesQ, v_ } ] := (Message[AlignMechanism::oob,v]; $Failed )
convertToAlign[ {pos_, v_} ] := (Message[AlignMechanism::num]; $Failed)

AlignMechanism::oob = "Specified vertices `1` are out of bounds of Mechanism.";
AlignMechanism::num = "Vertex positions must be numerical.";


(*find the geometric transform we need*)
alignTransform[ {positionsFrom_,vFrom_}, {positionsTo_,vTo_}, options_ ] := 
With[{
transformation = FindGeometricTransform[positionsFrom[[vFrom]], positionsTo[[vTo]], Flatten[{options, {TransformationClass -> "Rigid", Method -> "Linear" }}] ]
},
	If[Head[transformation] === FindGeometricTransform, Message[AlignMechanism::gt]; $Failed, transformation[[2]] ]
] /; Dimensions[positionsFrom] == Dimensions[positionsTo]

alignTransform[ {positionsFrom_,vFrom_}, {positionsTo_,vTo_}, options_ ] := (Message[AlignMechanism::match]; $Failed)

AlignMechanism::gt = "Failed to find geometric transform.";
AlignMechanism::match = "Vertices are not of the same dimension and number.";


CongruentMechanismQ[tolerance_?(NumericQ[#]&&#>0&)][ from_, to_ ] := With[
{ fromPos = convertToAlign[from ], toPos = convertToAlign[ to ] },
	With[ { transform = alignTransform[ fromPos, toPos, {} ] },
		With[ { difference = Flatten[transform[ toPos[[1]] ] - fromPos[[1]]] },
			difference . difference < tolerance
		] /; transform =!= $Failed
	] /; fromPos =!= $Failed && toPos =!= $Failed
]


BoundingRegion[o_Origami, r___] ^:= BoundingRegion[ o["VertexCoordinates"], r ]
BoundingRegion[o_Linkage, r___] ^:= BoundingRegion[ o["VertexCoordinates"], r ]


RegionNearest[ f_Linkage, pt_ ] ^:= RegionNearest[ f["MeshRegion"], pt ]
RegionNearest[ f_Linkage ] ^:= RegionNearest[ f["MeshRegion"] ]

RegionNearest[ f_Origami, pt_ ] ^:= RegionNearest[ f["MeshRegion"], pt ]
RegionNearest[ f_Origami ] ^:= RegionNearest[ f["MeshRegion"] ]


RegionMember[ f_Linkage, pt_ ] ^:= RegionMember[ f["MeshRegion"], pt ]
RegionMember[ f_Linkage ] ^:= RegionMember[ f["MeshRegion"] ]

RegionMember[ f_Origami, pt_ ] ^:= RegionMember[ f["MeshRegion"], pt ]
RegionMember[ f_Origami ] ^:= RegionMember[ f["MeshRegion"] ]


RegionBounds[ f_Linkage, type___ ] ^:= RegionBounds[ f["MeshRegion"], type ]
RegionBounds[ f_Origami, type___ ] ^:= RegionBounds[ f["MeshRegion"], type ]


RandomPoint[ f_Linkage, reg___ ] ^:= RandomPoint[ f["MeshRegion"], reg ]
RandomPoint[ f_Origami, reg___ ] ^:= RandomPoint[ f["MeshRegion"], reg ]


RegionCentroid[ f_Linkage ] ^:= RegionCentroid[ f["MeshRegion"] ]
RegionCentroid[ f_Origami ] ^:= RegionCentroid[ f["MeshRegion"] ]


RegionDistance[ f_Linkage, p___ ] ^:= RegionDistance[ f["MeshRegion"], p ]
RegionDistance[ f_Origami, p___ ] ^:= RegionDistance[ f["MeshRegion"], p ]


SignedRegionDistance[ f_Linkage, p___ ] ^:= SignedRegionDistance[ f["MeshRegion"], p ]
SignedRegionDistance[ f_Origami, p___ ] ^:= SignedRegionDistance[ f["MeshRegion"], p ]


(*tierEdges::usage="tierEdges[m] partitions the edges of a 2D Mechanism into tiers so that no two edges sharing a vertex are on the same tier.";*)


selectEdgeTiers[ {edgeList_, other_} ] := 
With[{
	pass =Sort/@(List@@@FindIndependentEdgeSet[UndirectedEdge@@@edgeList])
},
	{
	DeleteCases[ Sort /@ edgeList, Alternatives@@pass],
	Join[{pass},other]
	}
]

tierEdges[ m_?MechanismQ ] := With[{edges = MechanismEdges[m]},
	Reverse[NestWhile[selectEdgeTiers,{edges,{}}, Length[First[#]]>0&][[2]]]
] /; MechanismEmbeddingDimension[m]==2

tierEdges[ m_?MechanismQ ] := "nothing" /; Message[tierEdges::embdim]

tierEdges::embdim="Mechanism embedding dimension must be 2.";


ZeroLengthEdgeQ[ m_?MechanismQ, pos_ , precision : _?NumericQ : 10^(-16) ] := zeroLengthEdgeQinternal[m, pos, precision] /; VertexCoordinatesQ[m,pos]
ZeroLengthEdgeQ[ m_?MechanismQ, precision : _?NumericQ : 10^(-16) ] := zeroLengthEdgeQinternal[m, MechanismPositions[m], precision]

zeroLengthEdgeQinternal[ m_, positions_ , precision_ ] :=
With[ { lengths = DisplacementLengthSquared[positions, MechanismEdges[m] ] },
	If[ VectorQ[lengths, NumericQ] , 
		AnyTrue[ lengths, Abs[#] <= precision& ],
		AnyTrue[ Simplify[ lengths ], #===0 & ]
	]
]


MechanismCellTest[ m_?MechanismQ, rest__] := MechanismCellTest[rest][m]

MechanismCellTest[cells_List, geometricComputation_ , test_][m_?MechanismQ] := 
With[{result = geometricComputation[m, cells]},
	If[ ListQ[result], Pick[ cells , TrueQ /@ test /@ result ], {} ]
]

MechanismCellTest[ cellSelector : Except[_List] , geometricComputation_ , test_][m_?MechanismQ] := 
With[{ cells = cellSelector[m] },
	With[{ result = geometricComputation[m, cells]},
		If[ ListQ[result], Pick[ cells , TrueQ /@ test /@ result ], {} ]
]]


(*this is a private function*)
$parsableExpressions = {
	(*these evaluate to arbitrary positions or whatever positions provided*)
	_FaceArea, 
	_DisplacementVector, 
	_DisplacementLength , 
	_DisplacementLengthSquared, 
	_TorsionalFoldAngle, 
	_PlaneAngle, 
	_TurningAngle, 
	_NormalVector,
	(*these evaluate to the positions associated with the mechanism*)
	FaceArea[0][_], 
	DisplacementVector[0][_], 
	DisplacementLength[0][_] , 
	DisplacementLengthSquared[0][_], 
	TorsionalFoldAngle[0][_], 
	PlaneAngle[0][_], 
	TurningAngle[0][_], 
	NormalVector[0][_]
};

extractParsableExpressions[ expr_List ] :=  
	Head[#[[1]]][#[[All,1]]]& /@ GatherBy[ DeleteDuplicates[ Cases[ expr, Alternatives@@$parsableExpressions , Infinity]], Head ]
extractParsableExpressions[ expr_ ] :=  
	Head[#[[1]]][#[[All,1]]]& /@ GatherBy[ DeleteDuplicates[ Cases[ {expr}, Alternatives@@$parsableExpressions , Infinity]], Head ]

computeGeometricQuantities[ m_, positions_, arbitraryPositions_ , (head : TorsionalFoldAngle|DiscreteGaussianCurvature)[indices_] ] := Thread[(head/@indices) -> head[m, arbitraryPositions, indices]]
computeGeometricQuantities[ m_, positions_, arbitraryPositions_ , (head : TorsionalFoldAngle|DiscreteGaussianCurvature)[0][indices_] ] := Thread[(head[0]/@indices) -> head[m, positions, indices]]
computeGeometricQuantities[ m_, positions_, arbitraryPositions_, head_[indices_] ] := Thread[(head/@indices) -> head[arbitraryPositions, indices]]
computeGeometricQuantities[ m_, positions_, arbitraryPositions_, head_[0][indices_] ] := Thread[(head[0]/@indices) -> head[positions, indices]]

MechanismGeometricExpression[ m_?MechanismQ, expression_ ] :=
With[{
	parsableExpressions = extractParsableExpressions[expression],
	arbitraryPositions = VertexPosition[m],
	positions = m["VertexCoordinates"],
	positionRules = Dispatch[Thread[Flatten[VertexPosition[m] /. VertexPosition -> VertexPosition[0]] -> Flatten[m["VertexCoordinates"]]]]
},
	expression /. Dispatch@Flatten[computeGeometricQuantities[ m, positions , arbitraryPositions, #] & /@ parsableExpressions] /. positionRules
]

MechanismGeometricExpression[ m_?MechanismQ, positions_ , expression_ ] :=
With[{
	parsableExpressions = extractParsableExpressions[expression],
	mechanismPositions = m["VertexCoordinates"],
	positionRules = Dispatch[Thread[Flatten[VertexPosition[m] /. VertexPosition -> VertexPosition[0]] -> Flatten[m["VertexCoordinates"]]]]
},
	expression /. Dispatch@Flatten[computeGeometricQuantities[ m, mechanismPositions , positions, #] & /@ parsableExpressions] /. Dispatch[ PositionRules[positions] ] /. positionRules
] /; VertexCoordinatesQ[m, positions]


incrementVertices[d_List]:=#+1&/@d
decrementVertices[d_List]:=#-1&/@d

SaveToFOLD[m_?MechanismQ , filename_String ]:=
Export[filename,
	{
	"file_spec" -> $MechanismsVersion,
	"file_creator" -> "Mechanisms",
	"file_classes" -> {"singleModel"},
	"frame_classes" -> {"creasePattern"},
	"frame_attributes" -> {
		Switch[ MechanismDisplayDimension[m], 2, "2D", 3, "3D",_, Nothing ],
		If[ Head[m]===Origami > 0, "manifold", Nothing ],
		If[ MechanismOrientedQ[ m ], "orientable", "nonOrientable" ]
	},
	"frame_unit" -> "unit",
	"vertices_coords" -> m["VertexCoordinates"],
	"edges_vertices" -> decrementVertices /@ MechanismConnectivity[m, "edges" -> "vertices"],
	"Faces_vertices" -> decrementVertices /@ MechanismConnectivity[m, "faces" -> "vertices"]
},"JSON"]


Options[LoadFromFOLD]=Join[{ "Face"->(Face[#]&)}, Options[Origami] ];

LoadFromFOLD[filename_String,opt:OptionsPattern[]]:=Module[
{
	inputData=Import[filename,"JSON"],
	coords,edges,Faces
},
	If[inputData === $Failed,
		$Failed,

		coords="vertices_coords" /. inputData;
		edges="edges_vertices" /. inputData;
		Faces="Faces_vertices" /. inputData;

		Origami[ coords, Join[ OptionValue["Face"] /@ incrementVertices /@ Faces], FilterRules[{opt},Options[Origami]] ]
	]
]


End[];

EndPackage[];


BeginPackage["Mechanisms`rigidity`"];


RandomCellNetwork::usage="RandomCellNetwork[\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] returns a random network of \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)cells based on a Voronoi tesselation of \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) points and contained in a periodic region Rectangle[{0,0},{1,1}].";
RandomTriangulatedNetwork::usage="RandomTriangulatedNetwork[\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] returns a random triangulated network based on a Delaunay triangulation of \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) vertices contained in a periodic region Rectangle[{0,0},{1,1}].";

Henneberg::usage="Henneberg[1][{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),...}, \!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\)] is a generalized Henneberg operation of type 1 that creates a new vertex at \!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\) and attaches it to existing vertices {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),...}.
A proper Henneberg type-1 move in 2D attaches to two vertices only.

Henneberg[2][{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\)},\!\(\*
StyleBox[\"label\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\)] is a Henneberg operation of type 2 that subdivides an edge {\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),}, places a new vertex at \!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\), and connects it to vertex \!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(3\)]\).
Henneberg[\!\(\*
StyleBox[\"t\",\nFontSlant->\"Italic\"]\)][\!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\)] is a random Henneberg operation of type \!\(\*
StyleBox[\"t\",\nFontSlant->\"Italic\"]\), placing the new vertex at \!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\).

In two dimensions, Henneberg moves takes a 0 degree of freedom mechanism to another 0 degree of freedom mechanism.";

BlockFaces::usage="BlockFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"f\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\) ], BlockFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"f\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"thickness\",\nFontSlant->\"Italic\"]\)] rigidifies a list of faces \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"f\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)  by adding edges and vertices. The block size is specified by \!\(\*
StyleBox[\"thickness\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Plain\"]\)
BlockFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)], BlockFaces[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"thickness\",\nFontSlant->\"Italic\"]\)] rigidies all the nontriangular faces of a mechanism by adding edges and vertices.";


MechanismCellData::usage = "MechanismCellData[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns the equilibrium data for all cells in the form { \!\(\*
StyleBox[\"cellType\",\nFontSlant->\"Italic\"]\)[ {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ], <| \!\(\*SubscriptBox[
StyleBox[\"dataType\",\nFontSlant->\"Italic\"], \(1\)]\) -> \!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(1\)]\), ... |> }.
MechanismCellData[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\) ] returns the equilibrium data for all cells matching \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\) in the form { \!\(\*
StyleBox[\"cellType\",\nFontSlant->\"Italic\"]\)[ {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ], <| \!\(\*SubscriptBox[
StyleBox[\"dataType\",\nFontSlant->\"Italic\"], \(1\)]\) -> \!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(1\)]\), ... |> }.";

MechanismCellRawData::usage = "MechanismCellRawData[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns the raw data (as specified) for all cells in the form { \!\(\*
StyleBox[\"cellType\",\nFontSlant->\"Italic\"]\)[ {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ], <| \!\(\*SubscriptBox[
StyleBox[\"dataType\",\nFontSlant->\"Italic\"], \(1\)]\) -> \!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(1\)]\), ... |> }.
MechanismCellRawData[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\)] returns the raw data for all cells matching \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\) in the form { \!\(\*
StyleBox[\"cellType\",\nFontSlant->\"Italic\"]\)[ {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ], <| \!\(\*SubscriptBox[
StyleBox[\"dataType\",\nFontSlant->\"Italic\"], \(1\)]\) -> \!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(1\)]\), ... |> }.
MechanismCellRawData[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\) , \!\(\*
StyleBox[\"dataType\",\nFontSlant->\"Italic\"]\) \[RightArrow] \!\(\*
StyleBox[\"data\",\nFontSlant->\"Italic\"]\)] returns the specified raw data for cells matching \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\) and specific data.";

MechanismCellDataValue::usage = "MechanismCellDataValue[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pattern\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"dataType\",\nFontSlant->\"Italic\"]\)] returns only the specified equilibrium data for cells matching a pattern in the form { \!\(\*
StyleBox[\"cellType\",\nFontSlant->\"Italic\"]\)[ {\!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"cell\",\nFontSlant->\"Italic\"], \(2\)]\), ...} ], <| \!\(\*SubscriptBox[
StyleBox[\"dataType\",\nFontSlant->\"Italic\"], \(1\)]\) -> \!\(\*SubscriptBox[
StyleBox[\"data\",\nFontSlant->\"Italic\"], \(1\)]\), ... |> }.";

MechanismConstrainedCells::usage="MechanismConstrainedCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns a list of cells with infinite stiffness.
MechanismConstrainedCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) , {\!\(\*
StyleBox[\"head\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"indices\",\nFontSlant->\"Italic\"]\)}] returns a list of cells matching the specification with infinite stiffness.
MechanismConstrainedCells[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"patt\",\nFontSlant->\"Italic\"]\)] returns a list of cells matching a pattern and having infinite stiffness.";


RandomDisplacements::usage="RandomDisplacements[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] returns n random displacements of mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) respecting linear constraints.
RandomDisplacements[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns only one set of random displacements.";

RandomPositions::usage="RandomPositions[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] returns \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) positions that have been randomly displaced in mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) while respecting linear constraints.
RandomPositions[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns only one set of random positions.";

Distribution::usage="Distribution is an option in the Mechanisms package for RandomDisplacements and RandomPositions to specify a distribution for perturbing vertices.";


Constraints::usage="Constraints is an option in the Mechanisms package to specify additional mechanism constraints.";
EliminationRules::usage="EliminationRules is an option in the Mechanisms package to specify a set of replacement rules for vertex displacements.";
AddedEnergy::usage="AddedEnergy is an option in the Mechanisms package for additional terms added to an energy.";
ConstraintOutput::usage="ConstraintOutput is an option for MechanismConstraintEquations and related functions to determine that can take the value VertexPosition or VertexDisplacement.";
StepSize::usage="StepSize is an option for MechanismIsometricTrajectory[] to set the step size used to traverse the configuration space.";
OutputVariables::usage="OutputVariables is an option for MechanismInfinitesimalMotions to specify names for the output variables.";
InitialPositions::usage="InitialPositions is an option in the mechanisms package to specify initial positions.";
VertexMass::usage="VertexMass is an option in the Mechanisms package to add mass to the vertices of a mechanism.";
VertexDrag::usage="VertexDrag is an option in the mechanisms package to add drag to the vertices of a mechanism.";
StoppingCriteria::usage="StoppingCriteria is an option for MechanismIsometricTrajectory[]. It can be either None or a function that takes the current vertex positions and the tangent direction and returns True if the calculation should contimue.";
SetParameters::usage="SetParameters is an option for MechanismEnergy[]. It should be a list of replacement rules specifying a numerical value for a set of parameters in the energy.";


FixMechanism::usage="FixMechanism[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] replaces cell data with its equilibrium value.";

Deformed::usage="Deformed[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\) ] represents a mechanism whose vertices have been deformed to \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\) without changing cell data.";


MechanismConstraintMap::usage="MechanismConstraintMap[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns the constraint map for a mechanism in terms of VertexPosition.
MechanismConstraintMap[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) ] returns the constraint map for a mechanism up to order \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) in terms of VertexDisplacement.
MechanismConstraintMap[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), Infinity ] returns the constraint map for a mechanism up to order Infinity in terms of VertexDisplacement.

When mechanism has a Deformed[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\)] wrapper, the constraint map is evaluated at \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\).";

MechanismLinearConstraints::usage="MechanismLinearConstraints[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns solutions to all the linear constraints provided in a mechanism.";

MechanismEnergy::usage=
"MechanismEnergy[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] returns an energy expression for a mechanism.

When mechanism has a Deformed[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\)] wrapper, the energy is evaluated at positions.

See $DefaultMechanismStiffnesses to determine how MechanismEnergy[] sets the default stiffnesses when the stiffness is Infinity.";

CompiledMechanismEnergy::usage=
"CompiledMechanismEnergy[ \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) ] compiles an energy and gradient for a Mechanism.

Undefined symbols in the energy must be set using ReplaceAll[], /.
Options:
  \"AddToEnergy\" -> energy allows additional terms, written as a function of VertexPosition[], to be added to the energy and compiled.";

CompiledMechanismEnergyQ::usage=
"CompiledMechanismEnergyQ[\!\(\*
StyleBox[\"energy\",\nFontSlant->\"Italic\"]\)] returns True if and only if \!\(\*
StyleBox[\"energy\",\nFontSlant->\"Italic\"]\) is a CompiledMechanismEnergy[] object.";

$DefaultMechanismStiffnesses::usage="$DefaultMechanismStiffnesses[\!\(\*
StyleBox[\"cell\",\nFontSlant->\"Italic\"]\)] returns the default stiffness in case the constraint is rigid.
Use $DefaultMechanismStiffnesses[\"Constraints\"] to find the stiffness of added constraints.";


ReduceLinearConstraints::usage="A Boolean option in the Mechanisms package that specifies whether linear constraints should be automatically solved.";


EuclideanMotionConstraints::usage="EuclideanMotionConstraints[\!\(\*
StyleBox[\"v\",\nFontSlant->\"Italic\"]\)], EuclideanMotionConstraints[{\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"v\",\nFontSlant->\"Italic\"], \(2\)]\),...}] represents constraints pinning the Euclidean motions of a mechanism by fixing the listed vertices.
EuclideanMotionConstraints[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"indices\",\nFontSlant->\"Italic\"]\) ] returns constraints associated with fixing the vertex or the list of vertices in \!\(\*
StyleBox[\"indices\",\nFontSlant->\"Italic\"]\).
The number of specified vertices must be less than or equal to the embedding dimension of the mechanism.";


MechanismConstraintMatrix::usage="MechanismConstraintMatrix[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\)] returns the constraint matrix for the first-order constraints.
When mechanism has a Deformed[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\)] wrapper, the constraint matrix is evaluated at positions.";

MechanismAugmentedConstraintMatrix::usage="Experimental!
MechanismAugmentedConstraintMatrix[\!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"pi\",\nFontSlant->\"Italic\"]\)] returns an augmented constraint matrix for mechanism \!\(\*
StyleBox[\"m\",\nFontSlant->\"Italic\"]\) with periodic data \!\(\*
StyleBox[\"pi\",\nFontSlant->\"Italic\"]\).
The augmented constraint matrix has 3 additional degrees of freedoms in 2D and 6 additional degrees of freedom in 3D corresponding to deformations of the lattice vectors.";

MechanismZeroModes::usage="MechanismZeroModes[m] returns a list of numerical zero modes (linear isometries) associated with the constraints of Mechanism m.
When mechanism has a Deformed[m, positions] wrapper, the zero modes are evaluated at positions.

It takes the options of MechanismConstraintMatrix[] and Eigensystem. Option Tolerance can be used to set a numerical value to correspond to 0.";

MechanismSelfStresses::usage="MechanismSelfStresses[m] returns a list of numerical self-stresses () modes associated with the constraints of Mechanism m.
When mechanism has a Deformed[m, positions] wrapper, the self stresses are evaluated at positions.

It takes the options of MechanismConstraintMatrix[] and Eigensystem. Option Tolerance can be used to set a numerical value to correspond to 0.";

MechanismInfinitesimalMotions::usage=
"MechanismInfinitesimalMotions[m] returns a list of two elements: an Infinitesimal linear motion and, if necessary, a list of quadratic constraints they must satisfy.

Use option OutputVariables to control the form of the output.";

MechanismStressMatrix::usage=
"MechanismStressMatrix[ m, vec ] returns a stress matrix associated with the stress vector vec. The (i,j) component of the stress matrix is the negative of the corresponding stress vector component (and zero otherwise) and diagonal components are chosen so that rows and columns sum to zero.

(see Connelly on generic global rigidity)";


ConstraintModulus::usage="ConstraintModulus is an option for MechanismEnergy to specify the modulus used to enforce nonlinear constraints.";


MechanismHamiltonianFlow::usage="MechanismHamiltonianFlow[ mechanism ] creates a Hamiltonian flow problem.";
MechanismGradientFlow::usage="MechanismGradientFlow[ mechanism ] creates a gradient flow problem.";

MechanismNDSolve::usage="MechanismNDSolve[ flow , initialConditions, {time, start time, end time} ] solves a flow problem from initial conditions.
MechanismNDSolve[ flow , initialConditions, {time, start time, end time, stepsize} ] solves a flow problem from initial conditions and returns a list of positions.";

MechanismItoProcess::usage="MechanismItoProcess[ flow, noise, initial conditions, {time, start time, end time} ] returns a list of positions subject to velocity noise.";


MinimizeMechanismEnergy::usage=
"MinimizeMechanismEnergy[\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"mechanism\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)], MinimizeMechanismEnergy[ \*
StyleBox[\(m\!\(\*
StyleBox[\"echanism\",\nFontSlant->\"Italic\"]\)\)], \!\(\*
StyleBox[\"energy\",\nFontSlant->\"Italic\"]\) ] minimizes the energy of a Mechanism, returning {\!\(\*
StyleBox[\"minimum\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"energy\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"mininal\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"vertex\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"positions\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\).
MinimizeMechanismEnergy[], MinimizeMechanismEnergy[ energy ] can be applied to a mechanism to produce a new mechanism with positions at a local energy minimum.

The optional argument \!\(\*
StyleBox[\"energy\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)can be either an expression or a compiled Mechanism energy.";

MetropolisEnergy::usage="MetropolisEnergy[m] creates a compiled energy to use in MechanismMetropolis[].";
MechanismMetropolis::usage="MechanismMetropolis[ energy , initial position , inverse temperature , {m, n} ] takes a metropolis energy and executes m steps using the Metropolis algorithm, throwing away positions, then n steps recording positions.";


MechanismIsometricTrajectory::usage=
"MechanismIsometricTrajectory[\!\(\*
StyleBox[\"Mechanism\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]x1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]y1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] creates a trajectory using \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) steps through the configuration space of a Mechanism starting in the
displacement direction \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]x1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]y1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\).";

MechanismFindMinimalTrajectory::usage=
"MechanismFindMinimalTrajectory[\!\(\*
StyleBox[\"Mechanism\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"start\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"end\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] attempts to find a valid trajectory from \!\(\*
StyleBox[\"start\",\nFontSlant->\"Italic\"]\) to \!\(\*
StyleBox[\"end\",\nFontSlant->\"Italic\"]\) configurations using \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) intermediate steps.";

GenericGloballyRigidQ::usage=
"GenericGloballyRigidQ[m] returns True if it can be determined that the system is generically globally rigid according to Connelly's criteria based on the stress matrix.
If it returns True, the specific Mechanism may still be non-rigid.";


PrestressStability::usage="PrestressStability[m] returns {t, most unstable self stress} where t is the smallest stress matrix eigenvalue, so t < 0 if the mechanism is prestress stable.";
PrestressStableQ::usage="PrestressStableQ[m] attempts to determine if a mechanism is prestress stable.";


Begin["`Private`"];

Needs["Mechanisms`"];
Needs["Mechanisms`geometry`"];


(*Certain cell types can have specially named things*)
dataParsingRules[ Spring , "Strain"] := Dispatch[{"LinearStrain" -> ((#1-#2)/#2 &)}]


(*combinations of data that count as "constraints"*)
$constrainedCellData = Flatten[{
	Thread[{"Stiffness", "TorsionalStiffness", "PinningStiffness", "FaceStiffness","YoungsModulus", "AngleStiffness"}->Infinity]
	}];


(* how to interpret Automatic for different kinds of cells

automaticCellData[ mechanism , positions , cell[indices] , data ] returns the values that Automatic represents in cells of a particular data type.
*)
automaticCellData[ m_, positions_, RigidBar[indices_] , "EquilibriumLength" ] := DisplacementLength[positions , indices]
automaticCellData[ m_, positions_ , Spring[indices_] , "EquilibriumLength" ] := DisplacementLength[positions , indices]
automaticCellData[ m_, positions_ , TorsionalFold[indices_], "Angle" ] :=  TorsionalFoldAngle[m, positions, indices ]
automaticCellData[ m_, positions_ , AngleJoint[indices_], "Angle" ] :=  TurningAngle[m, positions, indices ]
automaticCellData[ m_, positions_, PinnedJoint[indices_], "ConstraintFunction"] := ConstantArray[(#1-#2 &), Length[indices]]
automaticCellData[ m_, positions_, StraightJoint[ indices_ ] , "Distance"] := DisplacementLength[positions, indices[[All,{1,2}]]]/DisplacementLength[positions, indices[[All,{1,3}]]]
																			(*how far along the distance between 1 and 3 is vertex 2*)


(*
cellConstraints[mechanism , positions , arbitrary positions, cell[indices] -> data ]
	returns the constraints associated with a particular cell evaluated at positions.

	cell[indices] -> data is the output of cellData[]
*)
cellConstraints[ m_, positions_, arbitraryPositions_, Rule[RigidBar[indices_], data_] ]:=
	DisplacementLengthSquared[ arbitraryPositions, indices ] - data["EquilibriumLength"]^2

cellConstraints[ m_, positions_, arbitraryPositions_, Rule[ElasticTriangle[indices_], data_] ]:=
With[{
	edges = DeleteDuplicatesBy[Flatten[Partition[indices,{1,2},1,1],2],Sort ]
},
	DisplacementLengthSquared[ arbitraryPositions, edges ] - DisplacementLengthSquared[ positions, edges ]
]

cellConstraints[ m_, positions_, arbitraryPositions_, Rule[Face[indices_], data_] ] :=
Module[{
	partitionedIndices = Select[ Partition[#, 3,1,1]& /@ indices, Length[#]>3& ]
},
	faceStiffnessFunction[NormalVector[ arbitraryPositions , # ]]& /@ partitionedIndices
]
faceStiffnessFunction[{x_,y__}]:= Map[Dot[x , #] - 1 & , {y}]

cellConstraints[ m_, positions_, arbitraryPositions_, Rule[Spring[indices_], data_] ] :=
	MapThread[ #1[#2,#3]&, { data["Strain"], DisplacementLength[ arbitraryPositions, indices ], data["EquilibriumLength"] } ]

cellConstraints[ m_, positions_, arbitraryPositions_, Rule[AngleJoint[indices_], data_] ] :=
	TurningAngle[arbitraryPositions, indices]-data["Angle"]

cellConstraints[ m_, positions_ , arbitraryPositions_, Rule[ StraightJoint[indices_], data_ ] ] :=
	With[{
		displacements = arbitraryPositions[[ indices[[All,3]] ]] - arbitraryPositions[[ indices[[All,1]]]],
		start = arbitraryPositions[[ indices[[All,1]]]],
		me = arbitraryPositions[[ indices[[All,2]] ]]
	},
		me - start - data["Distance"] displacements (*put vertex `me` a fraction of the way between the two end points*)
	]

cellConstraints[ m_, positions_, arbitraryPositions_, Rule[TorsionalFold[indices_], data_ ] ] :=
	TorsionalFoldAngle[ m, arbitraryPositions, indices ] - data["Angle"]

cellConstraints[ m_, positions_, arbitraryPositions_, Rule[PinnedJoint[indices_], data_ ] ] :=
	MapThread[ #1[#2,#3]&, { data["ConstraintFunction"], VertexPosition[ indices, All[ m["EmbeddingDimension"] ] ], positions[[ indices ]] } ]

cellConstraints[ ___ ] := {}


$DefaultMechanismStiffnesses["Methods"]={RigidBar, Spring, TorsionalFold, FreeJoint, Face, AngleJoint};
$DefaultMechanismStiffnesses[RigidBar]=1;
$DefaultMechanismStiffnesses[Spring]=1;
$DefaultMechanismStiffnesses[TorsionalFold]=10^(-4);
$DefaultMechanismStiffnesses[ElasticTriangle] = 1;
$DefaultMechanismStiffnesses[Face] = 1;
$DefaultMechanismStiffnesses[PinnedJoint]=10^(-4);
$DefaultMechanismStiffnesses[AngleJoint]=10^(-4);
$DefaultMechanismStiffnesses[StraightJoint]=10^(-1);


MechanismEnergy::EdgeLength="Warning: Edges `1` with length smaller than `2` have had their strains clipped.";

cellEnergy[m_, positions_, arbitraryPositions_, Rule[RigidBar[indices_],data_]] :=
With[{
	(*this puts a lower bound on the smallest length we use to divide the strain by*)
	smallestLengths = Clip[ data["EquilibriumLength"]^2, {$DefaultMechanismStiffnesses["SmallestLength"]^2, Infinity} ],
	(*this is to put out a warning in case some are short.*)
	shortEdges=Pick[ indices , (# < $DefaultMechanismStiffnesses["SmallestLength"])& /@ data["EquilibriumLength"]]
},
	If[Length[shortEdges]>0, Message[MechanismEnergy::EdgeLength, shortEdges, $DefaultMechanismStiffnesses["SmallestStiffness"] ] ];

	(*
		stiffness * ((l^2 - l0^2)/l0^2)^2/8 when equilibrium length l0 is longer than shortest length
		
		this has the property that subdivided edges have the same energy as their original edge length
	*)
	( data["Stiffness"] /. Infinity -> $DefaultMechanismStiffnesses[RigidBar] ) ( 
		(DisplacementLengthSquared[arbitraryPositions, indices ] - data["EquilibriumLength"]^2)/smallestLengths
	)^2/8
]

cellEnergy[m_, positions_, arbitraryPositions_, Rule[Spring[indices_],data_]] :=
With[{
	stiffness = data["Stiffness"] /. Infinity -> $DefaultMechanismStiffnesses[Spring]
},
	stiffness MapThread[ #1[#2,#3]^2&, { data["Strain"], DisplacementLength[arbitraryPositions, indices ], data["EquilibriumLength"] } ]
]

cellEnergy[m_, positions_, arbitraryPositions_, Rule[TorsionalFold[indices_], data_]] :=
With[{
	stiffness = data["TorsionalStiffness"] /. Infinity -> $DefaultMechanismStiffnesses[TorsionalFold]
},
	stiffness (TorsionalFoldAngle[m,arbitraryPositions, indices ] - data["Angle"])^2/2
]

cellEnergy[m_,positions_,arbitraryPositions_, Rule[Face[indices_],data_]]:=0 /; Length[arbitraryPositions[[1]]] < 3
cellEnergy[m_, positions_, arbitraryPositions_, Rule[Face[indices_], data_]] :=
Module[{
	partitionedIndices = Partition[#, 3,1,1]& /@ indices,
	stiffness = data["FaceStiffness"] /. Infinity -> $DefaultMechanismStiffness[Face],
	selector
},
	selector = # > 0& /@ stiffness; (*selects faces that have a stiffness that isn't 0*)
	MapThread[#1 faceEnergyFunction[NormalVector[arbitraryPositions, #2]]& , {Pick[stiffness, selector], Pick[partitionedIndices, selector]}]
] 
faceEnergyFunction[stiffness_ , {x_,y__}]:= 0 /; Length[{y}]<= 2
faceEnergyFunction[stiffness_ , {x_,y__}]:= Total[Map[(Dot[x , #] - 1)^2 & , {y}]]

cellEnergy[m_, positions_, arbitraryPositions_, Rule[ElasticTriangle[indices_], data_]] :=
With[{
	stiffness = data["YoungsModulus"] /. Infinity -> $DefaultMechanismStiffnesses[ElasticTriangle],
	poissonratio = data["PoissonRatio"]
},
	MapThread[
		elasticFaceEnergy[ #1, #2, positions[[ #3 ]], arbitraryPositions[[ #3 ]] ]&,
		{stiffness, poissonratio, indices}
	]
]

cellEnergy[m_, positions_, arbitraryPositions_, Rule[AngleJoint[indices_], data_]] :=
With[{
	stiffness = data["AngleStiffness"] /. Infinity -> $DefaultMechanismStiffnesses[AngleJoint]
},
	stiffness (TurningAngle[m,arbitraryPositions, indices ] - data["Angle"])^2/2
]

cellEnergy[m_, positions_, arbitraryPositions_, Rule[StraightJoint[indices_], data_]] :=
With[{
	stiffness = data["AngleStiffness"] /. Infinity -> $DefaultMechanismStiffnesses[StraightJoint]
},
	With[{
		displacements = arbitraryPositions[[ indices[[All,3]] ]] - arbitraryPositions[[ indices[[All,1]]]],
		start = arbitraryPositions[[ indices[[All,1]]]],
		me = arbitraryPositions[[ indices[[All,2]] ]]
	},
		stiffness (start + data["Distance"] displacements - me (*put vertex `me` a fraction of the way between the two end points*))^2/2
	]
]

cellEnergy[m_, positions_, arbitraryPositions_, Rule[PinnedJoint[indices_], data_]] :=
With[{
	stiffness = data["PinningStiffness"] /. Infinity -> $DefaultMechanismStiffnesses[TorsionalFold]
},
	stiffness MapThread[ #1[#2,#3]^2/2& , { data["ConstraintFunction"], arbitraryPositions[[ indices ]], positions[[ indices ]] } ]
]

cellEnergy[m_,_,_,_] := {0}


elasticFaceEnergy[Y_,\[Nu]_,{{x1_,y1_,z1_},{x2_,y2_,z2_},{x3_,y3_,z3_}},{{X1_,Y1_,Z1_},{X2_,Y2_,Z2_},{X3_,Y3_,Z3_}}] := 
1/(2 (1+\[Nu])) Y ((Sqrt[(-x1+x2)^2+(-y1+y2)^2+(-z1+z2)^2]-Sqrt[(-X1+X2)^2+(-Y1+Y2)^2+(-Z1+Z2)^2])^2/((-x1+x2)^2+(-y1+y2)^2+(-z1+z2)^2)+(Sqrt[1-(x1^2+x2 x3-x1 (x2+x3)+(y1-y2) (y1-y3)+(z1-z2) (z1-z3))^2/(((x1-x2)^2+(y1-y2)^2+(z1-z2)^2) ((x1-x3)^2+(y1-y3)^2+(z1-z3)^2))] Sqrt[(-x1+x3)^2+(-y1+y3)^2+(-z1+z3)^2]-Sqrt[1-(X1^2+X2 X3-X1 (X2+X3)+(Y1-Y2) (Y1-Y3)+(Z1-Z2) (Z1-Z3))^2/(((X1-X2)^2+(Y1-Y2)^2+(Z1-Z2)^2) ((X1-X3)^2+(Y1-Y3)^2+(Z1-Z3)^2))] Sqrt[(-X1+X3)^2+(-Y1+Y3)^2+(-Z1+Z3)^2])^2/((1-(x1^2+x2 x3-x1 (x2+x3)+(y1-y2) (y1-y3)+(z1-z2) (z1-z3))^2/(((x1-x2)^2+(y1-y2)^2+(z1-z2)^2) ((x1-x3)^2+(y1-y3)^2+(z1-z3)^2))) ((-x1+x3)^2+(-y1+y3)^2+(-z1+z3)^2))+((Sqrt[(-X1+X2)^2+(-Y1+Y2)^2+(-Z1+Z2)^2] (x1^2+x2 x3-x1 (x2+x3)+(y1-y2) (y1-y3)+(z1-z2) (z1-z3)) Sqrt[(-x1+x3)^2+(-y1+y3)^2+(-z1+z3)^2])/(Sqrt[((x1-x2)^2+(y1-y2)^2+(z1-z2)^2) ((x1-x3)^2+(y1-y3)^2+(z1-z3)^2)])-(Sqrt[(-x1+x2)^2+(-y1+y2)^2+(-z1+z2)^2] (X1^2+X2 X3-X1 (X2+X3)+(Y1-Y2) (Y1-Y3)+(Z1-Z2) (Z1-Z3)) Sqrt[(-X1+X3)^2+(-Y1+Y3)^2+(-Z1+Z3)^2])/(Sqrt[((X1-X2)^2+(Y1-Y2)^2+(Z1-Z2)^2) ((X1-X3)^2+(Y1-Y3)^2+(Z1-Z3)^2)]))^2/(4 ((-x1+x2)^2+(-y1+y2)^2+(-z1+z2)^2) (1-(x1^2+x2 x3-x1 (x2+x3)+(y1-y2) (y1-y3)+(z1-z2) (z1-z3))^2/(((x1-x2)^2+(y1-y2)^2+(z1-z2)^2) ((x1-x3)^2+(y1-y3)^2+(z1-z3)^2))) ((-x1+x3)^2+(-y1+y3)^2+(-z1+z3)^2)))+1/(2 (1-2 \[Nu]) (1+\[Nu])) Y (-((Sqrt[(-x1+x2)^2+(-y1+y2)^2+(-z1+z2)^2]-Sqrt[(-X1+X2)^2+(-Y1+Y2)^2+(-Z1+Z2)^2])/Sqrt[(-x1+x2)^2+(-y1+y2)^2+(-z1+z2)^2])-(Sqrt[1-(x1^2+x2 x3-x1 (x2+x3)+(y1-y2) (y1-y3)+(z1-z2) (z1-z3))^2/(((x1-x2)^2+(y1-y2)^2+(z1-z2)^2) ((x1-x3)^2+(y1-y3)^2+(z1-z3)^2))] Sqrt[(-x1+x3)^2+(-y1+y3)^2+(-z1+z3)^2]-Sqrt[1-(X1^2+X2 X3-X1 (X2+X3)+(Y1-Y2) (Y1-Y3)+(Z1-Z2) (Z1-Z3))^2/(((X1-X2)^2+(Y1-Y2)^2+(Z1-Z2)^2) ((X1-X3)^2+(Y1-Y3)^2+(Z1-Z3)^2))] Sqrt[(-X1+X3)^2+(-Y1+Y3)^2+(-Z1+Z3)^2])/(Sqrt[1-(x1^2+x2 x3-x1 (x2+x3)+(y1-y2) (y1-y3)+(z1-z2) (z1-z3))^2/(((x1-x2)^2+(y1-y2)^2+(z1-z2)^2) ((x1-x3)^2+(y1-y3)^2+(z1-z3)^2))] Sqrt[(-x1+x3)^2+(-y1+y3)^2+(-z1+z3)^2]))^2 \[Nu]


(*
does an expression evaluate to a real number if the vertex positions or displacements are set?
*)
numericExpressionQ[positions_, expression_]:=
With[{reducedExpression = (# . #&)[ Flatten[{expression /. Dispatch@PositionRules[ N[positions] ] /. VertexDisplacement[_,_]->0.001} ] ]},
	NumericQ[reducedExpression] && Chop[Im[reducedExpression]]==0
]


(*
constraintVector[ arbitrary positions, constraints ] takes arbitrary constraints, written as equations or in some other form,
parses them, and returns a standard vector map from positions to a "constraint space".
*)

equationToExpressionParser[positions_] := {
	None -> Nothing,
	a_And:>List@@a,
	Equal[a_,b_]:>a-b,
	Equal[a_,b__]:>ConstantArray[a,Length[{b}]]-{b},
	a_?PeriodicIdentificationDataQ :> a["Constraints"],
	EuclideanMotionConstraints[a_] :> EuclideanMotionConstraints[positions,a],
	PeriodicIdentification[ a_ ] :> PeriodicIdentification[positions,a]["Constraints"]
}

(*get a set of user-specified constraints into the form of a vector equal to zero when constraints are satisfied*)
constraintVector[positions_, None]:={}
constraintVector[positions_, constraints_]:=With[
{
equations=Flatten[{constraints} //. equationToExpressionParser[positions]],
dimensions=Dimensions[positions]
},
	equations /. Dispatch[DisplacementRules[ VertexPosition[ Range[dimensions[[1]]],All[dimensions[[2]]] ] - positions]]
]


(*
reduceConstraintToOrder[ actual positions, constraintMap, order ] changes the order of the constraint map produced by constraintVector[].
*)

(*express the constraints to be valid at a certain order*)
reduceConstraintToOrder[actualpositions_,constraintVector_,order_Integer?Positive]:=
Module[
{
dimensions=Dimensions[actualpositions],
expandedExpression,x
},
	expandedExpression = constraintVector /. Dispatch[ PositionRules[ actualpositions + x VertexDisplacement[Range[dimensions[[1]]], All[dimensions[[2]]]]]];
	Total[ D[expandedExpression,{x,#}]/Factorial[#]& /@ Range[0,order] /. x->0]
]
reduceConstraintToOrder[actualpositions_, constraintVector_, Infinity] :=
With[
{
dimensions=Dimensions[actualpositions]
},
	constraintVector /. Dispatch[ PositionRules[ actualpositions + VertexDisplacement[Range[dimensions[[1]]], All[dimensions[[2]]]]]]
]

reduceConstraintToOrder[actualpositions_,constraintVector_,_] := constraintVector /. Dispatch[PositionRules[ actualpositions ]]


(*
solveLinearEquations[constraint map , variables ] solves the linear constraints from constraint map explicitly.
*)

(*Fastest way to pull out equations that are definitely linear and can be solved explicitly*)
linearEquationQ[eq_,var_]:=VectorQ[D[eq,{var}],NumericQ]

(*given a set constraints, select out the linear ones and solve them.*)
solveLinearEquations[constraintVec_, var_] := Module[ {soln},
	Quiet[ soln = Solve[ Select[ constraintVec, linearEquationQ[#, var]& ] == 0, var ] ];
	If[ Head[soln] =!= Solve, soln[[1]], {} ]
]


(*
	processConstraintEquations[ arbitrary positions, constraint map ] decomposes a constraint vector in these parts:
		"additional variables" -> a list of additional variables that aren't specified that might muck things up for some functions,
		"linear solutions" -> { rules that solve any simple linear constraints },
		"constrained positions" -> positions that satisfy the linear constraints,
		"nonlinear constraints" -> any nonlinear constraints that remain after removing linear constraints,
		"inequalities" -> any inequalities that are left over after removing linear constraints
*)
processConstraintEquations[arbitraryPositions_, constraintEq_] := 
Module[
{
	constraints = constraintVector[ arbitraryPositions, constraintEq ],
	vars = Flatten @ Array[ VertexPosition, Dimensions[arbitraryPositions] ],
	equalityConstraints,
	linearEquationSelector,
	solvedLinearConstraints, processedSolvedLinearConstraints,
	constrainedPositions,
	inequalities, inequalitySelector
},
	inequalitySelector = MatchQ[Head[#],Less|Greater|LessEqual|GreaterEqual|Inequality]& /@ constraints;
	inequalities = Pick[constraints , inequalitySelector ];
	equalityConstraints = Pick[constraints, inequalitySelector, False ];
	(*find and solve the linear equations*)
	linearEquationSelector = linearEquationQ[#, vars]& /@ equalityConstraints;

	solvedLinearConstraints = Quiet[ 
		Solve[ Pick[ equalityConstraints, linearEquationSelector ] == 0, vars ]
	];

	If[Length[solvedLinearConstraints] == 0, Message[MechanismLinearConstraints::const,  Thread[Pick[ equalityConstraints, linearEquationSelector ]==0] ]];

	If[Head[solvedLinearConstraints] === Solve || Length[solvedLinearConstraints]==0,
		(*no solutions exist or could be found*)
		Association[
			"additional variables" -> Sort @ DeleteDuplicates @ DeleteCases[ Cases[equalityConstraints, _Symbol|_Symbol[_], Infinity], _VertexPosition|_VertexDisplacement ],
			"linear solutions"->{}, 
			"constrained positions" -> (constrainedPositions = Array[VertexPosition, Dimensions[arbitraryPositions] ]),
			"variables" -> Flatten[ constrainedPositions ],
			"nonlinear constraints" -> Pick[ equalityConstraints , Not /@ PossibleZeroQ /@ equalityConstraints ],
			"inequalities" -> inequalities
		],
	
		(*some solutions were found*)
		Association[
		(*make note of any variables that are not position or displacement variables*)
		"additional variables" -> Sort @ DeleteDuplicates @ DeleteCases[ Cases[equalityConstraints, _Symbol|_Symbol[_], Infinity], _VertexPosition|_VertexDisplacement ],
		
		(*rules that solve the linear constraints*)
		"linear solutions" -> First[solvedLinearConstraints],

		(*positions with linear solutions applied*)
		"constrained positions" -> ( constrainedPositions = Array[VertexPosition, Dimensions[arbitraryPositions]] /. Dispatch[First[solvedLinearConstraints]] ),

		(*any unfixed vertex position variables*)
		"variables" -> DeleteDuplicates[ Cases[ constrainedPositions , _VertexPosition , Infinity] ],

		(*remaining nontrivial, nonlinear constraints with linear solutions applied*)
		"nonlinear constraints" -> Select[ Pick[ equalityConstraints , linearEquationSelector, False ] /. First[solvedLinearConstraints] , Not[PossibleZeroQ[#]]& ],
		
		"inequalities" -> inequalities /. First[solvedLinearConstraints]
		]
	]
]

MechanismLinearConstraints::const="Linear constraints `1` cannot be solved.";


(*fill in the defaults*)
automaticCellData[ m_, positions_, _, _] := None
dataParsingRules[ _ , _ ] := {}


(*
cellData[m , positions, cell specification, data selector]

returns a list of mechanism cells that match a certain cell specification and whose data matches the pattern in data selector.
Any Automatic entries are replaced with their actual values based on the positions provided.

e.g. cellData[m, positions, _RigidBar, "Stiffness"->Infinity] will return only RigidBar cells with infinite stiffness.
*)
cellData[ m_, positions_, cellSpec_ , data_ : None ] := 
Module[{
	cells = Mechanisms`Private`mechanismCellList["Unthreaded", m, cellSpec, data, _],
	activeCells, inactiveCells
},
	If[ Head[cells] =!= List,
		{},
	
		activeCells = Cases[cells,_Rule];
		inactiveCells = DeleteCases[cells,_Rule];
	
		replaceAutomaticEntries[m, positions, #[[1]], #[[2]]]& /@ activeCells
	]
]


(*
replaceAutomaticEntries[  mechanism , positions, cell , dataRules ]
*)
replaceAutomaticEntries[ m_, positions_, cell_ , dataRules_ ] :=
	cell -> Association @@ (Map[ replaceAutomaticEntriesWithinData[ m, positions, cell , # ]& , dataRules ])

replaceAutomaticEntriesWithinData[ m_, positions_, head_[indices_] , dataType_ -> entries_ ] := 
Module[ { automaticCells, newData, newEntries = entries /. dataParsingRules[head , dataType] },
	automaticCells = Position[ newEntries, Automatic , 1];
	newData = automaticCellData[ m, positions ,head[ Extract[indices, automaticCells] ] , dataType ];
	
	If[ ListQ[newData] , dataType -> ReplacePart[ newEntries , Thread[Flatten[automaticCells] -> newData ] ] , dataType -> newEntries ]
]


(*
constraintEquations[ m, positions, pattern, additional constraints] 
	computes a set of constraint equations (based on mechanism m with vertices at position) for any
	constrained cells that match pattern. It removes cells that are elastic.
*)
constraintEquations[ m_ , positions_ , pattern_ , constraints_] :=
With[{
	(*get cell data based on the mechanism*)
	data = cellData[m, positions, pattern, $constrainedCellData],
	arbitraryPositions = VertexPosition[m],
	addedConstraints = OptionValue[m, Constraints]
},
	Mechanisms`geometry`Private`MechanismGeometricExpression[ PlaceVertices[m, positions] ,
		Flatten[{
			cellConstraints[m ,  positions, arbitraryPositions , #]& /@ data,
			(*add in additional specified constraints*)
			constraintVector[ positions, Flatten[{addedConstraints, constraints}] ]
		}]
	]
]


(*returns a set of unique standard variable names for functions that need them*)
standardVariableNames[ m_ ] :=
Module[{n,c, beginning = Unique["m"]},
	{
	VertexPosition[m] /. VertexPosition[n_,c_] :> ToExpression[ToString[beginning] <> "$" <> c <> ToString[n]],
	VertexPosition[m] /. VertexPosition[n_,c_] :> ToExpression[ToString[beginning] <> "$p" <> c <> ToString[n]]
	}
]


(*
renameVertexVariables[]

use the list of variables in variableName to rename VertexPosition's in expression
*)
renameVertexVariables[ variableName_?MatrixQ , expression_] := 
	Module[{v,n,c}, 
		expression /. VertexPosition[n_,c_] :> v[n,c] /. {"x"->1,"y"->2,"z"->3} /. v[n_,c_] :> variableName[[n, c ]]
	] /; largestVertexPositionQ[ expression ,  Dimensions[variableName] ]
renameVertexVariables[ variableName_ , _ ] := $Failed


largestVertexPosition[ expression_ ] := 
With[{ positionVariables = Cases[ expression, _VertexPosition, Infinity]},
{
	Max[ positionVariables[[All,1]] ],
	Max[ positionVariables[[All,2]] /. {"x"->1, "y"->2, "z"->3} ]
}]


largestVertexPositionQ[ expression_ , {numberVertices_, dimension_}] :=
With[ {
	d=largestVertexPosition[expression]},
		TrueQ[ And[ d[[1]] <= numberVertices, d[[2]] <= dimension] ]
	]


(*Build a periodic Voronoi mesh by tiling the vertices and extracting only the cells associated with the original vertices.*)
Options[RandomCellNetwork] = DeleteDuplicatesBy[ Join[
		{ Line -> Spring , Polygon -> None },
		Options[ToLinkage] ], 
	First ];

RandomCellNetwork[ numPoints_Integer?Positive, opt : OptionsPattern[] ] := RandomCellNetwork[ numPoints, 2, opt ]

RandomCellNetwork[numPoints_Integer?Positive, 2, opt : OptionsPattern[]]:=
Module[ {randomPoints , expandedCells , regionTesters, cells , i, j,
	actualOptions = Join[{
		Line->OptionValue[Line],
		Polygon->OptionValue[Polygon]
	}, {opt} ]},
	randomPoints = RandomReal[{-1/2,1/2},{numPoints,2}];
	expandedCells = MeshPrimitives[
		VoronoiMesh[
			Flatten[Table[randomPoints + ConstantArray[{i,j}, numPoints],{i,-1,1},{j,-1,1}],2]
		],
	2];

	ToLinkage[ Select[expandedCells,Or @@ RegionMember[#, randomPoints]&] , actualOptions ]
]

RandomCellNetwork[numPoints_Integer?Positive, 3, opt : OptionsPattern[]]:=
Module[ {randomPoints , expandedCells , regionTesters, cells , i, j, k,
	actualOptions = Join[{
		Line->OptionValue[Line],
		Polygon->OptionValue[Polygon]
	}, {opt} ]},
	randomPoints = RandomReal[{-1/2,1/2},{numPoints,3}];
	expandedCells = MeshPrimitives[
		VoronoiMesh[
			Flatten[Table[randomPoints + ConstantArray[{i,j,k}, numPoints],{i,-1,1},{j,-1,1},{k,-1,1}],3]
		],
	3];

	regionTesters = RegionMember /@ expandedCells;
	ToLinkage[ Pick[expandedCells,(Or@@(#/@randomPoints)&) /@ regionTesters] , actualOptions ]
]

RandomCellNetwork[numPoints : Except[_Integer?Positive], OptionsPattern[] ]:="nothing" /; Message[RandomCellNetwork::num, numPoints]
RandomCellNetwork[numPoints : Except[_Integer?Positive], _, OptionsPattern[] ]:="nothing" /; Message[RandomCellNetwork::num, numPoints]
RandomCellNetwork[numPoints_, d : Except[2|3] , OptionsPattern[] ]:="nothing" /; Message[RandomCellNetwork::dim, d]

RandomCellNetwork::dim="Dimension `1` should be either 2 or 3.";
RandomCellNetwork::num="Number of points `1` should be a positive integer.";


(*Build a periodic Voronoi mesh by tiling the vertices and extracting only the cells associated with the original vertices.*)
Options[RandomTriangulatedNetwork]:=DeleteDuplicatesBy[ Join[{ Line -> Spring , Polygon -> None }, Options[ToLinkage] ], First ];

RandomTriangulatedNetwork[ numPoints_Integer?Positive, opt : OptionsPattern[] ] := RandomTriangulatedNetwork[ numPoints, 2, opt ]

RandomTriangulatedNetwork[numPoints_Integer?Positive, 2, opt : OptionsPattern[]]:=
Module[ {randomPoints , expandedCells , regionTesters, cells , i, j,
	actualOptions = Join[{
		Line->OptionValue[Line],
		Polygon->OptionValue[Polygon]
	}, {opt} ]},
	randomPoints = RandomReal[{-1/2,1/2},{numPoints,2}];
	expandedCells = MeshPrimitives[
		DelaunayMesh[
			Flatten[Table[randomPoints + ConstantArray[{i,j}, numPoints],{i,-1,1},{j,-1,1}],2]
		],
	2];

	ToLinkage[ Select[expandedCells,Or @@ RegionMember[#, randomPoints]&] , actualOptions ]
]

RandomTriangulatedNetwork[numPoints_Integer?Positive, 3, opt : OptionsPattern[]]:=
Module[ {randomPoints , expandedCells , regionTesters, cells , i, j, k,
	actualOptions = Join[{
		Line->OptionValue[Line],
		Polygon->OptionValue[Polygon]
	}, {opt} ]},
	randomPoints = RandomReal[{-1/2,1/2},{numPoints,3}];
	expandedCells = MeshPrimitives[
		DelaunayMesh[
			Flatten[Table[randomPoints + ConstantArray[{i,j,k}, numPoints],{i,-1,1},{j,-1,1},{k,-1,1}],3]
		],
	3];

	regionTesters = RegionMember /@ expandedCells;
	ToLinkage[ Pick[expandedCells,(Or@@(#/@randomPoints)&) /@ regionTesters] , actualOptions ]
]

RandomTriangulatedNetwork[numPoints : Except[_Integer?Positive], OptionsPattern[] ]:="nothing" /; Message[RandomTriangulatedNetwork::num, numPoints]
RandomTriangulatedNetwork[numPoints : Except[_Integer?Positive], _, OptionsPattern[] ]:="nothing" /; Message[RandomTriangulatedNetwork::num, numPoints]
RandomTriangulatedNetwork[numPoints_, d : Except[2|3] , OptionsPattern[] ]:="nothing" /; Message[RandomTriangulatedNetwork::dim, d]

RandomTriangulatedNetwork::dim="Dimension `1` should be either 2 or 3.";
RandomTriangulatedNetwork::num="Number of points `1` should be a positive integer.";


(*In d dimensions, a type 1 Henneberg move adds a free vertex and joins it to d other vertices.*)
Henneberg[1][n_?VectorQ, label_ -> pos_?VectorQ][ m_?MechanismQ ] :=
	AddCells[ {FreeJoint[label -> PadRight[pos, MechanismEmbeddingDimension[m]] ], RigidBar[{#,label}]& /@ n } ][m]

Henneberg[1][pos_?VectorQ][ m_?MechanismQ ] :=
	With[{ vertices = RandomSample[ Range[ m["VertexCount"] ], 2 ] },
		Henneberg[1][vertices, Unique[] -> pos ][m]
	]


(*A type 2 Henneberg move subdivides an edge, adds a vertex, and joins the new vertex to the subdivided edge and two other vertices.*)
Henneberg[2][{n1_, n2_,n3_}, label_ -> pos_][ m_?MechanismQ ] :=
	PlaceVertices[label -> pos] @ AddCells[{RigidBar[{label, n3}]}] @ SubdivideCells[ {n1,n2}, label ][ m ]

Henneberg[2][pos_?VectorQ][ m_?MechanismQ ] :=
	With[{ edge = RandomChoice[ m["edges"] ] },
		Henneberg[2][Flatten[ { edge, RandomChoice[ Complement[ Range[ m["VertexCount"] ], edge] ] } ], Unique[] -> pos ][m]
	]

Henneberg[d:1|2][m_?MechanismQ, x__ ] := Henneberg[d][x][m]


(*take any nontriangular face and add two vertices on either side and connect it up to prevent the face from bending.*)
faceToBlock[ thickness_, label_, centroid_ , normal_ , indices_ ] := 
{
	FreeJoint[ label[1] -> (centroid + thickness normal) , {"Shape"->None,"BlockJoint"}],
	FreeJoint[ label[2] -> (centroid - thickness normal) , {"Shape"->None,"BlockJoint"}],
	RigidBar[ {#, label[1]} , {"Shape" -> None, "BlockEdge"} ]& /@ indices,
	RigidBar[ {#, label[2]} , {"Shape" -> None, "BlockEdge"} ]& /@ indices
}

BlockFaces[thickness : _?NumericQ : 1/10][ m_?MechanismQ ] := With[ { faces = Select[MechanismFaces[m],Length[#]>3&] }, BlockFaces[ faces, thickness ][m] ]
BlockFaces[ faces_List , thickness : _?NumericQ : 1/10 ][ m_?MechanismQ ] := With[
{
	normals = NormalVector[ m , faces , "Normalize" -> False],
	centroids = Mean[m[[1,#]]]& /@ faces,
	labels = Unique[] /@ Range[Length[faces]]
},
	AddCells[ MapThread[ faceToBlock[ thickness, #1, #2, #3, #4 ]&, { labels, centroids, normals, faces } ] ][m]
]
BlockFaces[ m_?MechanismQ, other___ ] := BlockFaces[ other ][m]


changecelldata[ m_, head_[ indices_ ] -> data_ ] := 
	Fold[ChangeCellData[ head[ indices ], #2]@ #1 &, m, DeleteCases[ Normal@data, "Shape"|"Style"|"Label" -> _] ]

Options[FixMechanism] = { CellPattern -> _ };
FixMechanism[ m_?MechanismQ , OptionsPattern[] ] := 
	Fold[ changecelldata , m, cellData[ m, m["VertexCoordinates"],  OptionValue[CellPattern] ] ]


randomDisplacements[ mask_ , distribution_ , precision_ , numberOfDisplacements_ ] :=
With[{ 
	randomNumbers = RandomVariate[ distribution, Join[{numberOfDisplacements}, Dimensions[mask]], WorkingPrecision -> precision ]
},
	MapThread[ If[NumericQ[#1], #1, #2]& , {ConstantArray[ mask, numberOfDisplacements ], randomNumbers}, 3 ] /; Head[randomNumbers] =!= RandomVariate
]


Options[RandomDisplacements] = { 
	Constraints -> None , 
	Distribution -> NormalDistribution[0, 1/10] , 
	ReduceLinearConstraints -> True, 
	WorkingPrecision -> MachinePrecision
};

RandomDisplacements[ m_?MechanismQ , number : Except[_Rule] : 1,  opt : OptionsPattern[] ] :=
With[ {
	linearConstraints = If[ OptionValue[ReduceLinearConstraints], MechanismLinearConstraints[ m , Constraints -> OptionValue[Constraints] ] , {} ]
},
	With[{res = randomDisplacements[
		(VertexPosition[m] /. linearConstraints) - m["VertexCoordinates"] ,
		OptionValue[Distribution],
		OptionValue[WorkingPrecision],
		number
	 ]},
		ToPackedArray[ If[ number == 1, res[[1]] , res ] ]  /; Head[res] =!= randomDisplacements && Head[linearConstraints] === List 
	 ]
] /; randomdisplacementArgumentsQ[ m , number , OptionValue[WorkingPrecision] , OptionValue[ReduceLinearConstraints] ]

randomdisplacementArgumentsQ[ m_ , number_ , workingprecision_ , reduce_] := 
	Which[
		Not[IntegerQ[number]] || number < 0, Message[RandomDisplacements::n, number]; False,
		workingprecision =!= MachinePrecision && Not[ TrueQ[workingprecision > 0 ]], Message[RandomDisplacements::prec, workingprecision]; False,
		Not[BooleanQ[reduce]], Message[RandomDisplacements::red]; False,
		True, True
	]

RandomDisplacements::red = "ReduceLinearConstraints must be a Boolean.";
RandomDisplacements::n = "Number of random displacements `1` must be a positive integer.";
RandomDisplacements::prec = "Working precision `1` should be a positive number of digits of precision.";


Options[RandomPositions] = { Constraints -> None , Distribution -> NormalDistribution[0, 1/10] , ReduceLinearConstraints -> True, WorkingPrecision -> MachinePrecision};

RandomPositions[ m_?MechanismQ , number : Except[_Rule] : 1, opt : OptionsPattern[] ] :=
With[ {
	linearConstraints = If[ OptionValue[ReduceLinearConstraints], MechanismLinearConstraints[ m , Constraints -> OptionValue[Constraints] ] , {} ]
},
	With[ {res =  randomDisplacements[
		(VertexPosition[m] /. linearConstraints) - m["VertexCoordinates"] ,
		OptionValue[Distribution],
		OptionValue[WorkingPrecision],
		number
	 ] }, 
	 
		ToPackedArray[
			If[ number == 1, m["VertexCoordinates"] + res[[1]] , ConstantArray[m["VertexCoordinates"], number] + res ]
		] /; Head[res] =!= randomDisplacements && Head[linearConstraints] === List	 
	]
] /; randompositionArgumentsQ[ m , number , OptionValue[WorkingPrecision] , OptionValue[ReduceLinearConstraints]]

randompositionArgumentsQ[ m_ ,  number_ , workingprecision_ , reduce_] := 
	Which[
		Not[IntegerQ[number]] || number < 0, Message[RandomPositions::n, number]; False,
		workingprecision =!= MachinePrecision && Not[ TrueQ[workingprecision > 0 ]], Message[RandomPositions::prec, workingprecision]; False,
		Not[BooleanQ[reduce]], Message[RandomPositions::red]; False,
		True, True
	]

RandomPositions::red = "ReduceLinearConstraints must be a Boolean.";
RandomPositions::n = "Number of random positions `1` must be a positive integer.";
RandomPositions::prec = "Working precision `1` should be a positive number of digits of precision.";


(*randomDisplacementsInternal[ positions_, distribution_, precision_, {}, numDisplacements_ ] :=
Module[{
	numberOfVertices, dim, randomNumbers
},
	{numberOfVertices, dim } = Dimensions[positions];
	Check[
		RandomVariate[ distribution, {numDisplacements, numberOfVertices,dim}, WorkingPrecision \[Rule] precision ],

		$Failed
	]
]

randomDisplacementsInternal[ positions_, distribution_, precision_, rules_, numDisplacements_ ] :=
Module[
{
	numberOfVertices, dim, displacements, arbitraryDisplacements
},
	{numberOfVertices, dim } = Dimensions[positions];
	displacements = Array[VertexDisplacement[#1,#2]&, {numberOfVertices,dim}] //. rules;
	arbitraryDisplacements = Cases[ Flatten[displacements], _VertexDisplacement];
	
	Check[
		Array[(displacements /. Dispatch@Thread[arbitraryDisplacements->RandomVariate[
			distribution,
			Length[arbitraryDisplacements],
			WorkingPrecision\[Rule]precision
		]] &), numDisplacements ],

		$Failed
	]
]*)


(*Options[RandomDisplacements]={
	Distribution -> NormalDistribution[0,1/10],
	WorkingPrecision -> MachinePrecision,
	ConstraintRules \[Rule] {}
};

Options[RandomPositions]={
	Distribution -> NormalDistribution[0,1/10],
	WorkingPrecision -> MachinePrecision,
	ConstraintRules \[Rule] {}
};*)


(*processRules[ _, {} ] := {}
processRules[ RandomDisplacements, r_ ] := parseDisplacementRules[r,Message[RandomDisplacements::rules]]
processRules[ RandomPositions, r_ ] := parseDisplacementRules[r,Message[RandomPositions::rules]]

precisionQ[ _, p_?(NumericQ[#] && #>0&) ] := p
precisionQ[ RandomDisplacements, p_ ] := (Message[RandomDisplacements::precision, p]; $Failed)
precisionQ[ RandomPositions, p_ ] := (Message[RandomPositions::precision, p]; $Failed)

processNumber[ _, n_Integer?Positive ] := n
processNumber[ RandomDisplacements, n_] := (Message[RandomDisplacements::num]; $Failed)
processNumber[ RandomPositions, n_] := (Message[RandomPositions::num]; $Failed)

RandomDisplacements::rules="List of rules must be of the form {VertexDisplacements[_,_]->_, ..}";
RandomDisplacements::precision="Working precision should be a real, positive number.";
RandomDisplacements::num="Number of displacements must be a positive integer.";
RandomDisplacements::pos="First argument should be positions or a mechanism.";

RandomPositions::rules="List of rules must be of the form {VertexDisplacements[_,_]->_, ..}";
RandomPositions::precision="Working precision should be a real, positive number.";
RandomPositions::num="Number of displacements must be a positive integer.";
RandomPositions::pos="First argument should be positions or a mechanism.";*)


(*displacementParsingRules = {
	Rule[x : {__VertexDisplacement} , y : Except[_List]] :> Thread[x->y],
	Rule[x : {__VertexDisplacement} , y_List] /; Length[x]==Length[y] :> Thread[x->y],
	Rule[ x_?(MatrixQ[#,Head[#]===VertexDisplacement&]&), y_List ] /; Length[x]==Length[y] :> Thread[x->y],
	Rule[ x_?(MatrixQ[#,Head[#]===VertexDisplacement&]&), y : Except[_List] ] :> Thread[x->y],
	pi_PeriodicIdentificationData :> (pi["DisplacementRules"] /. Thread[pi["labels"]->1])
};

parseDisplacementRules[ x_ , err_] := 
Module[{
processedRules=Flatten[ {x} //. displacementParsingRules ], badQ
},
	badQ = DeleteCases[ processedRules, VertexDisplacement[_Integer,_String] -> Except[_List] ];
	If[Length[badQ] > 0, 
		Evaluate[err]; {} , 
		processedRules
	]
]
SetAttributes[parseDisplacementRules,HoldRest];*)


(*RandomDisplacements[ m_, opt : OptionsPattern[] ] := With[{res=RandomDisplacements[m,1, opt]},
	res[[1]] /; Head[res] =!= RandomDisplacements
]

RandomDisplacements[ m_?MechanismQ, num : Except[_Rule] , opt : OptionsPattern[] ] := 
With[{
	precision = precisionQ[ RandomDisplacements, OptionValue[WorkingPrecision] ],
	rules = processRules[ RandomDisplacements, OptionValue[ConstraintRules] ],
	distribution = OptionValue[Distribution],
	number = processNumber[RandomDisplacements, num]
},
	With[{res=randomDisplacementsInternal[ m["VertexCoordinates"], distribution, precision, rules, number ]},
		res /; res =!= $Failed
	] /; precision =!= $Failed && number =!= $Failed
]

RandomDisplacements[ pos_?VertexCoordinatesQ, num : Except[_Rule] , opt : OptionsPattern[] ] := 
With[{
	precision = precisionQ[ RandomDisplacements, OptionValue[WorkingPrecision] ],
	rules = processRules[ RandomDisplacements, OptionValue[ConstraintRules] ],
	distribution = OptionValue[Distribution],
	number = processNumber[RandomDisplacements, num]
},
	With[{res=randomDisplacementsInternal[ pos, distribution, precision, rules, number ]},
		res /; res =!= $Failed
	] /; precision =!= $Failed && number =!= $Failed
]

RandomDisplacements[ a_, ___] := "nothing" /; Message[RandomDisplacements::pos]*)


(*RandomPositions[ m_ , opt : OptionsPattern[] ] := With[{res=RandomPositions[m,1,opt]}, res[[1]] /; Head[res] =!= RandomPositions]

RandomPositions[ m_?MechanismQ, num : Except[_Rule] , opt : OptionsPattern[] ] := 
With[{
	precision = precisionQ[ RandomPositions, OptionValue[WorkingPrecision] ],
	rules = processRules[ RandomPositions, OptionValue[ConstraintRules] ],
	distribution = OptionValue[Distribution],
	number = processNumber[RandomPositions, num]
},
	With[{res=randomDisplacementsInternal[ m["VertexCoordinates"], distribution, precision, rules, number ]},
		(ConstantArray[m["VertexCoordinates"],number]+res) /; res =!= $Failed
	] /; precision =!= $Failed && number =!= $Failed
]

RandomPositions[ pos_?VertexCoordinatesQ, num : Except[_Rule] , opt : OptionsPattern[] ] := 
With[{
	precision = precisionQ[RandomPositions, OptionValue[WorkingPrecision] ],
	rules = processRules[RandomPositions, OptionValue[ConstraintRules] ],
	distribution = OptionValue[Distribution],
	number = processNumber[RandomPositions, num]
},
	With[{res=randomDisplacementsInternal[ pos, distribution, precision, rules, number ]},
		(ConstantArray[pos,number]+res) /; res =!= $Failed
	] /; precision =!= $Failed && number =!= $Failed
]

RandomPositions[ a_, ___] := "nothing" /; Message[RandomPositions::pos]*)


MechanismCellRawData[anything__][ m_?MechanismQ ] := MechanismCellRawData[m, anything]

MechanismCellRawData[ m_?MechanismQ , cellSpec_ : _ ] :=
	#[[1]] -> Association@@#[[2]]&/@Cases[Mechanisms`Private`mechanismCellList["Unthreaded", m, cellSpec, None, _],_Rule]
MechanismCellRawData[ m_?MechanismQ , cellSpec_ : _ , dataSpec_ ] := 
	#[[1]] -> Association@@#[[2]]&/@Cases[Mechanisms`Private`mechanismCellList["Unthreaded", m, cellSpec, dataSpec, _],_Rule]

MechanismCellRawData[ Deformed[ m_?MechanismQ , _], anything__ ] := MechanismCellRawData[ m, anything]


MechanismCellData[ anything___ ][m_?MechanismQ] := MechanismCellData[m, anything]

MechanismCellData[ m_?MechanismQ, cellSpec_ : _] := cellData[m, m["VertexCoordinates"], cellSpec]
MechanismCellData[ Deformed[m_?MechanismQ, pos_], cellSpec_ : _ ] := 
	cellData[m, m["VertexCoordinates"], cellSpec] /; VertexCoordinatesQ[m,pos]

MechanismCellData[ Deformed[m_?MechanismQ, pos_], ___ ] := "nothing" /; Message[ MechanismCellData::pos , pos ]
MechanismCellData::pos = "Positions `1` do not correspond to mechanism.";


MechanismCellDataValue[ m_?MechanismQ, cellSpec_ , data_ ] := With[{d=cellData[m, m["VertexCoordinates"], cellSpec]},
	{#[[1]], #[[2]][data]}& /@ d
]
MechanismCellDataValue[ Deformed[m_?MechanismQ, pos_], cellSpec_ , data_ ] := With[{d=cellData[m, m["VertexCoordinates"], cellSpec]},
	{#[[1]], #[[2]][data]}& /@ d
] /; VertexCoordinatesQ[m,pos]


MechanismConstrainedCells[ m_?MechanismQ , cellSpec_ : _ ] := With[{out=Check[cellData[m , m["VertexCoordinates"], cellSpec , $constrainedCellData], $Failed]},
	out /; out =!= $Failed
]
MechanismConstrainedCells[ Deformed[ m_?MechanismQ , pos_ ] , cellSpec_ : _ ] := With[{
	out =Check[
		cellData[m , m["VertexCoordinates"], cellSpec , $constrainedCellData],
		$Failed
		]},
	out /; out =!= $Failed
]/; VertexCoordinatesQ[ m , pos ]

MechanismConstrainedCells[ Deformed[m_?MechanismQ, pos_], ___ ] := "nothing" /; Message[MechanismConstrainedCells::pos, pos]
MechanismConstrainedCells::pos = "Positions `1` do not correspond to mechanism.";


Options[MechanismLinearConstraints]={Constraints -> None, CellPattern -> _};

MechanismLinearConstraints[m_?MechanismQ, OptionsPattern[] ] := 
	processConstraintEquations[ VertexPosition[m] , constraintEquations[m, m["VertexCoordinates"], OptionValue[CellPattern], OptionValue[Constraints] ] ]["linear solutions"]
MechanismLinearConstraints[ Deformed[ m_?MechanismQ , pos_ ], OptionsPattern[] ] :=
	processConstraintEquations[ VertexPosition[m] , constraintEquations[m, pos, OptionValue[CellPattern], OptionValue[Constraints] ] ]["linear solutions"] /; VertexCoordinatesQ[m, pos]

MechanismLinearConstraints[ Deformed[m_?MechanismQ, pos_], ___ ] := "nothing" /; Message[MechanismLinearConstraints::pos, pos]
MechanismLinearConstraints::pos = "Positions `1` do not correspond to mechanism.";


Options[MechanismConstraintMap] = {
	Constraints -> None,
	CellPattern -> _,
	ReduceLinearConstraints -> False
};

(*version with arbitrary vertex positions*)
MechanismConstraintMap[ m_?MechanismQ , order : Except[_Rule|_List] : "nothing" , OptionsPattern[] ] :=
With[{ res = internalConstraintMap[m, VertexPosition[m], order, OptionValue[ReduceLinearConstraints], OptionValue[CellPattern], OptionValue[Constraints] ] },
	res /; Head[res] =!= internalConstraintMap
] /; orderQ[ order] && reduceLinearConstraintsQ[ OptionValue[ReduceLinearConstraints] ]

(*compute the strains with given vertex positions*)
MechanismConstraintMap[ Deformed[ m_?MechanismQ , positions_ ] , order : Except[_Rule|_List] : "nothing" , OptionsPattern[] ] :=
With[{ res = internalConstraintMap[m, positions, order, OptionValue[ReduceLinearConstraints], OptionValue[CellPattern], OptionValue[Constraints] ] },
	res /; Head[res] =!= internalConstraintMap
] /; VertexCoordinatesQ[m, positions] && orderQ[ order] && reduceLinearConstraintsQ[ OptionValue[ReduceLinearConstraints] ]

MechanismConstraintMap[ Deformed[ m_?MechanismQ , positions_] , order : Except[_Rule|_List] , OptionsPattern[] ] := 
	"nothing" /; Message[MechanismConstraintMap::pos, positions]
	
(*reduce constraints*)
reduceLinearConstraintsQ[ x_?BooleanQ ] := True
reduceLinearConstraintsQ[ x_ ] := (Message[MechanismConstraintMap::red]; False)

(*order requested*)
orderQ[Infinity|_Integer?Positive|"nothing"] := True
orderQ[ order : Except[_Rule] ] := (Message[MechanismConstraintMap::order, order]; False)

MechanismConstraintMap::pos="Positions `1` cannot correspond to the mechanism.";
MechanismConstraintMap::red="Option ReduceLinearConstraints should be Boolean.";
MechanismConstraintMap::order="Order `1` must be a positive integer or Infinity.";


(*
	positions are the positions of the actual mechanism
	order is a positve integer indicated the order we should expand to
	reduceLinearConstraints is a Boolean to decide if we should remove linear constraints from the constraints (since they are often solved explicitly)
	cellPattern is a cell selection pattern
	constraints are additional constraints we might add that aren't represented by cells
*)
internalConstraintMap[ m_ , positions_ , order_ , reduceLinearConstraints_ , cellPattern_ , constraints_  ] :=
With[{ 
	eq = constraintEquations[m, m["VertexCoordinates"], cellPattern, constraints] (*get the constraint equations based on mechanism positions*)
},
	reduceConstraintToOrder[ positions, (*expand constraints around provided positions*)
		If[ reduceLinearConstraints , 
			processConstraintEquations[ VertexPosition[m] , eq ]["nonlinear constraints"],
			eq
		],
		order ] /; Head[eq] === List
]


EuclideanMotionConstraints[ m_?MechanismQ, data_ ] := With[{out=euclideanConstraintsInternal[m["VertexCoordinates"],Flatten[{data} /. m["labels"]] ]}, out /; Head[out]===List]
EuclideanMotionConstraints[ pos_?VertexCoordinatesQ, data_ ] := With[{out=euclideanConstraintsInternal[pos,Flatten[{data}] ]}, out /; Head[out]===List]


euclideanConstraintsInternal[ pos_?VertexCoordinatesQ, numberedEdge : {_Integer} ] := 
	VertexDisplacement[ numberedEdge[[1]], All[2]] /; Length[pos[[1]]] == 2 && Max[numberedEdge] <= Length[pos] && Min[numberedEdge] > 0

euclideanConstraintsInternal[ pos_?VertexCoordinatesQ,  numberedEdge : {_Integer,_Integer} ] := 
	Flatten[{
		(*fix a vertex*)
		VertexDisplacement[ numberedEdge[[1]], All[2]],
		(*fix the orientation of the edge*)
		({{0,1},{-1,0}} . ( pos[[numberedEdge[[2]]]]-pos[[numberedEdge[[1]]]] )) . (VertexDisplacement[ numberedEdge[[2]] , All[2] ] - VertexDisplacement[ numberedEdge[[1]], All[2] ])
	}] /; Length[pos[[1]]] == 2 && Max[numberedEdge] <= Length[pos] && Min[numberedEdge] > 0


euclideanConstraintsInternal[ pos_?VertexCoordinatesQ, numberedEdge : {_Integer} ] := 
	VertexDisplacement[ numberedEdge[[1]] , All[3]]  /; Length[pos[[1]]] == 3 && Max[numberedEdge] <= Length[pos] && Min[numberedEdge] > 0

euclideanConstraintsInternal[ pos_?VertexCoordinatesQ, numberedEdge : {_Integer,_Integer} ] := 
	Flatten[{
		(*fix a vertex*)
		VertexDisplacement[ numberedEdge[[1]], All[3]],
		(*fix the orientation of the edge*)
		NullSpace[ {pos[[numberedEdge[[2]]]]-pos[[numberedEdge[[1]]]]} ] . (VertexDisplacement[ numberedEdge[[2]] , All[3] ] - VertexDisplacement[ numberedEdge[[1]], All[3] ])
	}]  /; Length[pos[[1]]] == 3 && Max[numberedEdge] <= Length[pos] && Min[numberedEdge] > 0

euclideanConstraintsInternal[ pos_?VertexCoordinatesQ, numberedEdge : {_Integer,_Integer,_Integer} ] := 
	Flatten[{
		(*fix a vertex*)
		VertexDisplacement[ numberedEdge[[1]], All[3]],
		(*fix the orientation of the edge*)
		NullSpace[ {pos[[numberedEdge[[2]]]]-pos[[numberedEdge[[1]]]]} ] . (VertexDisplacement[ numberedEdge[[2]] , All[3] ] - VertexDisplacement[ numberedEdge[[1]], All[3] ]),
			NullSpace[ {pos[[numberedEdge[[2]]]]-pos[[numberedEdge[[1]]]],pos[[numberedEdge[[3]]]]-pos[[numberedEdge[[1]]]]} ] . (VertexDisplacement[ numberedEdge[[3]] , All[3] ] - VertexDisplacement[ numberedEdge[[1]], All[3] ])
	}]  /; Length[pos[[1]]] == 3 && Max[numberedEdge] <= Length[pos] && Min[numberedEdge] > 0


euclideanConstraintsInternal[ m_?VertexCoordinatesQ, edge : {__Integer} ] := (
	If[ Max[edge] > Length[m] || Min[edge] <= 0, Message[EuclideanMotionConstraints::c, edge] ];
	If[ Length[edge]>Length[m[[1]]], Message[EuclideanMotionConstraints::e, Length[m[[1]]] ] ];
	$Failed
)

euclideanConstraintsInternal[ m_?VertexCoordinatesQ , edge_ ] := "nothing" /; Message[EuclideanMotionConstraints::i, edge]

EuclideanMotionConstraints::e = "Mechanism of embedding dimension `1` cannot have more than `1` vertices specified.";
EuclideanMotionConstraints::c = "One of the vertices of `1` is out of bounds.";
EuclideanMotionConstraints::i = "The vertices of `1` are not all valid.";


(*check that this energy is properly numeric*)
minimizableEnergyQ[ energy_?CompiledMechanismEnergyQ , positions_ ] := VectorQ[ energy["data"], NumericQ ] && Quiet[TrueQ[ energy[Flatten[positions],energy["data"]] ] ]
minimizableEnergyQ[ energy_ , positions_ ] := 
With[{
	number = N[ energy /. Dispatch[PositionRules[positions]] ]
},
	Im[Chop[number]] == 0 && NumericQ[number] && Chop[Im[number]] == 0
]


(*return a list of non-numeric variables*)
nonNumericVariablesInEnergy[ energy_?CompiledMechanismEnergyQ , positions_  ] :=
	Select[energy["data"], Not[NumericQ[#]]&]

nonNumericVariablesInEnergy[ energy_ , positions_  ] := With[{
	number = N[ energy /. Dispatch[PositionRules[positions]] ]
},
	Variables[number]
]


(*
	minimizeEnergy[
		energy , 
		{ flattened vertex positions , positions we minimize over }, 
		initial positions of mechanism , 
		options for FindMinimum[]
	]
	
	returns
	
		{ energy , flattened positions}
	
	or
	
		{"error"[energy], flattened positions} if an error flag is thrown
*)
minimizeEnergy[ energy_?CompiledMechanismEnergyQ , {variables_ , namedVariables_} , positions_ , options_] :=
Module[{ result , data = energy["data"] , initialNamedVariables = Pick[ Flatten[positions] , variables , _VertexPosition]},
	Check[
		result = FindMinimum @@ {
			energy["energy"][variables, data],
			Sequence @@ Transpose[{namedVariables , initialNamedVariables}],
			Gradient :> energy["gradient"][variables, data],
			Sequence @@ options
		};
		{result[[1]], variables /. Dispatch[result[[2]]]}
		,
		{ "error" @ result[[1]] , variables /. Dispatch[result[[2]]] }
	]
]

minimizeEnergy[ energy_ , {variables_ , namedVariables_} , positions_ , options_ ] :=
Module[{result , initialNamedVariables = Pick[ Flatten[positions] , variables , _VertexPosition]},
	Check[
		result = FindMinimum @@ {
			energy,
			Sequence @@ Transpose[{namedVariables, initialNamedVariables}],
			options
		};
		{result[[1]], variables /. Dispatch[result[[2]]]}
		,
		{"error" @ result[[1]] , variables /. Dispatch[result[[2]]] }
	]
]


(*
	mobileVariables[ mechanism , constraint equations, positions ] returns
	
		{ 
		flattened list of all vertex positions satisfying linear constraints , 
		only minimizable variables
		}
*)
mobileVariables[ m_ , constraints_ ] := 
Module[{
	variables = Flatten[processConstraintEquations[ VertexPosition[m], constraints ]["constrained positions"]],
	namedVariableSelector
},
	namedVariableSelector = MatchQ[ #, _VertexPosition] & /@ variables;
	{ variables , Pick[variables , namedVariableSelector] }
]


(*
evaluateEnergy[ (m), (positions), energy ] evaluates the energy (or compiled energy) in a number of different ways.
*)

evaluateEnergy[m_?MechanismQ, positions_?MatrixQ, energy: Except[_CompiledMechanismEnergy]]:=
	energy /. Dispatch[PositionRules[positions]]

evaluateEnergy[m_?MechanismQ, positions_?VectorQ, energy: Except[_CompiledMechanismEnergy]]:=
	energy /. Dispatch[Thread[Flatten[VertexPosition[m]]->positions]]

evaluateEnergy[m_?MechanismQ, positions_?MatrixQ, energy_?CompiledMechanismEnergyQ]:=
	energy[[2]][Flatten[positions],energy["data"]]

evaluateEnergy[m_?MechanismQ, positions_?VectorQ, energy_?CompiledMechanismEnergyQ]:=
	energy[[2]][positions,energy["data"]]
	
evaluateEnergy[positions_?MatrixQ, energy: Except[_CompiledMechanismEnergy]]:=
	energy /. Dispatch[PositionRules[positions]]

evaluateEnergy[positions_?VectorQ, energy: Except[_CompiledMechanismEnergy]]:=
	energy /. Dispatch[Thread[Flatten[VertexPosition[m]]->positions]]

evaluateEnergy[positions_?MatrixQ, energy_?CompiledMechanismEnergyQ]:=
	energy[[2]][Flatten[positions],energy["data"]]

evaluateEnergy[positions_?VectorQ, energy_?CompiledMechanismEnergyQ]:=
	energy[[2]][positions,energy["data"]]


$DefaultMechanismStiffnesses["SmallestLength"]=10^(-6);

$DefaultMechanismStiffnesses::err="`1` does not have a default stiffness.";
$DefaultMechanismStiffnesses[s_]:="nothing"/; Message[$DefaultMechanismStiffnesses::err,s]


Options[MechanismEnergy] = 
	{ SetParameters -> {}, Constraints -> None, CellPattern -> _ , ConstraintModulus -> 10^(-1), ReduceLinearConstraints -> True };

MechanismEnergy[ m_?MechanismQ, OptionsPattern[] ] :=
	With[{res=mechanismEnergyInternal[ m , VertexPosition[m] , OptionValue[Constraints] , OptionValue[ConstraintModulus] , OptionValue[CellPattern] , OptionValue[ReduceLinearConstraints] , OptionValue[SetParameters] ]},
		res /; Head[res] =!= mechanismEnergyInternal
	]
MechanismEnergy[ Deformed[ m_?MechanismQ , pos_] , OptionsPattern[] ] :=
	With[{res=mechanismEnergyInternal[ m , pos , OptionValue[Constraints],  OptionValue[ConstraintModulus], OptionValue[CellPattern] , OptionValue[ReduceLinearConstraints], OptionValue[SetParameters] ] },
		res /; Head[res] =!= mechanismEnergyInternal
	] /; VertexCoordinatesQ[ m , pos ]

MechanismEnergy::pos="Positions `1` cannot correspond to mechanism.";
MechanismEnergy[ Deformed[ m_?MechanismQ , pos_ ] , OptionsPattern[] ] := "nothing" /; Message[MechanismEnergy::pos, pos]

MechanismEnergy::param="Option SetParameters -> `1` should be a list of replacement rules.";


mechanismEnergyInternal[ m_, positions_, inputConstraints_, constraintScale_?NumericQ,  pattern_ , reduceLinearConstraints_, setparams_ ] := 
With[{ constraints = Mechanisms`geometry`Private`MechanismGeometricExpression[ PlaceVertices[m,positions], inputConstraints ]},
With[
{
	components = cellData[m, m["VertexCoordinates"], pattern],
	(*process only the added constraints here; linear constraints here will be eliminated automatically*)
	constraintData = processConstraintEquations[m["VertexCoordinates"] , constraints],
	(*if requested, solve all the linear constraints here including those from cells*)
	linearConstraints = If[ TrueQ[reduceLinearConstraints], 
		MechanismLinearConstraints[ m, Constraints -> constraints ],
		{}],
	arbitraryPositions = VertexPosition[m],
	params = If[ MatchQ[setparams, {___Rule}] , setparams, Message[MechanismEnergy::param, setparams]; {}]
},
	Total @ Flatten[{
		cellEnergy[m, m["VertexCoordinates"], positions, #]& /@ components,
		constraintScale (constraintData["nonlinear constraints"] . constraintData["nonlinear constraints"])/2
	}] /. If[ TrueQ[ reduceLinearConstraints], linearConstraints, constraintData["linear solutions"] ] /. params
]] /; Which[
			constraintScale < 0, Message[MechanismEnergy::scale, constraintScale]; False, 
			Not[BooleanQ[reduceLinearConstraints]], Message[MechanismEnergy::red]; False,
			True, True
	]

MechanismEnergy::scale="Constraint modulus `1` should be a non-negative number.";
MechanismEnergy::red="Option ReduceLinearConstraints must be Boolean.";


CompiledMechanismEnergy[variables_List,energy_CompiledFunction,gradient_CompiledFunction]["variables"]:=variables

Format[CompiledMechanismEnergy[variables_List,energy_CompiledFunction,gradient_CompiledFunction]]:=
StringJoin[
	"CompiledMechanismEnergy[",
	If[Length[variables]<10,
		ToString[variables],
		"{"<>ToString[First[variables]<>"..."<>Last[variables]<>"}"]
	],
	"]"
]


CompiledMechanismEnergy[variables_?VectorQ,energy_CompiledFunction,gradient_CompiledFunction]["data"]:=variables

CompiledMechanismEnergy[variables_List,energy_CompiledFunction,gradient_CompiledFunction]["energy"][pos_?(VectorQ[#,NumericQ]&),data_] := 
	energy[pos,data]
CompiledMechanismEnergy[variables_List,energy_CompiledFunction,gradient_CompiledFunction]["gradient"][pos_?(VectorQ[#,NumericQ]&),data_] := 
	gradient[pos,data]

CompiledMechanismEnergy[variables_List,energy_CompiledFunction,gradient_CompiledFunction][v_?(VectorQ[#,NumericQ]&)] := 
	CompiledMechanismEnergy[v,energy,gradient]


CompiledMechanismEnergyQ[CompiledMechanismEnergy[variables_,energy_CompiledFunction,gradient_CompiledFunction]]:=VectorQ[variables]
CompiledMechanismEnergyQ[_]:=False

compiledNumericalMechanismEnergyQ[CompiledMechanismEnergy[variables_,energy_CompiledFunction,gradient_CompiledFunction]]:=VectorQ[variables,NumericQ]
compiledNumericalMechanismEnergyQ[_]:=False


Options[CompiledMechanismEnergy] := Join[
	(*this is going to be set to False permanently for this function just in case*)
	FilterRules[ Options[MechanismEnergy], Except[ReduceLinearConstraints] ],
	{
	AddedEnergy->0,
	CompilationTarget -> Automatic
	}
]


CompiledMechanismEnergy[m_?MechanismQ, opt : OptionsPattern[]] :=
Module[{
	res = compiledmechanismEnergyInternal[m, Mechanisms`geometry`Private`MechanismGeometricExpression[m,OptionValue[AddedEnergy]],
						FilterRules[{opt}, Options[MechanismEnergy]],
						OptionValue[CompilationTarget] 
					]},
	res /; res=!=$Failed
]

CompiledMechanismEnergy::pos="Provided positions `1` do not correspond to Mechanism.";
CompiledMechanismEnergy[m_?MechanismQ, pos_ , ___ ]:="nothing"/;Message[CompiledMechanismEnergy::pos, pos]
CompiledMechanismEnergy::comp = "CompilationTarget `1` is not a string or Automatic. Using Automatic.";


compiledmechanismEnergyInternal[m_, additionalEnergy_ , energyOptions_, compilationTarget_]:=
Module[
{
	symbols, uniqueSymbols,
	arbitraryPositions = Flatten[VertexPosition[m]],

	energy = MechanismEnergy[ m , 
					ReduceLinearConstraints -> False , Sequence @@ energyOptions
			] + Mechanisms`geometry`Private`MechanismGeometricExpression[m, additionalEnergy],
	modifiedEnergy,

	compilationTargetActual = Which[ 
		compilationTarget === Automatic, $MechanismCompilationTarget,
		Head[compilationTarget] === String , compilationTarget,
		True,
			Message[CompiledMechanismEnergy::comp, compilationTarget];
			$MechanismCompilationTarget
		]
},
	If[ Head[energy] === MechanismEnergy, 
		(*if you are here, somehow the mechanism energy failed.
		It may not always return an error so make sure this function returns one.*)
		Message[CompiledMechanismEnergy::en];
		$Failed,

		(*get all symbols we need to declare that are not positions*)
		symbols = DeleteDuplicates[ DeleteCases[  Select[ Cases[ energy, _Symbol|_Symbol[_], Infinity], Not[NumericQ[#]]& ], _VertexPosition ] ];
		(*give them all unique names*)
		uniqueSymbols = Unique[]& /@ symbols;
		(*rewrite the energy in terms of the new symbols*)
		modifiedEnergy = energy /. Dispatch[Thread[ symbols -> uniqueSymbols]];

		Check[
			CompiledMechanismEnergy[
				symbols,
				compileExpression[ modifiedEnergy, arbitraryPositions, uniqueSymbols, compilationTargetActual],
				compileExpression[ D[ modifiedEnergy, {arbitraryPositions} ], arbitraryPositions, uniqueSymbols, compilationTargetActual]
			],
			$Failed
		]
	]
]

CompiledMechanismEnergy::en="Unable to find an expression for the mechanism energy.";


compileExpression[expression_, variables_ , symbols_, compiler_]:=Module[
{
body,
injector,c,
dataInjector,data
},
	(*rules to replace VertexPosition[ n , c ] with c[[ m ]] where m is associated with the relevant variable*)
	injector = Dispatch @ Thread[ variables -> ( Hold[c[[#]]]& /@ Range[Length@variables] ) ];
	(*rules to replace data with an element of corresponding data matrix  *)
	dataInjector = Dispatch @ Thread[ symbols -> ( Hold[data[[#]]]& /@ Range[Length@symbols] ) ];
	(*rewrite the body of the energy using the rules*)
	body=expression /. injector /. dataInjector ;

	ReleaseHold[Hold[Compile][
		{{c,_Real,1},{data,_Real,1}},
		body,
		RuntimeOptions -> { "Speed", "EvaluateSymbolically" -> False },
		CompilationTarget -> compiler,
		Parallelization -> True
	]]
]


Options[MinimizeMechanismEnergy]=Join[{
	(*initial positions for the minimization.*)
	InitialPositions -> Automatic,
	(*should we include "error" head around the energy of a minimization that produced errors?*)
	"IncludeError" -> False
	},
	(*this isn't adjustable in this function*)
	FilterRules[ Options[MechanismEnergy], Except[ReduceLinearConstraints] ], 
	Options[FindMinimum]
];
SetAttributes[MinimizeMechanismEnergy,HoldRest];

MinimizeMechanismEnergy::badinitial="Initial conditions are not well-formed numeric positions matching the Mechanism.";
MinimizeMechanismEnergy::data="Data `1` is not numerical. Use Replace to substitute numerical values.";
MinimizeMechanismEnergy::energy="Energy is not numerical at initial condition. Non-numeric variables are `1`";


MinimizeMechanismEnergy[ energy : Except[_Rule], opt : OptionsPattern[] ][m_?MechanismQ] := With[
{res = MinimizeMechanismEnergy[ m, energy, opt ]},
	If[Head[res]===List , PlaceVertices[res[[2]]] , m]
]
MinimizeMechanismEnergy[ opt : OptionsPattern[] ][m_?MechanismQ] := With[
{res = minimizeMechanismEnergyInternal[ m, Automatic, Automatic, {opt} ] },
	If[Head[res]===List , PlaceVertices[m, res[[2]]] , m]
]

MinimizeMechanismEnergy[ m_?MechanismQ, energy : Except[_Rule] : Automatic, opt : OptionsPattern[]] :=
Module[{res = minimizeMechanismEnergyInternal[ m, energy, OptionValue[InitialPositions], {opt} ] },
	res /; res =!= $Failed
]
MinimizeMechanismEnergy[ Deformed[m_?MechanismQ, positions_], energy : Except[_Rule] : Automatic, opt : OptionsPattern[]] :=
Module[{res = minimizeMechanismEnergyInternal[ m, energy, positions, {opt} ] },
	res /; res =!= $Failed
] /; NumericCoordinatesQ[m, positions]

MinimizeMechanismEnergy[ Deformed[m_?MechanismQ, positions_], energy : Except[_Rule] : Automatic, opt : OptionsPattern[]] :=
	"nothing" /; Message[MinimizeMechanismEnergy::pos, positions]

MinimizeMechanismEnergy::pos="Deformed positions `1` are not numeric positions corresponding to mechanism.";

minimizeMechanismEnergyInternal[ m_, energyExpression_, initial_, opt_ ] := Module[
{
	energy = minimizeMechanismEnergyComputeEnergy[m, energyExpression, opt ],
	initialPositions = minimizeMechanismEnergyInitialPositions[m, initial ],
	res
},
	If[energy =!= $Failed && initialPositions =!= $Failed,
		(*do the minimization and format the results for output*)
		res = Map[ minimizeMechanismEnergyOutputFormat, minimizeFindMinimum[ m, energy, initialPositions, opt ] ];

		If[ Length[ Dimensions[initial] ] == 3, 
			Merge[res,Identity], 
			If[TrueQ[OptionValue["IncludeError"]], First[res], Values[First[res]][[2;;]]]
		],
		$Failed
	]
]


(*
	parse the initial positions
*)
minimizeMechanismEnergyInitialPositions[ m_, Automatic ] := {m["VertexCoordinates"]}
minimizeMechanismEnergyInitialPositions[ m_, initialPositions_?MatrixQ ] := {initialPositions} /; NumericCoordinatesQ[m, initialPositions]
minimizeMechanismEnergyInitialPositions[ m_, initialPositions_?(ArrayQ[#,_,NumericQ]&) ] := initialPositions /; Dimensions[initialPositions][[2;;]] == {m["VertexCount"],m["EmbeddingDimension"]}
minimizeMechanismEnergyInitialPositions[ m_, pos_ ] := (Message[MinimizeMechanismEnergy::badinitial]; $Failed)

(*
	parse the energy we want
*)
minimizeMechanismEnergyComputeEnergy[ m_, Automatic, options_ ] := With[
{en=MechanismEnergy[m, FilterRules[{options}, Options[MechanismEnergy]] ]},
	If[
		minimizableEnergyQ[en, m["VertexCoordinates"]], 
		en, 
		Message[MinimizeMechanismEnergy::energy, nonNumericVariablesInEnergy[en, m["VertexCoordinates"]] ]; $Failed
	]
]
minimizeMechanismEnergyComputeEnergy[ m_, energy_?compiledNumericalMechanismEnergyQ, options_ ] := 
	If[
		VectorQ[energy["data"], NumericQ],
		energy,
		Message[MinimizeMechanismEnergy::energy, Select[ energy["data"] , _?(Not[NumericQ[#]]&) ]]; $Failed
	]
minimizeMechanismEnergyComputeEnergy[ m_, analyticEnergy_, options_ ] := With[{
	en = Mechanisms`geometry`Private`MechanismGeometricExpression[m,analyticEnergy]
	},
	If[
		minimizableEnergyQ[en, m["VertexCoordinates"]],
		en, 
		Message[MinimizeMechanismEnergy::energy, nonNumericVariablesInEnergy[en, m["VertexCoordinates"]] ]; $Failed
	]
]

(*
	output
*)
minimizeMechanismEnergyOutputFormat[ {"error"[energy_], positions_} ] := <| "Error"->True, "Energy"->energy, "VertexCoordinates"->ToPackedArray[N[positions,Precision[positions]]] |>
minimizeMechanismEnergyOutputFormat[ {energy_, positions_} ] := <| "Error"->False, "Energy"->energy, "VertexCoordinates"->ToPackedArray[N[positions,Precision[positions]]] |>


(*
	actually do the minimization over all the initial positions
*)
minimizeFindMinimum[ m_ , energy_ , initialPositions_ , options_ ] :=
Module[
{
	(*process the constraints based on internal vertex coordinates*)
	constraints,
	constraintData ,

	(*get the data provided*)
	data = If[ compiledNumericalMechanismEnergyQ[energy], energy["data"], {} ],

	(*variables*)
	constrainedPositions, selector, components,
	variables, initialMinimizationRules,

	minimizationOptions = FilterRules[ FilterRules[options, Options[FindMinimum]], Except[Gradient] ],
	
	minimizationResults, tmp
},
	(*get the constrained positions for each initial position we want to consider*)
	constraints = MechanismConstraintMap[ m, Sequence @@ FilterRules[ options , Options[MechanismConstraintMap] ] ];
	constraintData = processConstraintEquations[ VertexPosition[m], constraints ]& /@ initialPositions ;
	constrainedPositions = N[Flatten[ #["constrained positions"] ]] & /@ constraintData ;

	(* 
		what variables are we actually minimizing over?
		
		note that the variables we will minimize over should always be VertexPositions. Therefore, to identify which ones we can minimize over, we
		just need to identify the constrained positions that have the form of a pure VertexPosition[].
	*)
	selector = MatchQ[#, VertexPosition[_,_] ]& /@ constrainedPositions[[1]];
	variables = DeleteDuplicates[ Pick[ constrainedPositions[[1]] , selector ]];
	initialMinimizationRules = Thread /@ Thread[ConstantArray[Flatten[VertexPosition[m]], Length[initialPositions] ] ->  (Flatten /@ initialPositions)];

	(*do one minimization for each initial condition specified*)
	minimizationResults = If[ compiledNumericalMechanismEnergyQ[energy],
		components = Pick[ Range[ Length[selector] ] , selector ];
		(*compiled energy*)
		MapThread[
			Check[
				tmp = FindMinimum @@ {  
					energy["energy"][#1 , data] , 
					Sequence @@ #2 ,  
					Gradient :> energy["gradient"][#1 , data][[components]], 
					Sequence @@ minimizationOptions },
				(*if the minimization reports an error, just flag it here*)
				{"error" @ tmp[[1]], tmp[[2]] }
			] &,
			{
			constrainedPositions,
			Transpose /@ Thread[{ ConstantArray[variables,Length[initialMinimizationRules]], variables /. initialMinimizationRules}]
			}
		],
		(*analytical energy*)
		MapThread[
			Check[
				tmp = FindMinimum @@ {  energy /. #1, Sequence @@ #2 ,  Sequence @@ minimizationOptions } ,
				(*if the minimization reports an error, just flag it here*)
				{"error" @ tmp[[1]], tmp[[2]] }
			] &,
			{
			constraintData[[All, "linear solutions"]],
			Transpose /@ Thread[{ ConstantArray[variables,Length[initialMinimizationRules]], variables /. initialMinimizationRules }]			
			}
		]
	];


	(*output the results as a list { energy, positons} instead of rules*)
	MapThread[
		{#2[[1]] , #1["constrained positions"] /. #2[[2]] } & ,
		{
		constraintData,
		minimizationResults
		}
	]
]


(*
rigidityMatrix[ m, extra constraints , cell pattern, reduce] returns the rigidity matrix for a mechanism
with vertices at given positions.

extra constraints allows additional constraints to be imposed.
cell pattern only includes certain cells that match a pattern.
reduce is a Boolean. True if we should solve linear constraints and remove solved constraints from the matrix.
*)
rigidityMatrix[ m_, positions_ , extraConstraints_ , cellPattern_ , reduce_] :=
Module[{names = standardVariableNames[m][[1]], equations, constraints},
	(*get constraint equations using arbitrary vertex positions*)
	equations = constraintEquations[ m , names , cellPattern, extraConstraints];
	constraints = If[ TrueQ[reduce],
		With[ {tmp = processConstraintEquations[ VertexPosition[m], equations ]},
			{
			tmp["variables"],
			tmp["nonlinear constraints"]
			} 
		],
		
		{Flatten[VertexPosition[m]], equations}
	] ;
	
	CoefficientArrays[ 
		(*reduce constraints to first order and restore names of vertex positions*)
		reduceConstraintToOrder[names , constraints[[2]], 1] /. Dispatch[Thread[Flatten[names] -> Flatten[positions]]],
		constraints[[1]] /. VertexPosition -> VertexDisplacement
	]
]


stressedQ[ arrays_List , tol_ ] := (Max @ Abs @ N @ Normal @ arrays[[1]]) >= tol /; Length[arrays] >= 1 && VectorQ[ arrays[[1]] , NumericQ ]
stressedQ[ arrays_List, tol_ ] := "analytic" /; Length[arrays] >= 1
stressedQ[ _ , _ ] := $Failed


(*
selfStresses[constraint matrix, tolerance]

returns the left null space of a constraint matrix given some tolerance. If the matrix is numerical, 
	it uses the eigenvalues of C C^T smaller than tolerance. otherwise it uses the function NullSpace[]
*)
selfStresses[ mat_ , tol_] := 
With[ {es = Quiet @ Eigensystem[ mat . Transpose[mat] ]},
	Pick[ es[[2]] , (# <= tol&) /@ es[[1]] ]
] /; MatrixQ[ mat , MachineRealQ ]

(*selfStresses[ mat_ , tol_] := 
With[ {es = Quiet @ Simplify @ Eigensystem[ mat . Transpose[mat] ]},
	Orthogonalize @ Pick[ es[[2]] , (# <= tol&) /@ es[[1]] ]
] /; MatrixQ[ mat , NumericQ ]*)

selfStresses[ mat_ , tol_] := NullSpace[ Transpose[mat], Tolerance -> tol]


(*
zeroModes[constraint matrix, tolerance]

returns the right null space of a constraint matrix given some tolerance. If the matrix is numerical,
	it uses the eigenvalues of C^T C smaller thance Tolerance. otherwise it uses the function NullSpace[]
*)
zeroModes[ mat_ , tol_ ] :=
With[ {es = Quiet @ Eigensystem[ Transpose[mat] . mat ]},
	Pick[ es[[2]] , (# <= tol&) /@ es[[1]] ]
] /; MatrixQ[ mat , MachineRealQ ]

(*zeroModes[ mat_ , tol_ ] :=
With[ {es = Quiet @ Simplify @ Eigensystem[ Transpose[mat] . mat ]},
	Orthogonalize @ Pick[ es[[2]] , (# <= tol&) /@ es[[1]] ]
] /; MatrixQ[ mat , NumericQ ]*)

zeroModes[ mat_, tol_ ] := NullSpace[ mat , Tolerance -> tol]


(*
	linearMotions[m, constraint matrix] finds the right null space of the constraint matrix provided and
	collects results into a displacement vector {{dx, dy,dz}, ...} or {{dx,dy}, ... }
	
	this is really just a wrapper for zeroModes.
*)
linearMotions[ m_ , rigidityMatrix_ , tol_ ]:=
Module[{dim = MechanismEmbeddingDimension[m], lin = zeroModes[rigidityMatrix, tol]},
	If[Length[lin]>0,
		Partition[ Orthogonalize[lin], {1,dim} ][[ All, All, 1 ]],
		{}
	]
]


Options[MechanismConstraintMatrix] = {
	Constraints -> None, 
	CellPattern -> _ , 
	(*Tolerance for deciding if a mechanism is stressed*)
	Tolerance -> 10^(-6) , 
	(*eliminate any constraints that are linear by solving for them directly*)
	ReduceLinearConstraints -> False
};

(*argument checkers*)
reduceQ[_?BooleanQ] := True
reduceQ[ _ ] := (Message[MechanismConstraintMatrix::red]; False)

smallestStressQ[ _?(NumericQ[#] && # >= 0 &) ] := True
smallestStressQ[ _ ] := (Message[MechanismConstraintMatrix::st]; False)

(*error messages*)
MechanismConstraintMatrix::red="Option ReduceLinearConstraints should be Boolean.";
MechanismConstraintMatrix::stressed="Warning: Mechanism is stressed. Constraint matrix may not be useful.";
MechanismConstraintMatrix::arbitrarystress="Assuming mechanism is not stressed.";
MechanismConstraintMatrix::nomat="Failed to find constrained cells.";
MechanismConstraintMatrix::st="Option Tolerance, which sets threshold for stress to be zero, must be a number greater than or equal to 0.";
MechanismConstraintMatrix::pos="Positions `1` do not correspond to mechanism.";

MechanismConstraintMatrix[ m_?MechanismQ , opt : OptionsPattern[] ] := 
With[ {res = MechanismConstraintMatrix[ Deformed[ m, m["VertexCoordinates"]], opt ]},
	res /; Head[res] =!= MechanismConstraintMatrix
]

MechanismConstraintMatrix[ Deformed[ m_?MechanismQ , actualPositions_ ], OptionsPattern[] ] :=
	With[ {
		arrays = rigidityMatrix[m , actualPositions, OptionValue[Constraints] , OptionValue[CellPattern] , OptionValue[ReduceLinearConstraints] ],
		smallestStress = OptionValue[Tolerance]
		},
		Switch[ stressedQ[arrays , smallestStress],
			True, Message[MechanismConstraintMatrix::stressed]; arrays[[2]],
			False, arrays[[2]],
			"analytic", Message[MechanismConstraintMatrix::arbitrarystress]; arrays[[2]],
			$Failed, Message[MechanismConstraintMatrix::nomat]; {{}}
		] /; smallestStressQ[ smallestStress ] && reduceQ[ OptionValue[ReduceLinearConstraints] ]
	] /; VertexCoordinatesQ[m, actualPositions]

MechanismConstraintMatrix[ Deformed[ m_?MechanismQ, pos_], ___] := "nothing" /; Message[ MechanismConstraintMatrix::pos , pos ]


(*
Implementation notes:
  For machine size numerical positions, zero modes and self stresses have eigenvalues smaller than option Tolerance.
*)


Options[MechanismZeroModes] = {Constraints -> None, CellPattern -> _, Tolerance->10^(-10)};

MechanismZeroModes::stressed="Warning: Mechanism is stressed. Constraint matrix may not be useful.";
MechanismZeroModes::nomat="Failed to find constrained cells.";
MechanismZeroModes::st="Option Tolerance, which sets threshold for stress to be zero, must be a number greater than or equal to 0.";
MechanismZeroModes::pos="Positions of dimensions `1` do not seem to conform to mechanism.";

zmtolQ[ _?(NumericQ[#] && # >= 0 &) ] := True
zmtolQ[ _ ] := (Message[MechanismZeroModes::st]; False)

zmposQ[ m_ , pos_ ] := True /; VertexCoordinatesQ[m,pos]
zmposQ[ m_, pos_ ] := (Message[MechanismZeroModes::pos, Dimensions[pos]]; False)

MechanismZeroModes[ m_?MechanismQ , opt : OptionsPattern[] ] := With[ {res= MechanismZeroModes[ Deformed[ m , m["VertexCoordinates"]],opt ]},
	res /; Head[res] =!= MechanismZeroModes ]

MechanismZeroModes[ Deformed[ m_?MechanismQ, actualPositions_ ], opt : OptionsPattern[]] :=
Module[{rm},With[
{
	tolerance = OptionValue[Tolerance],
	dim = MechanismEmbeddingDimension[m]
},(
	rm = rigidityMatrix[m, actualPositions, OptionValue[Constraints], OptionValue[CellPattern], False ];
	Map[Partition[#,dim]& , Switch[ stressedQ[rm, tolerance],
		True, Message[MechanismZeroModes::stressed]; zeroModes[ rm[[2]], tolerance ],
		False, zeroModes[ rm[[2]], tolerance ],
		$Failed, Message[MechanismZeroModes::nomat]; IdentityMatrix[Length[Flatten @ actualPositions]]
	] ] ) /; zmtolQ[ tolerance ] && zmposQ[ m , actualPositions ]
]] /; VertexCoordinatesQ[m , actualPositions]

MechanismZeroModes[ Deformed[ m_?MechanismQ, actualPositions_ ], opt : OptionsPattern[]] :=
	"nothing" /; Message[MechanismZeroModes::pos, actualPositions]

MechanismZeroModes::pos = "Positions `1` do not correspond to mechanism.";


Options[MechanismSelfStresses] = {Constraints -> None, CellPattern -> _, Tolerance->10^(-10)};

MechanismSelfStresses::stressed="Warning: Mechanism is stressed. Constraint matrix may not be useful.";
MechanismSelfStresses::nomat="Failed to find constrained cells.";
MechanismSelfStresses::st="Option Tolerance, which sets threshold for stress to be zero, must be a number greater than or equal to 0.";
MechanismSelfStresses::pos="Positions of dimensions `1` do not seem to conform to mechanism.";
MechanismSelfStresses::num="For non-numerical positions, MechanismSelfStresses[] may not always return all values.";

sstolQ[ _?(NumericQ[#] && # >= 0 &) ] := True
sstolQ[ _ ] := (Message[MechanismSelfStresses::st]; False)

ssposQ[ m_ , pos_ ] := (If[ Not @ MatrixQ[ pos, NumericQ], Message[MechanismSelfStresses::num]]; True) /; VertexCoordinatesQ[m,pos]
ssposQ[ m_, pos_ ] := (Message[MechanismSelfStresses::pos, Dimensions[pos]]; False)

MechanismSelfStresses[ m_?MechanismQ , opt : OptionsPattern[] ] := 
With[ {res= MechanismSelfStresses[ Deformed[ m , m["VertexCoordinates"]],opt ]},
	res /; Head[res] =!= MechanismSelfStresses
]

MechanismSelfStresses[ Deformed[ m_?MechanismQ, actualPositions_], opt : OptionsPattern[]] :=
Module[{rm},With[
{
	tolerance = OptionValue[Tolerance]
},(
	rm = rigidityMatrix[m, actualPositions, OptionValue[Constraints], OptionValue[CellPattern], False ];
	Switch[ stressedQ[rm, tolerance],
		True, Message[MechanismSelfStresses::stressed]; selfStresses[ rm[[2]], tolerance ],
		False, selfStresses[ rm[[2]], tolerance ],
		$Failed, Message[MechanismSelfStresses::nomat]; IdentityMatrix[Length[Flatten @ actualPositions]]
	] )/; sstolQ[ tolerance ] && ssposQ[ m , actualPositions ]
]] /; VertexCoordinatesQ[m, actualPositions]

MechanismSelfStresses[ Deformed[ m_?MechanismQ, actualPositions_ ], opt : OptionsPattern[]] :=
	"nothing" /; Message[MechanismSelfStresses::pos, actualPositions]

MechanismSelfStresses::pos = "Positions `1` do not correspond to mechanism.";


Options[MechanismInfinitesimalMotions]={Constraints->None, OutputVariables->Automatic, Tolerance -> 10^(-12) };


MechanismInfinitesimalMotions[ m_?MechanismQ, opt : OptionsPattern[]]:=
With[{
	actualPositions=m["VertexCoordinates"]
},
	Module[
		{res=mechanismInfinitesimalMotionsInternal[m,actualPositions,OptionValue[Constraints],OptionValue[OutputVariables],OptionValue[Tolerance] ]},
		res /; res=!=$Failed
	 ] /; NumericQ[ OptionValue[Tolerance] ] && OptionValue[Tolerance] >= 0
]

MechanismInfinitesimalMotions[ Deformed[m_?MechanismQ, actualPositions_], opt : OptionsPattern[]]:=
	Module[
		{res=mechanismInfinitesimalMotionsInternal[m,actualPositions,OptionValue[Constraints],OptionValue[OutputVariables],OptionValue[Tolerance] ]},
		res /; res=!=$Failed
	 ] /; NumericQ[ OptionValue[Tolerance] ] && OptionValue[Tolerance] >= 0 && NumericCoordinatesQ[m, actualPositions]

MechanismInfinitesimalMotions::failed="Failed to find an appropriate solution. Check the constraints.";
MechanismInfinitesimalMotions::pos="Positions `1` are not numeric or do not match those of Mechanism.";
MechanismInfinitesimalMotions[m_?MechanismQ,  OptionsPattern[]] := "nothing" /; (
		If[Not[NumericQ[ OptionValue[Tolerance] ] && OptionValue[Tolerance] >= 0], Message[MechanismInfinitesimalMotions::tol]];
		False
	)

MechanismInfinitesimalMotions[ Deformed[ m_?MechanismQ, positions_],  OptionsPattern[]] := "nothing" /; (
		Message[MechanismInfinitesimalMotions::pos, positions];
		If[ Not[NumericQ[ OptionValue[Tolerance] ] && OptionValue[Tolerance] >= 0], Message[MechanismInfinitesimalMotions::tol] ];
		False
	)


MechanismInfinitesimalMotions::var="Variables listed are not of the form VertexDisplacement[n,c].";
MechanismInfinitesimalMotions::sing="Jacobian matrix is singular. Recovering using generic variables.";
MechanismInfinitesimalMotions::jac="Jacobian matrix may not be invertible. Choosing different displacements may give better results.";
MechanismInfinitesimalMotions::lin="Found `1` linear motions so `1` displacements are needed.";
MechanismInfinitesimalMotions::tol="Option Tolerance must be a non-negative number.";
MechanismInfinitesimalMotions::const="Failed to obtain proper constraints: `1`.";


mechanismInfinitesimalMotionsInternal[m_,positions_,inputConstraints_,v_,tolerance_]:=
Module[{matrix,dependencies,solution},
With[{
	variables=Flatten[VertexDisplacement[m]],

	(*collect all the constraints valid to 2nd order in the displacements *)
	equations = internalConstraintMap[m, positions , 2, False, _, inputConstraints]
},
	
	(* {zeroth order, first order, 2nd order}
		If zeroth order vector is non-zero, the system has some stresses.
		first order matrix gives dependencies and zero modes.
	*)
	Quiet[matrix=CoefficientArrays[equations,variables, "Symmetric"->True]];
	If[Head[matrix] === CoefficientArrays, Message[MechanismInfinitesimalMotions::const,equations]; Return[$Failed]];
	
	(*
	Find dependencies among the linear equations.
	When the constraints arise only from edge stretching, these dependences are the self-stresses.
	
	If the self stresses happen to be numeric, go ahead and normalize them.
	Otherwise throw in a quick Simplify[] and leave as is.
	*)
	dependencies= (If[MatrixQ[#,NumericQ], Orthogonalize[#], Simplify[#] ]&) @ selfStresses[ matrix[[2]] , tolerance ];
	
	(*the linear displacements that are allowed*)
	solution = linearMotionsToDisplacementRules[m, linearMotions[m, matrix[[2]], tolerance],v];

	Which[
		solution===$Failed, $Failed,

		Length[solution]>0,
			Expand[(*analytical processing that I prefer, but should not take a long time to perform*)
				{#[[1]],Select[#[[2]],Not@PossibleZeroQ[N@#]&], #[[3]]}&[
					{
					VertexDisplacement[m],
					If[Length[dependencies]>0, dependencies . equations,{}],
					dependencies
					} /. Dispatch[solution]
				]
			],
		
		(*no solution but no errors either*)
		True,
			Message[MechanismInfinitesimalMotions::failed];
			{ConstantArray[0,Dimensions[MechanismPositions[m]]],{}, dependencies}
	]
]]


linearMotionsToDisplacementRules[m_,linearMotions_,inputDisplacements_]:={} /; Length[linearMotions]==0

linearMotionsToDisplacementRules[m_,linearMotions_,inputDisplacements_List]:=
With[
(*preprocess arguments*)
{displacements=Flatten[{inputDisplacements}]},
Module[
{x,y,c,rules,jacobianMatrix,inverseJacobian,displacementIndices},
	displacementIndices=displacements/.VertexDisplacement[x_,y_]->{x,y}/.{"x"->1,"y"->2,"z"->3};
	jacobianMatrix=linearMotions[[All,Sequence@@#]]&/@displacementIndices;
	
	(*if inverting the jacobian fails entirely, we'll need to deal with that.*)
	inverseJacobian=Check[Inverse[jacobianMatrix],
		Message[MechanismInfinitesimalMotions::sing];
		Return[linearMotionsToDisplacementRules[m,linearMotions,Automatic]],
		Inverse::sing
	];
	(*warn that the jacobian matrix is almost singular*)
	If[Abs[Det[jacobianMatrix]]<10^(-16),Message[MechanismInfinitesimalMotions::jac]];

	rules=Thread[Array[c,Length[jacobianMatrix]]->inverseJacobian . Flatten[{displacements}]];
	Thread[Flatten[VertexDisplacement[m]]->Flatten[Array[c,Length[jacobianMatrix]] . linearMotions/.rules]]

]/; Length[linearMotions]==Length[displacements]&&MatchQ[displacements,{__VertexDisplacement}] ]

linearMotionsToDisplacementRules[m_,linearMotions_,Automatic]:=Module[{v=Unique[]},
	Thread[Flatten[VertexDisplacement[m]]->Flatten[Array[v,Length[linearMotions]] . linearMotions]]
]/;Length[linearMotions]>0

linearMotionsToDisplacementRules[m_,linearMotions_,c_Symbol]:=
	Thread[Flatten[VertexDisplacement[m]]->Flatten[Array[c,Length[linearMotions]] . linearMotions]]/;Length[linearMotions]>0
	
linearMotionsToDisplacementRules[m_,linearMotions_,displacements_]:=Which[
	Not[MatchQ[Flatten[{displacements}],{__VertexDisplacement}]],
		Message[MechanismInfinitesimalMotions::var];
		$Failed,
	Length[linearMotions]!=Length[Flatten[{displacements}]],
		Message[MechanismInfinitesimalMotions::lin,Length[linearMotions]];
		$Failed,
	True,
		$Failed
]


(*
	This algorithm for prestress stabiltiy comes from
		Holmes\[Hyphen]Cerfon, Theran, and Gortler.
		"Almost\[Hyphen]Rigidity of Frameworks."
		Communications on Pure and Applied Mathematics 74, no. 10 (2021): 2185-2247.

	The function returns
		{ t , ss }
	where t < 0 implies the system is prestress stable and ss is the resulting self stress.
*)
Options[PrestressStability]={Constraints->None, Tolerance->10^(-10) };

PrestressStability[m_?MechanismQ, opt : OptionsPattern[]] := 
With[{res = internalPrestressStability[N[m], N[m["VertexCoordinates"]], {opt}]},
	res /; Head[res] =!= internalPrestressStability
]

PrestressStability[ Deformed[ m_?MechanismQ, _], OptionsPattern[] ] := "nothing" /; Message[PrestressStability::pos]
PrestressStability::pos = "Function does not support Deformed[] as it does not entirely make sense if a mechanism is stressed.";

internalPrestressStability[m_ , positions_ , opt_] :=
Module[
{
	v, linear, quadratic, dependencies, variables, eigenvals, initialSign, quadraticForms, solution
},
	{linear, quadratic, dependencies} = MechanismInfinitesimalMotions[m, Flatten[{OutputVariables->v, opt}]];
	variables = Variables[linear];

	Which[

	Length[dependencies]==0,
		{0,{}},

	True,
		quadraticForms = With[
			{tmpQuadraticForms = CoefficientArrays[#, variables, Symmetric->True][[3]]& /@ quadratic},
			If[Length[tmpQuadraticForms]==0,
				{},
			
				(*get the eigenvalues of the first quadratic form*)
				eigenvals = Chop @ Eigenvalues[ tmpQuadraticForms[[1]] ];
				Sign[Total[Sign[eigenvals]]] tmpQuadraticForms
			]
		];

		solution = SemidefiniteOptimization[
			Join[ConstantArray[0,Length[quadraticForms]-1],{1}],
			Join[quadraticForms, {IdentityMatrix[ Length[variables] ]} ]
		];
	
		{Last[solution], Normalize[Join[{1},Drop[solution,-1]]] . dependencies }
	]
] /; VertexCoordinatesQ[m,positions]

internalPrestressStability[m_, positions_ , _] := "nothing" /; Message[PrestressStability::pos, positions]
PrestressStability::pos = "The positions `1` do not correspond to the mechanism.";


Options[PrestressStableQ]={Constraints->None, Tolerance -> 10^(-10)};

PrestressStableQ[m_?MechanismQ, opt : OptionsPattern[]] := 
With[{res = internalPrestressStableQ[ N[m] , N[m["VertexCoordinates"]] , OptionValue[Tolerance] , {opt}]},
	res /; Head[res] =!= internalPrestressStableQ
]

PrestressStableQ[ Deformed[ m_?MechanismQ, _], OptionsPattern[] ] := "nothing" /; Message[PrestressStableQ::pos]
PrestressStableQ::pos = "Function does not support Deformed[] as it does not entirely make sense if a mechanism is stressed.";

internalPrestressStableQ[m_ , positions_ , tolerance_, opt_ ] :=
Module[
{
	v, linear, quadratic, dependencies, variables, eigenvals, initialSign, quadraticForms, solution
},
	{linear, quadratic, dependencies} = MechanismInfinitesimalMotions[m, Flatten[{OutputVariables->v, opt}]];
	variables = Variables[linear];

	Which[
	Length[dependencies]==0, False,
	Length[dependencies]==1, True,
	Length[variables] == 1, True,

	True,
		quadraticForms = With[
			{tmpQuadraticForms = CoefficientArrays[#, variables, Symmetric->True][[3]]& /@ quadratic},
			If[Length[tmpQuadraticForms]==0,
				{},
			
				(*get the eigenvalues of the first quadratic form*)
				eigenvals = Chop[ Eigenvalues[ tmpQuadraticForms[[1]] ], tolerance ];
				Sign[Total[Sign[eigenvals]]] tmpQuadraticForms
			]
		];

		solution = SemidefiniteOptimization[
			Join[ConstantArray[0,Length[quadraticForms]-1],{1}],
			Join[quadraticForms, {IdentityMatrix[ Length[variables] ]} ]
		];
	
		Last[solution] < 0
	]
]  /; VertexCoordinatesQ[m,positions]


Options[MechanismAugmentedConstraintMatrix] = Options[MechanismConstraintMatrix];

MechanismAugmentedConstraintMatrix[ m_?MechanismQ, pi_?PeriodicIdentificationDataQ, opt : OptionsPattern[] ] :=
With[ { res = augmentedConstraintMatrixInternal[ m , pi, {opt} ]},
	res /; MatrixQ[ res ]
]


augmentedConstraintMatrixInternal[ m_ , pi_ , options_ ] :=
Module[{
	constraints = pi["LatticeVectors" -> designArbitraryBasis[pi,"a"]]["Constraints"],
	constraintEq, variables
},
	constraintEq = MechanismConstraintMap[m, 1, Normal@Merge[{{Constraints -> constraints},options},Flatten] ];
	variables = Flatten[ {VertexDisplacement[m], Array["a", numberOfLatticeElements[ m["EmbeddingDimension"] ] ] } ];
	
	CoefficientArrays[ constraintEq , variables ][[2]]
]


numberOfLatticeElements[2] = 3;
numberOfLatticeElements[3] = 6;

designArbitraryBasis[ pi_ , name_ ] := 
Module[
{
	d = pi[ "EmbeddingDimension" ],
	basis = pi[ "LatticeVectors" ]
},
	Switch[d,
		2, { basis[[1]] + {name[1], 0} , basis[[2]] + {name[2], name[3]} },
		3, { basis[[1]] + {name[1], 0, 0} , basis[[2]] + {name[2], name[3], 0} , basis[[3]] + {name[4], name[5], name[6] }},
		_ , $Failed
	]
]


(*
MechanismStressMatrix[ m, vec ] returns a stress matrix associated with the stress vector vec. The (i,j) component of the stress matrix is the negative of the corresponding
stress vector component (and zero otherwise) and diagonal components are chosen so that rows sum to zero.

Columns should also sum to zero.

(see Connelly on generic global rigidity)
*)

MechanismStressMatrix[ m_?MechanismQ, stressVector_ ] :=
Module[ { offDiagonalComponents, diagonalComponents, edges = MechanismConnectivity[m, "vertices" -> "edges"] },
	offDiagonalComponents = 
	(
		(*symmetrize*)
		(# + Transpose[#] & )
	) @ SparseArray[ 
		Thread[ m["edges"] -> -stressVector ],
		{ m["VertexCount"], m["VertexCount"] }
	];
	diagonalComponents = SparseArray[
		Thread[ ({#,#}& /@ Range[ m["VertexCount"] ]) -> (- Total /@ Map[ offDiagonalComponents[[ #[[1]], #[[2]] ]]&, MechanismConnectivity[m, "vertices" -> "edges"] , {2} ]) ],
		{ m["VertexCount"], m["VertexCount"] }
	];
	
	offDiagonalComponents + diagonalComponents
] /; MechanismStressMatrixArgumentsQ[ m, stressVector ]

MechanismStressMatrix::svec="Stress vector is not a vector.";
MechanismStressMatrix::len="Stress vector length is not the same as the number of edges.";

MechanismStressMatrixArgumentsQ[ m_, stressVector_ ] := Which[
	Not @ VectorQ[ stressVector ] ,
		Message[MechanismStressMatrix::svec]; False,
	Length[m["edges"]] != Length[stressVector],
		Message[MechanismStressMatrix::len]; False,
	True, True
]


hamiltonianFlowQ[ d_Association ] := And[
	KeyExistsQ[d, "equations"] ,
	KeyExistsQ[d, "variables"] ,
	KeyExistsQ[d, "positions"] ,
	KeyExistsQ[d, "momenta" ]
	]

gradientFlowQ[ d_Association ] := And[
	KeyExistsQ[d, "equations"] ,
	KeyExistsQ[d, "variables"] ,
	KeyExistsQ[d, "positions"] ,
	Not[KeyExistsQ[d , "momenta"]]
	]


initialConditions[ flow_ , {initialPositions_, initialMomenta_} ] :=
	With[ {
		pos = DeleteCases[ Thread[Flatten[flow["positions"]] -> Flatten[initialPositions]], 0 -> _ ],
		mom = DeleteCases[ Thread[Flatten[flow["momenta"]] -> Flatten[initialMomenta]], 0 -> _ ]
	}, 
	flow["variables"] /. Join[ pos, mom ]
	] /; KeyExistsQ[ flow, "momenta" ] && Dimensions[ initialPositions ] == Dimensions[ initialMomenta ] == Dimensions[ flow["positions"] ]

initialConditions[ flow_ , initialPositions_ ] :=
	With[ {
		pos = DeleteCases[ Thread[Flatten[flow["positions"]] -> Flatten[initialPositions]], 0 -> _ ]
	}, 
	flow["variables"] /. pos
	] /; Not[KeyExistsQ[flow, "momenta"]] && Dimensions[ initialPositions ] == Dimensions[ flow["positions"] ]

initialConditions[ flow_ , _ ] := $Failed


Options[MechanismHamiltonianFlow]=
Join[
	{
	VertexMass->1,
	VertexDrag->0,
	AddedEnergy->0 (*additional terms to add to the energy*)
	},
	FilterRules[ Options[MechanismEnergy], Except[ReduceLinearConstraints] ]
];

vertexMassQ[ mass_?NumericQ , vertexNumber_ ] := If[ TrueQ[mass > 0], True, Message[MechanismHamiltonianFlow::mass , vertexNumber]; False ]
vertexMassQ[ mass_?(VectorQ[#,NumericQ[#]&&#>0&]&) , vertexNumber_ ] := If[ TrueQ[Length[mass] == vertexNumber], True, Message[MechanismHamiltonianFlow::mass , vertexNumber]; False]
vertexMassQ[ _ , vertexNumber_ ] := (Message[MechanismHamiltonianFlow::mass , vertexNumber]; False)

vertexDragQ[ drag_?NumericQ, vertexNumber_ ] := If[ TrueQ[ drag >= 0], True, Message[MechanismHamiltonianFlow::drag , vertexNumber]; False ]
vertexDragQ[ drag_?(VectorQ[#,NumericQ[#]&&#>=0&]&) , vertexNumber_ ] := If[ TrueQ[Length[drag] == vertexNumber], True, Message[MechanismHamiltonianFlow::drag , vertexNumber]; False]
vertexDragQ[ _ , vertexNumber_ ] := (Message[MechanismHamiltonianFlow::drag , vertexNumber]; False)

MechanismHamiltonianFlow::mass="Mass should be a positive number of a list of masses of length `1`";
MechanismHamiltonianFlow::drag="Drag should be a non-negative number of a list of drags of length `1`";

MechanismHamiltonianFlow[ m_?MechanismQ,  opt : OptionsPattern[] ] :=
Module[
{
	masses = N @ OptionValue[VertexMass],
	drag = N @ OptionValue[VertexDrag]
},
	hamiltonianFlow[ m , masses , drag , Mechanisms`geometry`Private`MechanismGeometricExpression[m,OptionValue[AddedEnergy]], FilterRules[{opt},Options[MechanismEnergy]] ] /; vertexMassQ[ masses, m["VertexCount"]] && vertexDragQ[ drag, m["VertexCount"] ]
]


(*
hamiltonianFlowVector[mechanism, {vertex variables, momentum/velocity variables}, masses, options for MechanismEnergy[] 

Note that we have allowed the possibility of drag, for which:
	D[p,t] == - V'[x] - \[Gamma] p
	D[x,t] == p/m

This gives the ODE D[x,{t,2}] == -V'[x]/m - \[Gamma] p/m == -V'[x]/m - \[Gamma] D[x,t]
*)
hamiltonianFlow[ m_, mass_, drag_ , addedEnergy_ , opt_ ] :=
Module[{
	unfixedVertices = VertexPosition[m],
	linearRules = Dispatch @ MechanismLinearConstraints[m, FilterRules[opt,Options[MechanismLinearConstraints]]], 
	energy = MechanismEnergy[ N[m], opt] + N[addedEnergy],
	gradient, momentum,
	v,p
},
	{v,p} = standardVariableNames[m];
	(*which vertices are fixed?*)
	unfixedVertices = Cases[ Flatten[unfixedVertices /. linearRules], _VertexPosition ];

	gradient = - renameVertexVariables[ v , D[ (energy /. linearRules) ,{unfixedVertices}] ] - renameVertexVariables[ p, unfixedVertices];
	momentum = renameVertexVariables[ p , unfixedVertices]/mass;

	Association[
		"positions" -> renameVertexVariables[ v , VertexPosition[m] /. linearRules ],
		"momenta" -> renameVertexVariables[ p , VertexPosition[m] /. linearRules ], 
		"variables" -> Join[ renameVertexVariables[ v , unfixedVertices ], renameVertexVariables[ p , unfixedVertices ] ],
		"equations" -> Flatten[{momentum,gradient}]
	]
]


Options[MechanismGradientFlow] =
	Join[
	{
		AddedEnergy->0 (*additional terms to add to the energy*)
	},
		FilterRules[ Options[MechanismEnergy], Except[ReduceLinearConstraints] ]
	];

MechanismGradientFlow[ m_?MechanismQ , opt : OptionsPattern[] ] :=
	gradientFlow[ m , Mechanisms`geometry`Private`MechanismGeometricExpression[m,OptionValue[AddedEnergy]] , FilterRules[{opt},Options[MechanismEnergy]] ]


gradientFlow[ m_, addedEnergy_ , opt_ ] :=
Module[{
	unfixedVertices = VertexPosition[m],
	linearRules = Dispatch @ MechanismLinearConstraints[m, FilterRules[opt,Options[MechanismLinearConstraints]]], 
	energy = MechanismEnergy[ N[m], opt] + N[addedEnergy],
	gradient, momentum,
	v,p
},
	{v,p} = standardVariableNames[m];
	(*which vertices are fixed*)
	unfixedVertices = Cases[ Flatten[unfixedVertices /. linearRules], _VertexPosition ];

	gradient = - renameVertexVariables[ v , D[ (energy /. linearRules) ,{unfixedVertices}] ];

	Association[
		"positions" -> renameVertexVariables[ v , VertexPosition[m] /. linearRules ],
		"variables" -> Join[ renameVertexVariables[ v , unfixedVertices ] ],
		"equations" -> Flatten[gradient]
	]
]


MechanismNDSolve[ d_ , initialC_ , {t_, tstart_, tend_} ] :=
	Module[
	{
		positions = (#[t]& /@ d["variables"]),
		velocities = (#'[t]& /@ d["variables"]),
		initial = initialConditions[ d, initialC ]
	},
		With[{
			res = NDSolve[ 
				Join[
					(*actual equations*)
					Thread[velocities == (d["equations"] /. Thread[d["variables"] -> positions])],
					(*initial conditions*)
					Thread[(positions /. t->tstart) == initial]
				],
				d["variables"],
				{t, tstart, tend}
			]
		},
			(d["positions"] /. First[res]) /; ListQ[res]
		] /; If[initial === $Failed, Message[MechanismNDSolve::init, initialConditions]; False, True]
	] /; hamiltonianFlowQ[d] || gradientFlowQ[d]

MechanismNDSolve[ d_ , initialC_ , {t_, tstart_, tend_, stepsize_} ] :=
	Module[
	{
		positions = (#[t]& /@ d["variables"]),
		velocities = (#'[t]& /@ d["variables"]),
		initial = initialConditions[ d, initialC ],
		range = List /@ Thread[t -> Range[ tstart, tend, stepsize ]]
	},
		With[{
			res = NDSolve[
					Join[
						(*actual equations*)
						Thread[velocities == (d["equations"] /. Thread[d["variables"] -> positions])],
						(*initial conditions*)
						Thread[(positions /. t->tstart) == initial]
					],
					d["variables"],
					{t, tstart, tend}
				]
		},
		((d["positions"] /. Thread[ d["variables"] -> (positions /. First[res]) ]) /. range) /; ListQ[res]

		] /; If[initial === $Failed, Message[MechanismNDSolve::init, initialConditions]; False, True]
	] /; hamiltonianFlowQ[d] || gradientFlowQ[d]

MechanismNDSolve::init= "Could not resolve initial conditions `1` for this flow.";


MechanismItoProcess[ d_?hamiltonianFlowQ , noise_ , {initialPositions_?VertexCoordinatesQ, initialMomenta_?VertexCoordinatesQ} , {t_, tstart_, tend_, stepsize_} ] :=
	With[ {noiseVector = Join[ ConstantArray[0, Length[d["variables"]]/2], ConstantArray[noise, Length[d["variables"]]/2] ]},		
		With[ {process = ItoProcess[
							{ d["equations"], noiseVector}, 
							{d["variables"],initialConditions[d, {initialPositions, initialMomenta}]}, 
							{t, tstart}
			]},
			With[ {res = RandomFunction[ process , {tstart, tend, stepsize}]},
				(d["positions"] /. (Thread[d["variables"] -> # ]& /@ res["Paths"][[1,All,2]]) ) /; Head[res] =!= RandomFunction
		]]
	] /; Dimensions[d["positions"]] == Dimensions[initialPositions] == Dimensions[initialMomenta]

MechanismItoProcess[ d_?gradientFlowQ , noise_ , initialPositions_?VertexCoordinatesQ , {t_, tstart_, tend_, stepsize_} ] :=
	With[ {noiseVector = ConstantArray[noise, Length[d["variables"]] ]},		
		With[ {process = ItoProcess[
							{ d["equations"], noiseVector}, 
							{d["variables"],initialConditions[d, initialPositions]}, 
							{t, tstart}
			]},
			With[ {res = RandomFunction[ process , {tstart, tend, stepsize}]},
				(d["positions"] /. (Thread[d["variables"] -> # ]& /@ res["Paths"][[1,All,2]]) ) /; Head[res] =!= RandomFunction
		]]
	] /; Dimensions[d["positions"]] == Dimensions[initialPositions]

MechanismItoProcess[ d_, _, initial_, _] := "nothing" /; Message[MechanismItoProcess::init, initial]

MechanismItoProcess::init= "Could not resolve initial conditions `1` for this flow.";


Options[MetropolisEnergy] = FilterRules[ Options[MechanismEnergy], Except[ReduceLinearConstraints] ];

MetropolisEnergy[m_?MechanismQ, opt : OptionsPattern[] ] :=
Module[{
	energy, linearRules, v,
	unfixedVertices, variables,
	compiledEnergy
},
	v = standardVariableNames[m];
	linearRules = MechanismLinearConstraints[ m , FilterRules[{opt}, Options[MechanismLinearConstraints] ]];
	unfixedVertices = Cases[ Flatten[VertexPosition[m] /. linearRules], _VertexPosition ];
	variables = renameVertexVariables[ v[[1]] , unfixedVertices ];
	energy = renameVertexVariables[ v[[1]], MechanismEnergy[ m , opt ] /. linearRules ];
	compiledEnergy = Compile @@ { variables , energy , CompilationTarget -> $MechanismCompilationTarget};

	Association[
		"positions" -> renameVertexVariables[ v[[1]] , VertexPosition[m] /. linearRules ],
		"variables" -> variables,
		"energy" -> energy,
		"compiled energy" -> compiledEnergy
	]
]

metropolisEnergyQ[ d_Association] := And[ KeyExistsQ[ d, "positions"] , KeyExistsQ[ d, "energy"] , KeyExistsQ[ d, "compiled energy"] ]


Options[ MechanismMetropolis ] := {
	WorkingPrecision -> MachinePrecision , 
	Distribution -> NormalDistribution[0,1/10]
	} ;

MechanismMetropolis[ d_?metropolisEnergyQ , positions_?VertexCoordinatesQ , inverseTemperature_?inverseTemperatureQ , {initialSteps_?stepNumberQ, steps_?stepNumberQ} , opt : OptionsPattern[] ] :=
Module[{
	oldEnergy, newEnergy,
	random,
	compiledEnergy = d["compiled energy"],
	initialState = d["variables"] /. DeleteCases[ Thread[Flatten[d["positions"]] -> Flatten[ positions ]], 0 -> _ ],
	stateAfterSkipping,
	output
},
	(*initialize the first set of random displacements*)
	random = RandomVariate[ OptionValue[Distribution], {initialSteps - 1, Length[d["variables"]]}, WorkingPrecision -> OptionValue[WorkingPrecision] ];
	(*if all worked, run the metropolis algorithm a bunch of times and just remember the last value*)
	stateAfterSkipping = If[Head[random] =!= RandomVariate,
		Fold[
			With[{ e = compiledEnergy @@ (#1[[2]]+#2)}, If[ RandomReal[] < Exp[ N[inverseTemperature ( #1[[1]] - e)]] , {e , #1[[2]]+#2}, #1 ] ] &,
			{ compiledEnergy @@ initialState , initialState } ,
			random
		],
		{ compiledEnergy @@ initialState , initialState }
	];

	(*initialize the second set of random displacements*)
	random = RandomVariate[ OptionValue[Distribution], {steps - 1, Length[d["variables"]]}, WorkingPrecision -> OptionValue[WorkingPrecision] ];
	(*if all worked, run the metropolis algorithm a bunch of times and remember all positions*)
	output = If[ Head[random] =!= RandomVariate,
		FoldList[
			With[{ e = compiledEnergy @@ (#1[[2]]+#2)}, If[ RandomReal[] < Exp[ N[inverseTemperature ( #1[[1]] - e)]] , {e,#1[[2]]+#2}, #1 ] ] &,
			stateAfterSkipping ,
			random
		],
		stateAfterSkipping
	];
	
	d["positions"] /. (Thread[d["variables"] -> #]& /@ output[[All,2]])

] /; metropolispositionsQ[ d["positions"] , positions ]


inverseTemperatureQ[ t_?(TrueQ[Positive[#]] &) ] := True
inverseTemperatureQ[ t_ ] := (Message[MechanismMetropolis::t, t]; False)
metropolispositionsQ[ pos1_, pos2_ ] := Which[ 
	Not[NumericCoordinatesQ[ pos2 ]], Message[MechanismMetropolis::npos, pos2]; False,
	Dimensions[pos1] != Dimensions[pos2], Message[MechanismMetropolis::pos, pos2]; False, 
	True, True]
stepNumberQ[ s_Integer?Positive ] := True
stepNumberQ[ s_ ] := (Message[MechanismMetropolis::steps, s]; False)

MechanismMetropolis::t = "Inverse temperature `1` should be a positive numeric value.";
MechanismMetropolis::pos = "Positions `1` does not agree with mechanism energy.";
MechanismMetropolis::npos = "Positions `1` are not numeric.";
MechanismMetropolis::steps= "Number of steps `1` should be a positive integer.";


(*
mechanismConstraintMatrixFunction[ mechanism ]

returns a compiled function that can take numerical positions and return the constraint matrix. This is used to speed up
	other functions that do this repeatedly, like MechanismIsometricTrajectory[].
*)
Options[mechanismConstraintMatrixFunction]={ Constraints -> None, CellPattern -> _, ReduceLinearConstraints -> False , "options" -> {} };

mechanismConstraintMatrixFunction[ m_ , opt : OptionsPattern[] ] := 
Module[ {
	constraintMatrix, arrays, vars , 
	symb = Array[Unique["x"]&,Length[Flatten[VertexPosition[m]]]], map, 
	positions = VertexPosition[m], f, p = Unique[]
	},
	arrays = rigidityMatrix[m, positions, OptionValue[Constraints], OptionValue[CellPattern], OptionValue[ReduceLinearConstraints] ];
	(*we're not going to report errors*)
	constraintMatrix = Switch[ stressedQ[arrays, 1],
		$Failed, {{}},
		_, arrays[[2]]
	];
	map=Dispatch@Thread[Flatten[positions]->symb];
	Compile @@ { symb, Normal@constraintMatrix /. map, If[ Length[OptionValue["options"]] == 0 , Nothing , OptionValue["options"] ] }
]


(*
	take a step in a constrained trajectory problem.
	If the provided energy is outside the tolerance specified, it will optimize the energy.
	
	constrainedTrajectoryStep[ {method , stepsize , tolerance} , m ,
		{current position , last direction},
		step number , 
		{constraint matrix , options for NullSpace[] }
		{ energy to minimize over , {flattened vertex positions satisfying any constraints, named variables to minimize over}, options for minimization }
	]
	
	Returns {new positions , direction we just stepped in}
*)
constrainedTrajectoryStep[ _,_,{$Failed, _},_,_]:={$Failed, $Failed}

(*standard Euler integration method. Never minimize.*)
constrainedTrajectoryStep[ {"Euler", stepsize_,tolerance_}, m_, {positions_,lastDirection_}, n_, 
	{constraintMat_, nullspaceOptions_}, 
	{constraintEnergy_, constraintData_, minimizationOptions_}
] :=
Module[
{
	newDirection = projectTrialDirection[positions, lastDirection, constraintMat, nullspaceOptions ]
},
	{
		computeTrialPosition[ positions, newDirection, stepsize, n ],
		newDirection
	}
]

(*RungeKutta with minimization if needed*)
constrainedTrajectoryStep[ {"RungeKutta", stepsize_,tolerance_},m_,{positions_,lastDirection_}, n_, {constraintMat_, nullspaceOptions_}, 
	{constraintEnergy_, constraintData_, minimizationOptions_} ] :=
Module[{k1, k2, k3, k4, k5, trialPosition},
	k1 = projectTrialDirection[ positions , lastDirection, constraintMat, nullspaceOptions ];
	k2 = projectTrialDirection[ positions + stepsize k1/2, lastDirection, constraintMat, nullspaceOptions ];
	k3 = projectTrialDirection[ positions + stepsize k2/2, lastDirection, constraintMat, nullspaceOptions ];
	k4 = projectTrialDirection[ positions + stepsize k3, lastDirection, constraintMat, nullspaceOptions ];
	k5 = (k1+2 k2 + 2 k3+k4)/6;
	trialPosition = positions + stepsize k5;
	{
		If[ evaluateEnergy[m, trialPosition, constraintEnergy] > tolerance,
			correctTrialPosition[m, trialPosition, constraintEnergy, constraintData, minimizationOptions],
			trialPosition
		],
		k5/Norm[Flatten[k5]]
	}
]

(*Euler step with minimization when necessary*)
constrainedTrajectoryStep[ {"Minimization", stepsize_, tolerance_} , m_, {positions_, lastDirection_}, n_, {constraintMat_, nullspaceOptions_}, 
	{constraintEnergy_, constraintData_, minimizationOptions_} ] :=
Module[
{
	newDirection = projectTrialDirection[ positions, lastDirection, constraintMat, nullspaceOptions ],
	trialPosition
},
	trialPosition = computeTrialPosition[ positions, newDirection, stepsize, n ];
	{
		If[ evaluateEnergy[m, trialPosition, constraintEnergy] > tolerance,
			correctTrialPosition[m, trialPosition, constraintEnergy, constraintData, minimizationOptions],
			trialPosition
		],
		newDirection
	}
]

(*take a random walk step in an allowed direction*)
constrainedTrajectoryStep[ {"RandomWalk", stepsize_, tolerance_} , m_, {positions_, lastDirection_}, n_, {constraintMat_, nullspaceOptions_}, 
	{constraintEnergy_, constraintData_, minimizationOptions_} ] :=
Module[
{
	newDirection = projectTrialDirection[ positions, RandomDisplacements[m], constraintMat, nullspaceOptions ],
	trialPosition
},
	trialPosition = computeTrialPosition[ positions, newDirection, stepsize, n ];
	{
		If[ evaluateEnergy[m, newDirection, constraintEnergy] > tolerance,
			correctTrialPosition[m, trialPosition, constraintEnergy, constraintData, minimizationOptions],
			trialPosition
		],
		newDirection
	}
]


(*
given a trial position, performa minimization to get back to the constraint surface

you can pass this either a CompiledMechanismEnergy or an analytic expression in terms of VertexPosition[]
*)
correctTrialPosition[ m_, trialPosition_ , constraintEnergy_, constraintData_ , minimizationOptions_ ] :=
	minimizeEnergy[constraintEnergy, constraintData, trialPosition, minimizationOptions][[2]]


(* returns a normalized displacement tangent to the configuration space and as close to trialDirection as possible *)
projectTrialDirection[ positions_ , trialDirection_, constraintMat_ , nullspaceOptions_ ] :=
With[ {
nullspaceBasis = Orthogonalize[ NullSpace[constraintMat, nullspaceOptions ] ]
},
	If[ Length[nullspaceBasis] > 0,
		ArrayReshape[
			Normalize[Transpose[nullspaceBasis] . nullspaceBasis . Flatten[trialDirection]],
			Dimensions[positions]
		],

		Message[Mechanism::dirns , positions];
		ConstantArray[ 0, Dimensions[positions] ]
	]
]

Mechanism::dirns="Cannot identify tangent space at `1`.";
Mechanism::stepsize = "Stepsize should be a function of positions or a positive real number.";


(* find a new set of positions from a trial step *)
computeTrialPosition[ positions_ , trialStep_ , stepsize_?NumericQ, n_ ] := 
		If[ stepsize >= 0,
			positions + stepsize trialStep,

			Message[ MechanismIsometricTrajectory::stepsize ];
			$Failed
		]

computeTrialPosition[ positions_ , trialStep_ , stepsize_, n_ ] :=
With[ { actualSize = stepsize[positions,n] },
	If[ NumericQ[ actualSize ] && actualSize >= 0,
		positions + actualSize trialStep,

		Message[ Mechanism::stepsize ];
		$Failed
	]
]


Options[ MechanismIsometricTrajectory ] := {
	(*any constraints added by the user*)
	Constraints -> None,
	(*positions from which to start the walk*)
	InitialPositions -> Automatic,
	Method -> {"Minimization", MaxIterations -> 10^4},
	Tolerance -> 10^(-8),
	StepSize -> 0.1,
	StoppingCriteria -> None
};


MechanismIsometricTrajectory[m_?MechanismQ, direction_, steps_?stepsQ , opt : OptionsPattern[] ] :=
With[{
	initialPositions = If[ OptionValue[InitialPositions] === Automatic, m["VertexCoordinates"], OptionValue[InitialPositions] ]
},
	With[{
		res = mechanismIsometricTrajectoryInternal[m, 
			(*initial positions and direction*)
			initialPositions, direction, 
			(*data to decide on how to choose step size*)
			{steps, OptionValue[StepSize], OptionValue[Tolerance], stoppingcriteriaQ[MechanismPositions[m],direction,OptionValue[StoppingCriteria]]}, 
			(*what method to use to take a step*)
			Flatten[{OptionValue[Method]}],
			mobileVariables[ m, MechanismConstraintMap[m, Constraints -> OptionValue[Constraints] , ReduceLinearConstraints -> False] ],
			{opt}
		]
	},
		ToPackedArray[N[res]] /; Head[res] =!= mechanismIsometricTrajectoryInternal
	] /; And[ positionsQ[m, initialPositions] , displacementsQ[m, direction] , toleranceQ[ OptionValue[Tolerance] ] ]
]

stepsQ[ steps_Integer?(#>0&) ] := True
stepsQ[ steps_ ] := (Message[MechanismIsometricTrajectory::steps]; False)

toleranceQ[ tol_?(NumericQ[#]&&#>=0&) ] := True
toleranceQ[ tol_ ] := (Message[MechanismIsometricTrajectory::tol]; False)

positionsQ[ m_ , positions_ ] := If[ NumericCoordinatesQ[m,positions], True, Message[MechanismIsometricTrajectory::pos,positions]; False]
displacementsQ[ m_ , positions_ ] := If[ NumericCoordinatesQ[m,positions], True, Message[MechanismIsometricTrajectory::disp,positions]; False]

stoppingcriteriaQ[ pos_, dir_ , None] := None
stoppingcriteriaQ[ pos_, dir_ , stopfunc_] := If[ BooleanQ[stopfunc[pos,dir]], stopfunc, Message[MechanismIsometricTrajectory::sc2]; stopfunc]

MechanismIsometricTrajectory::steps="Number of steps is not a positive integer.";
MechanismIsometricTrajectory::tol = "Tolerance should be a positive real number.";
MechanismIsometricTrajectory::stepsize = "Stepsize should be a function of positions or a positive real number.";
MechanismIsometricTrajectory::pos = "Initial positions `1` should be numerical and correspond to Mechanism..";
MechanismIsometricTrajectory::disp = "Initial displacements `1` should be numerical and correspond to Mechanism..";
MechanismIsometricTrajectory::sc = "Option StoppingCriteria is not a function or the keyword None.";
MechanismIsometricTrajectory::sc2 = "Function provided to StoppingCriteria does not return True or False.";


mechanismIsometricTrajectoryInternal[ m_, 
	initialPositions_, direction_, 
	{steps_, stepsize_, tolerance_,stoppingcriteria_}, 
	{method_ , methodSpec___} , 
	constraintData_,
	options_ ] :=
With[
{
	minimizationOptions = FilterRules[ {methodSpec}, Options[FindMinimum] ],
	nullspaceOptions = FilterRules[ {methodSpec}, Options[NullSpace] ],

	(*normalize the initial direction*)
	normalizedDirection = direction/Sqrt[Flatten[direction] . Flatten[direction] ],

	(*function to determine local constraints*)
	constraintMatrixFunc = mechanismConstraintMatrixFunction[ m , FilterRules[ options, Options[mechanismConstraintMatrixFunction] ]],
	(*function to minimize*)
	energyFunc = MechanismEnergy[m , FilterRules[ options, Options[MechanismEnergy] ] ],
	dim = Length[initialPositions[[1]]]
},
	Partition[#,dim]&/@ Which[

	constraintMatrixFunc === $Failed, {},

	(*no stopping criteria selected means we go until we run out of steps*)
	stoppingcriteria === None,
		DeleteCases[
			FoldList[
				constrainedTrajectoryStep[ {method, stepsize, tolerance}, m, 
					#1, #2, 
					{ Quiet[constraintMatrixFunc @@ Flatten[#1[[1]]]] , nullspaceOptions }, 
					{energyFunc , constraintData, minimizationOptions} 
				] &,
				{Flatten@initialPositions,normalizedDirection},
				Range[steps]
			][[All,1]],
			$Failed
		],
	(*the stepping criteria is a function*)
	Head[stoppingcriteria] === Function,
		DeleteCases[
			FoldWhileList[
				constrainedTrajectoryStep[ {method, stepsize, tolerance}, m,
				 #1, #2, 
				 { Quiet[constraintMatrixFunc @@ Flatten[#1[[1]]]] , nullspaceOptions }, 
				 {energyFunc , constraintData, minimizationOptions} ] &,
				{Flatten@initialPositions,normalizedDirection},
				Range[steps],
				stoppingcriteria[ #[[1]],#[[2]] ]&
			][[All,1]],
			$Failed
		],
	(*same as no stopping criteria but with an error message; repeating this is kind of a silly kludge but what's the harm?*)
	True,
		Message[MechanismIsometricTrajectory::sc];
		DeleteCases[
			FoldList[
				constrainedTrajectoryStep[ {method, stepsize, tolerance}, m, 
				#1, #2, 
				{ Quiet[constraintMatrixFunc @@ Flatten[#1[[1]]]] , nullspaceOptions }, 
				{energyFunc , constraintData, minimizationOptions} ] &,
				{Flatten@initialPositions,normalizedDirection},
				Range[steps]
			][[All,1]],
			$Failed
		]
	]
]


Options[MechanismFindMinimalTrajectory]={
	AddedEnergy->0,
	Constraints->None,
	Method->{"ElasticBand", MaxIterations->10^5, "Stiffness" -> 10^(-4)}
};


MechanismFindMinimalTrajectory["Methods"]={{"ElasticBand", Join[{"Stiffness"->10^(-4)},"Options[FindMinimum]"]}};

MechanismFindMinimalTrajectory[ m_?MechanismQ, start_, end_, steps_, opt : OptionsPattern[] ]:=
Module[{method = Flatten[{OptionValue[Method]}], res},
	res = Switch[First[method],
		"ElasticBand",
			MechanismFindMinimalTrajectoryElasticBand[m, start, end, steps, MechanismEnergy[m, Constraints->OptionValue[Constraints]]+Mechanisms`geometry`Private`MechanismGeometricExpression[m,OptionValue[AddedEnergy]], Sequence @@ Rest[method] ],
		_,
			Message[MechanismFindMinimalTrajectory::meth];
			$Failed
	];
	
	res /; res =!= $Failed
]

MechanismFindMinimalTrajectory::method="`1` is not a recognized method. Only \"ElasticBand\" is currently recognized.";


MechanismFindMinimalTrajectory::ebstiff="Stiffness in \"ElasticBand\" method must be a positive numerical value.";
MechanismFindMinimalTrajectory::ebstart="Start positions are not numeric coordinates corresponding to Mechanism.";
MechanismFindMinimalTrajectory::ebend="End positions are not numeric coordinates corresponding to Mechanism.";
MechanismFindMinimalTrajectory::steps="Number of steps should be a positive integer.";

ClearAll[MechanismFindMinimalTrajectoryElasticBand];
Options[MechanismFindMinimalTrajectoryElasticBand]=Join[{"Stiffness"->10^(-4)},Options[FindMinimum]];

MechanismFindMinimalTrajectoryElasticBand[m_, startPositions_,endPositions_, steps_, energy_, opt : OptionsPattern[]]:=
Module[{
stiffness = OptionValue["Stiffness"],
fixedVertices = solveLinearEquations[MechanismConstraintMap[m,startPositions], Flatten[VertexPosition[m]] ], 
variable, internalVariables, partialEnergy, newVariables, potentialEnergy, initialConditions,
minimizationOptions = FilterRules[{opt},Options[FindMinimum]], solution
},

	Which[
		Not[ NumericQ[stiffness] && stiffness > 0 ],
			Message[MechanismFindMinimalTrajectory::ebstiff]; Return[$Failed],
		Not @ NumericCoordinatesQ[m, startPositions],
			Message[MechanismFindMinimalTrajectory::ebstart]; Return[$Failed],
		Not @ NumericCoordinatesQ[m, endPositions],
			Message[MechanismFindMinimalTrajectory::ebend]; Return[$Failed],
		Not[ IntegerQ[steps] && steps>0 ],
			Message[MechanismFindMinimalTrajectory::steps]; Return[$Failed]
	];

	internalVariables= Join[
		{PositionRules[startPositions]},
		Flatten[MapThread[ #1 -> #2&, {VertexPosition[m], #}, 2],2]& /@ Array[variable, {steps, m["VertexCount"](*MeshCellCount[m,0]*),MechanismEmbeddingDimension[m]}],
		{PositionRules[endPositions]}
	];

	newVariables = Flatten[VertexPosition[m] /. fixedVertices] /. internalVariables;

	partialEnergy = energy /. fixedVertices;

	potentialEnergy = Total @ Flatten @ {
	(*local equations*)
	(partialEnergy /. # &) /@ internalVariables,

	(*elastic band equations*)
	(stiffness (#[[2]]-#[[1]]) . (#[[2]]-#[[1]])&) /@ Partition[newVariables, 2, 1]
	};

	initialConditions = DeleteCases[ 
		Transpose @ {Flatten[ Drop[ Rest @ newVariables, -1] ], Flatten[startPositions + (endPositions - startPositions)/(steps+1) #& /@ Range[steps] ]},
		{_?NumericQ, _}
	];

	solution = FindMinimum @@ {potentialEnergy, initialConditions, minimizationOptions };
	If[Head[solution] =!= FindMinimum, Partition[#,MechanismEmbeddingDimension[m]]& /@ (newVariables /. solution[[2]]), $Failed]
]


GenericGloballyRigidQ[m_?MechanismQ] :=
Module[ {dim = m["EmbeddingDimension"], num = m["VertexCount"]},
	If[ContainsAny[MechanismCellTypes[m],{PinnedJoint, RigidBar, Spring}], Message[GenericGloballyRigidQ::more]];
	Or @@ (
		(MatrixRank[MechanismStressMatrix[m, #], Tolerance -> OptionValue[Tolerance] ] == num - dim - 1)& /@ MechanismSelfStresses[m, CellPattern->_RigidBar]
	)
]

GenericGloballyRigidQ::more="Mechanism containts more than joints, bars, and springs.";


End[];

EndPackage[];


BeginPackage["Mechanisms`Origami`"];


KawasakiQ::usage=
"KawasakiQ[\!\(\*
StyleBox[\"Origami\",\nFontSlant->\"Italic\"]\)] returns True if it can be determined that the Origami satisfies Kawasaki's theorem at each vertex.
Use option ZeroTest to modify how the function tests for zero. Use option WorkingPrecision to set a number of digits for the test.";


EquilibriumFoldAngles::usage=
"EquilibriumFoldAngles[m] returns an association containing a list of TorsionalFolds, their corresponding target angles, and their actual angles.";

PossibleFoldsQ::usage="PossibleFoldsQ[ m, {{e11, e12}, {e21, e22}, ...}] returns True if the edges are possible folds.";


TorsionalFoldMatrix::usage=
"TorsionalFoldMatrix[m] returns the TorsionalFold matrix mapping linear vertex displacements to linear TorsionalFold angle changes.";


ElasticizeOrigami::usage="ElasticizeOrigami[ o ] attempts to create an elastic model of an Origami structure.";


RandomOrigami::usage=
"RandomOrigami[ \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) ] returns random Origami with n internal vertices.";


FlatOrigamiQ::usage=
"FlatOrigamiQ[ \!\(\*
StyleBox[\"Origami\",\nFontSlant->\"Italic\"]\) ] returns True if the Origami Mechanism is flat.
Use option ZeroTest to specify how to test for zero. Use option WorkingPrecision to choose the precision.";


KreslingOrigami::usage=
"KreslingOrigami[{\!\(\*
StyleBox[\"#\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"azimuthal\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"cells\",\nFontSlant->\"Italic\"]\), #\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"of\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"rings\",\nFontSlant->\"Italic\"]\)(, \!\(\*
StyleBox[\"twist\",\nFontSlant->\"Italic\"]\))},\!\(\*
StyleBox[\"overall\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"scale\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"height\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"ratio\",\nFontSlant->\"Italic\"]\)] creates a Kresling TorsionalFold pattern of a particular radius, height, and integer twist if specified.";


MVAssignment::usage = "MVAssignment[ o (, positions), tolerance_ (, assignmentFunction)] returns a list of rules assigning a value to mountain or valley TorsionalFolds up to the value of tolerance.
The function assignmentFunction should take one of the values {-1,0,1} for valley, flat, or mountain TorsionalFolds respectively.";

FlattenOrigami::usage = "FlattenOrigami[m, tolerance] attempts to flatten an Origami structure.";


SameFoldAnglesQ::usage="SameFoldAnglesQ[ Origami, (TorsionalFolds,) (precision) ] is a function that compares the positions of two Origami structures and returns True if they have the same TorsionalFold angles.";
SameMVAnglesQ::usage="SameMVAnglesQ[ Origami, (TorsionalFolds,) (precision) ] is a function that compares the positions of two Origami structures and returns True if they have the same mountain-valley assignments.";


ButterflyDecompositionQ::usage = "ButterflyDecompositionQ[ Origami ] returns True if Origami can be decomposed into pairs of \"butterfly\" Faces.";
ButterflyDecomposition::usage = "ButterflyDecomposition[ Origami ] returns a list of \"butterfly\" Face pairs and a non-butterfly-decomposible kernel after removing butterfly Faces. You can apply MechanismDeleteDanglingVertices[] to extract the underlying Origami structure.";


DeconstructedOrigami::usage="DeconstructedOrigami[ Origami ] returns a list of vertices for polygons corresponding to the individual Faces.
Option \"edgeWeights\" allows the assignment of positive weights that allow some edges to have widths.
Option \"defaultWeight\" is the default weight on all edges.";

ExtrudedPolygon::usage="ExtrudedPolygon[coords, extrusion vector, (translation vector)] takes a Polygon and creates a 3D version.";


MVColor::usage="MVColor[ Origami, data, styleFunction] attempts to color data according to styles specified by styleFunction.";


Begin["`Private`"];

Needs["Mechanisms`"];
Needs["Mechanisms`geometry`"];
Needs["Mechanisms`rigidity`"];


Options[KreslingOrigami]=Options[Origami];


KreslingOrigami[{numTriangles_Integer,numHeight_Integer,twist_Integer:0},opt:OptionsPattern[]]:=KreslingOrigami[{numTriangles,numHeight,twist},1,1,opt]
KreslingOrigami[{numTriangles_Integer,numHeight_Integer,twist_Integer:0},radius_?NumericQ,heightScale_?NumericQ,opt:OptionsPattern[]]:=Module[{i},
With[
{
height=heightScale Sqrt[2 (Cos[Pi/numTriangles]-Cos[2 Pi/numTriangles])]
},
	Origami[
		radius Join@@Table[
			{
			Cos[2 Pi #/numTriangles+((-1)^(i-1)) Pi/numTriangles/2],
			Sin[2 Pi #/numTriangles+((-1)^(i-1)) Pi/numTriangles/2],
			(i-1) height
			}&/@Range[numTriangles],
			{i,1,numHeight+1}],
		Table[{
			Face[
				{
				#+i numTriangles,
				Mod[#+i numTriangles+1,numTriangles,i numTriangles+1],
				Mod[#+(1+(-1)^i)/2+(i+1) numTriangles+twist,numTriangles,(i+1) numTriangles+1]
				}
			]&/@Range[numTriangles],
			Face[
				{
				#+i numTriangles,
				Mod[#+(i+1) numTriangles+(1+(-1)^i)/2+twist,numTriangles,(i+1)numTriangles+1],
				Mod[#+(i+1) numTriangles+(1+(-1)^i)/2-1+twist,numTriangles,(i+1)numTriangles+1]
				}
			]&/@Range[numTriangles]
		},{i,0,numHeight-1}],
		opt
	]
]]/;numTriangles>=2&&numHeight>=1


Options[RandomOrigami]=Join[
	Options[Origami],
	{
	Precision->Automatic,
	MaxIterations->20,
	"MinimumFolds"->4,
	"BoundaryPoints"->CirclePoints[4]
	}
];


RandomOrigami[ numberOfVertices_, opt : OptionsPattern[] ] :=
Module[ {
ctr = 1,
firstMesh = randomMesh[ numberOfVertices, OptionValue[Precision], OptionValue["BoundaryPoints"] ]
},
	(
	meshTry = ToOrigami[ firstMesh , Precision -> OptionValue[Precision] ];

	While[ Not @ validRandomOrigamiQ[ numberOfVertices, meshTry, OptionValue["MinimumFolds"], Length[OptionValue["BoundaryPoints"]] ] && ctr <= OptionValue[MaxIterations],
		meshTry = ToOrigami[ randomMesh[ numberOfVertices, OptionValue[Precision], OptionValue["BoundaryPoints"] ], Precision -> OptionValue[Precision] ]; ctr++
	];

	If[ ctr > OptionValue[MaxIterations], Message[RandomOrigami::max, ctr - 1] ];

	Origami[ meshTry, FilterRules[{opt}, Options[Origami]] ]
	) /; MeshRegionQ[firstMesh]

] /; RandomOrigamiMinFoldsQ[ OptionValue[ "MinimumFolds" ] ] && RandomOrigamiMaxIterationsQ[ OptionValue[ MaxIterations ] ]

RandomOrigami::max="Maximum number of iterations reached at `1` without finding a suitable random Origami.";

validRandomOrigamiQ[ numberOfVertices_, m_?MechanismQ, minimumFolds_, boundarySize_ ] :=
	AllTrue[
		Length /@ Drop[ MechanismConnectivity[m, "vertices" -> "edges"], boundarySize],
		# >= minimumFolds &
	] && m["VertexCount"]-boundarySize == numberOfVertices

RandomOrigami::mTorsionalFold="Minimum number of TorsionalFolds, `1`,  must be a position integer.";
RandomOrigamiMinFoldsQ[ _Integer?(#>0&) ] := True
RandomOrigamiMinFoldsQ[ f_ ] := (Message[RandomOrigami::mTorsionalFold, f]; False)

RandomOrigami::miter="Maximum number of iterations, `1`, must be a position integer.";
RandomOrigamiMaxIterationsQ[ _Integer?(#>0&) ] := True
RandomOrigamiMaxIterationsQ[ f_ ] := (Message[RandomOrigami::miter, f]; False)


(* get a Delaunay triangulation from a set of random points *)
randomMesh[numberOfVertices_Integer?(#>0&), precision : _?(NumericQ[#] && #>0&)|Automatic|MachinePrecision, boundary_?(MatrixQ[#,NumericQ]&)]:=
Module[{points},
	points=Join[
		boundary,
		Select[
			RandomVariate[
				UniformDistribution[RegionBounds[Polygon[boundary]]],
				numberOfVertices,
				WorkingPrecision->precision
			],
			RegionMember[Polygon[boundary]]
		]
	];
	DelaunayMesh[points]
] /; Last[ Dimensions[ boundary ] ] == 2

RandomOrigami::vnum="Number of vertices `1` should be a positive integer.";
RandomOrigami::prec="Option Precision must be a positive number.";
RandomOrigami::bound="Boundary points should be a list of vertices in 2D.";
randomMesh[ numberOfVertices_, precision_, boundary_ ] := "nothing" /; (
	If[ Not[ IntegerQ[numberOfVertices] && numberOfVertices >= 1 ], Message[ RandomOrigami::vnum, numberOfVertices ] ];
	If[ Not[ NumericQ[ precision ] && precision > 0 ] && Not[ precision === Automatic ], Message[ RandomOrigami::prec, precision ] ];
	If[ Not[ MatrixQ[ boundary, NumericQ ] && Last[Dimensions[ boundary ]] == 2 ], Message[ RandomOrigami::bound ] ];
	False
)


ElasticizeOrigami[ m_Origami ] := Module[
{
	bars = MechanismCellData[m, _RigidBar],
	Faces = MechanismCellData[m,_Face],
	TorsionalFolds = MechanismCellData[m,_TorsionalFold],
	possibleFolds = InteriorEdges[m],
	skippedFolds
},
	AddCells[ 
		DeleteCells[ 
			Join[ 
				If[Length[bars]>0, Thread[bars[[1,1]]] , {}] , 
				If[Length[Faces]>0, Thread[Faces[[1,1]] ], {} ]
			] 
		] @ m,

		{
		If[ Length[Faces]>0, ElasticTriangle /@ Faces[[1,1,1]] , {} ],
		If[ Length[TorsionalFolds]>0,
			skippedFolds = Complement[ Sort/@possibleFolds, Sort/@TorsionalFolds[[1,1,1]]];
			If[Length[skippedFolds]>0, TorsionalFold[ skippedFolds , {"TorsionalStiffness" -> 0}], {} ],
			TorsionalFold[possibleFolds,{"TorsionalStiffness" -> 0}]
		]
		}
	] /; FacesWorkQ[ Faces ]
]

FacesWorkQ[ {} ] := True
FacesWorkQ[ {Face[ indices_ ] -> data_ } ] := AllTrue[ {MatrixQ[indices], Last[Dimensions[indices]] == 3}, TrueQ ]
FacesWorkQ[ _ ] := False

ElasticizeOrigami[ m_Origami ] := "nothing" /; Message[ElasticizeOrigami::Faces];
ElasticizeOrigami::Faces="Faces must be triangles to elasticize this Origami.";


PossibleFoldsQ[ m_Origami , foldList_List ] :=
With[ {
	edges = Sort /@ (foldList /. m["labels"]),
	allFolds = Sort /@ InteriorEdges[m]
},
	MemberQ[ allFolds , # ] & /@ edges
]

PossibleFoldsQ[ m_Origami, foldList_ ] := "nothing" /; Message[PossibleFoldsQ::edges, foldList]
PossibleFoldsQ::edges = "Second argument `1` must be a list of potential folds.";


EquilibriumFoldAngles[ m_Origami ] := With[ {res = targetFoldAnglesInternal[ m, m["VertexCoordinates"]]},
	res /; Head[res] =!= targetFoldAnglesInternal
]


targetFoldAnglesInternal[ m_ , positions_ ] :=
With[{ data=MechanismCellData[ m, _TorsionalFold]},
	If[Length[data]>0,
		Association[
			"TorsionalFolds" -> data[[1,1,1]],
			"target" -> data[[1,2]]["Angle"],
			"actual" -> TorsionalFoldAngle[m, positions, data[[1,1,1]]]
		],
		Association["TorsionalFolds"->{},"target"->{},"actual"->{}]
	]
]


Options[FlatOrigamiQ]={
	ZeroTest->Automatic,
	Precision->Infinity
};


FlatOrigamiQ::precision="Precision is not a positive real number or Infinity.";
FlatOrigamiQ::zerotest="ZeroTest function must return True or False.";


computePrecision[m_,Infinity] := Precision[m]
computePrecision[m_,precision_?NumericQ] := Min[Precision[m],precision] /; precision>0
computePrecision[m_,_] := $Failed


computeZeroTestFunction[Automatic,Infinity] := PossibleZeroQ
computeZeroTestFunction[Automatic, precision : _?NumericQ] := (Abs[#]<=10^(-precision+1)&)
computeZeroTestFunction[f_,_] := f


FlatOrigamiQ[m_Origami, OptionsPattern[]]:=Module[{
	actualPrecision = computePrecision[m,OptionValue[Precision]], zerotestFunction, res
},
	zerotestFunction=computeZeroTestFunction[ OptionValue[ZeroTest], actualPrecision];

	res=flatOrigamiInternalQ[m,actualPrecision,zerotestFunction];

	res/;Which[
		Head[res]=!=flatOrigamiInternalQ,
			True,
		Not[BooleanQ[zerotestFunction[0]]],
			Message[FlatOrigamiQ::zerotest]; False,
		actualPrecision===$Failed,
			Message[FlatOrigamiQ::precision]; False,
		True,False
	]
]


flatOrigamiInternalQ[m_, precision : _?NumericQ | Infinity, zerotestFunction_?(BooleanQ[#[0]]&)]:=
	AllTrue[DiscreteGaussianCurvature[m, N[m["VertexCoordinates"], precision] , InteriorVertices[m] ], zerotestFunction]


Options[KawasakiQ]={
	ZeroTest->PossibleZeroQ,
	WorkingPrecision->Infinity
};


KawasakiQ[m_Origami,opt:OptionsPattern[]]:=
With[
{
	faceList = MechanismConnectivity[m, "vertices" -> "faces"][[InteriorVertices[m]]],
	mNum=N[m,OptionValue[WorkingPrecision]]
},
	If[ FlatOrigamiQ[m,opt],
		And @@ (OptionValue[ZeroTest] /@ kawasakiAlternatingSum[mNum, faceList]),
		False
	]
]/;(
	((NumericQ[OptionValue[WorkingPrecision]]&&OptionValue[WorkingPrecision]>0)||
	OptionValue[WorkingPrecision]===Infinity)&&
	BooleanQ[OptionValue[ZeroTest][0]]
)


kawasakiAlternatingSum[m_, faceList_]:=
With[
{
	faces = RotateRight[#,1]& /@ faceList
},
	If[OddQ[Length[#]],
		1,
		Total[DiagonalMatrix[(-1)^# &/@Range[Length[#]]] . PlaneAngle[m,#]]
	]& /@ faces
]


KawasakiQ::workingprecision="Working precesion must be a real value larger than 0.";
KawasakiQ::zerotest="Zero test does not return True or False.";

KawasakiQ[m_Origami,opt:OptionsPattern[]]:="nothing"/;Which[
	Not[(NumericQ[OptionValue[WorkingPrecision]]&&OptionValue[WorkingPrecision]>0)||OptionValue[WorkingPrecision]===Infinity],
		Message[KawasakiQ::workingprecision];
		False,
	Not[BooleanQ[OptionValue[ZeroTest][0]]],
		Message[KawasakiQ::zerotest];
		False,
	True,False
]


SameFoldAnglesQ[m_Origami, TorsionalFolds_?(MatrixQ[#,IntegerQ]&), precision : _?(NumericQ[#]&&#>0&) : 0.1 ][ pos1_?MatrixQ, pos2_?MatrixQ ] :=
With[
{
	angles1 = TorsionalFoldAngle[ m, pos1, TorsionalFolds ],
	angles2 = TorsionalFoldAngle[ m, pos2, TorsionalFolds ]
},
	(angles1 - angles2) . (angles1 - angles2) < precision^2
] /; Dimensions[pos1]==Dimensions[pos2] && Dimensions[pos1]=={m["VertexCount"],MechanismEmbeddingDimension[m]}
SameFoldAnglesQ[m_Origami, TorsionalFolds_?(MatrixQ[#,IntegerQ]&), precision : _?(NumericQ[#]&&#>0&) : 0.1][_,_] := False

SameFoldAnglesQ[m_Origami, precision : _?(NumericQ[#]&&#>0&) : 0.1 ][ pos1_?MatrixQ, pos2_?MatrixQ ] :=
With[
{TorsionalFolds = InteriorEdges[m]},
	With[
	{
	angles1 = TorsionalFoldAngle[ m, pos1, TorsionalFolds ],
	angles2 = TorsionalFoldAngle[ m, pos2, TorsionalFolds ]
	},
	(angles1 - angles2) . (angles1 - angles2) < precision^2
	]
] /; Dimensions[pos1]==Dimensions[pos2] && Dimensions[pos1]=={m["VertexCount"],MechanismEmbeddingDimension[m]}

SameFoldAnglesQ[m_Origami, precision : _?(NumericQ[#]&&#>0&) : 0.1][_,_] := False


SameMVAnglesQ[m_Origami, TorsionalFolds_?(MatrixQ[#,IntegerQ]&), precision : _?(NumericQ[#]&&#>0 &) : 0.1 ][ pos1_?MatrixQ, pos2_?MatrixQ ] :=
With[
{
	angles1 = Sign[ If[Abs[#]<precision,0,#]& /@ TorsionalFoldAngle[ m, pos1, TorsionalFolds ] ],
	angles2 = Sign[ If[Abs[#]<precision,0,#]& /@ TorsionalFoldAngle[ m, pos2, TorsionalFolds ] ]
},
	And @@ MapThread[#1==#2&,{angles1,angles2}]
] /; Dimensions[pos1]==Dimensions[pos2] && Dimensions[pos1]=={m["VertexCount"](*MeshCellCount[m["MeshRegion"],0]*),MechanismEmbeddingDimension[m]}
SameMVAnglesQ[m_Origami, TorsionalFolds_?(MatrixQ[#,Integer]&), precision : _?(NumericQ[#]&&#>0 &) : 0.1][_,_] := False

SameMVAnglesQ[m_Origami, precision : _?(NumericQ[#]&&#>0&) : 0.1 ][pos1_?MatrixQ, pos2_?MatrixQ ] :=
With[
{TorsionalFolds = InteriorEdges[m]},
	With[
	{
	angles1 = Sign[ If[Abs[#]<precision,0,#]& /@ TorsionalFoldAngle[ m, pos1, TorsionalFolds ] ],
	angles2 = Sign[ If[Abs[#]<precision,0,#]& /@ TorsionalFoldAngle[ m, pos2, TorsionalFolds ] ]
	},
	And @@ MapThread[#1==#2&,{angles1,angles2}]
	]
] /; Dimensions[pos1]==Dimensions[pos2] && Dimensions[pos1]=={m["VertexCount"](*MeshCellCount[m["MeshRegion"],0]*),MechanismEmbeddingDimension[m]}
SameMVAnglesQ[m_Origami, precision : _?(NumericQ[#]&&#>0&) : 0.1][_,_] := False


TorsionalFoldMatrix[m_Origami]:=torsionalFoldMatrixInternal[m,m["VertexCoordinates"],InteriorEdges[m]]
TorsionalFoldMatrix[m_Origami, edges_?MatrixQ] := With[{ actualEdges = edges /. m["labels"]},
	torsionalFoldMatrixInternal[m, m["VertexCoordinates"], actualEdges]
] /; And @@ PossibleFoldsQ[m, edges]

TorsionalFoldMatrix[m_?MechanismQ, ___] := "nothing" /; Message[TorsionalFoldMatrix::notorig]
TorsionalFoldMatrix[m_?MechanismQ, edges_ ] := "nothing" /; Message[TorsionalFoldMatrix::indices, edges]

TorsionalFoldMatrix::notorig="Mechanism is not Origami.";
TorsionalFoldMatrix::indices="Indices provided `1` do not correspond to a list of edges.";

torsionalFoldMatrixInternal[m_,positions_,indices_?(MatrixQ[#,IntegerQ]&)]:= With[
{displacements=VertexDisplacement[m]},
	D[TorsionalFoldAngle[m, positions+displacements, indices],{Flatten[displacements]}] /. Dispatch[Thread[Flatten[displacements]->0]]
]


(*AngularFoldMatrix[m_Origami,vertex_Integer]:=AngularFoldMatrix[Deformed[m,m["VertexCoordinates"]],vertex]
AngularFoldMatrix[Deformed[m_Origami,positions_?MatrixQ],vertex_Integer]:=Module[
{vertices=MechanismVertices[m,vertex],TorsionalFoldLengths,angles,heights},
	TorsionalFoldLengths=DisplacementLength[m["VertexCoordinates"],{#,vertex}&/@vertices];
	heights=Thread[VertexDisplacement[vertices,"z"]->TorsionalFoldLengths Array[angles,Length[vertices]]];
	Last@CoefficientArrays[
		-TorsionalFoldMatrixInternal[m,positions,{#,vertex}&/@vertices] . Flatten[VertexDisplacement[m,All[3]]]/.heights/.VertexDisplacement[_,_]->0,
		Array[angles,Length[vertices]]
	]
]/;MemberQ[InteriorVertices[m],vertex]*)


(*AngularFoldMatrix::notintv="Vertex should be an interior vertex.";
AngularFoldMatrix::orig="Mechanism is not Origami.";
AngularFoldMatrix::pos="Positions do not correspond to the Mechanism provided.";

AngularFoldMatrix[m_Origami,_]:="nothing"/;Message[AngularFoldMatrix::notintv]
AngularFoldMatrix[Deformed[m_,positions_],v_]:="nothing"/;Which[
	Head[m]=!=Origami,Message[AngularFoldMatrix::orig],
	Not[VertexCoordinatesQ[m,positions]],Message[AngularFoldMatrix::pos],
	Not[IntegerQ[v]]||Not[MemberQ[InteriorVertices[m],v]],Message[AngularFoldMatrix::notintv],
	True,False
]*)


ButterflyDecomposition[ o_Origami ] := Module[
{ results = FixedPointList[ ButterflyDecompositionStep, {{},o} ], remainingOrigami },
	remainingOrigami = Last[results][[2]];

	{ Drop[ Drop[ results[[All,1]], -1],1], remainingOrigami }
]

ButterflyDecompositionStep[ {Facepair_, o_Origami} ] := Module[
{boundary=Flatten[BoundaryVertices[o]], Faces, possibleButterflies, butterfly},
	Faces = MechanismConnectivity[ o, "vertices" -> "faces"][[ boundary ]];
	possibleButterflies = Select[ Transpose[ {boundary, Faces} ], Length[Last[#]] == 2 & ];
	If[Length[possibleButterflies]>0,
		butterfly = RandomChoice[possibleButterflies];
		{ butterfly[[2]], DeleteCells[o, Alternatives@@( Face /@ butterfly[[2]] ) ]  },

		{Facepair, o}
	]
] /; Length[o["faces"]]>=2
ButterflyDecompositionStep[ {Facepair_,o_Origami} ] := {Facepair,o}

(*this version shows little speed improvements over solving everything explicitly*)
ButterflyDecompositionQ[ o_Origami ] := FixedPoint[ ButterflyDecompositionStepQ, o ]

ButterflyDecompositionStepQ[ f_?BooleanQ ] := f
ButterflyDecompositionStepQ[ o_Origami ] := Module[
{boundary=Flatten[BoundaryVertices[o]], Faces, possibleButterflies, butterfly},
	Faces = MechanismConnectivity[ o, "vertices" -> "faces"][[ boundary ]];
	possibleButterflies = Select[ Transpose[ {boundary, Faces} ], Length[Last[#]] == 2 & ];
	If[Length[possibleButterflies]>0,
		butterfly = RandomChoice[possibleButterflies]; 
		DeleteVertices[o, {butterfly[[1]]}],

		False
	]
] /; Length[o["faces"]]>=2
ButterflyDecompositionStepQ[ o_Origami ] := True


unTorsionalFoldOrigami[ m_Origami ] := 
Module[
{
	TorsionalFolds = Property[ TorsionalFold[#], {"Angle" -> 0} ]& /@ InteriorEdges[m],
	selfflatteningOrigami, res
},
	selfflatteningOrigami = AddCells[ TorsionalFolds ] @ DeleteCells[ _PinnedJoint ] @ DeleteCells[ _TorsionalFold ] @ m;

	res = MinimizeMechanismEnergy[ selfflatteningOrigami, MaxIterations -> 10^6 ];
	If[ Head[res]===Association, res, {"Error" -> False, "Energy" -> Infinity, "VertexCoordinates"->m["VertexCoordinates"]} ]
]


chooseBoundaryFace[ m_Origami ] := First @ SelectFirst[ MechanismConnectivity[m, "edges" -> "faces" ], Length[#]==1 & ]


rotateFaceToXYPlane[ positions_, Face : {__Integer} ] :=
Module[{ initialPoints = positions[[ Face[[1;;3]] ]], lengths, angle, newPointLocations, residual, transform }, 
	lengths = DisplacementLength[positions, {Face[[1;;2]],Face[[2;;3]]} ];
	angle = First @ PlaneAngle[ positions, {Face[[1;;3]]} ];	
	newPointLocations = {
		{lengths[[1]],0,0},
		{0,0,0},
		lengths[[2]] {Cos[ angle ], Sin[ angle ], 0 }
	};
	
	{ residual, transform } = FindGeometricTransform[ newPointLocations,initialPoints, TransformationClass -> "Rigid", Method -> "Linear" ];

	transform
]

FlattenOrigami::Face="Unable to identify Faces.";
rotateFaceToXYPlane[ m_Origami, _ ] := (Message[FlattenOrigami::Face]; Identity)


Options[FlattenOrigami] = Options[MeshRegion];

FlattenOrigami[ m_Origami , tol_?(NumericQ[#] && #>0&), opt : OptionsPattern[] ] := 
Module[{ unTorsionalFoldedEnergy, unTorsionalFoldedPositions, transform, xyPositions, newOrigami },
	If[ Not[FlatOrigamiQ[m, Precision -> tol ]], Message[FlattenOrigami::flat] ];

	{ unTorsionalFoldedEnergy, unTorsionalFoldedPositions } = unTorsionalFoldOrigami[m];
	If[ (# . # &) @ TorsionalFoldAngle[m, unTorsionalFoldedPositions, InteriorEdges[m]] > 10^(-4), Message[ FlattenOrigami::notflt ] ];

	transform = rotateFaceToXYPlane[ unTorsionalFoldedPositions, chooseBoundaryFace[m] ];
	xyPositions = PadRight[ transform[ unTorsionalFoldedPositions ][[All,1;;2]], {Length[unTorsionalFoldedPositions], 3 } ];
			
	Mechanisms`Private`addMeshRegion[ Origami[ xyPositions, {}, m[[3]], m[[4]] ], Automatic, opt ]
]

FlattenOrigami::notflt="Origami flat energy may be too large to get good results.";
FlattenOrigami::flat="Gaussian curvature of vertices is not flat to desired tolerance `1`.";
FlattenOrigami::tol = "Tolerance `1` should be a positive number.";
FlattenOrigami::tol2 = "Second argument should be a tolerance.";

FlattenOrigami[ m_Origami, OptionsPattern[] ] := "nothing" /; Message[FlattenOrigami::tol2 ]
FlattenOrigami[ m_Origami, tol_, OptionsPattern[] ] := "nothing" /; Message[FlattenOrigami::tol, tol ]


MVAssignment[ m_Origami , tol : _?NumericQ, color_ : Automatic] := MVAssignment[ Deformed[m, m["VertexCoordinates"]], tol, color]
MVAssignment[ Deformed[m_Origami, positions_ ] , tol : _?NumericQ, color_ : Automatic ] := 
With[{
	pos = If[positions === Automatic, m["VertexCoordinates"], positions], 
	colorFunction = If[color === Automatic, MVdefaultColor, color ], 
	edges = InteriorEdges[m]
},
	With[ { angles = TorsionalFoldAngle[m, pos, edges] },
		MapThread[ (#1 -> colorFunction[ assignMVForFold[ #2, tol ] ] ) & , { edges, angles } ]
	] /; NumericCoordinatesQ[m, pos]

]

assignMVForFold[angle_, tol_]:= 1 /; angle > Abs[tol]
assignMVForFold[angle_, tol_]:= -1 /; angle < -Abs[tol]
assignMVForFold[_,_]:=0

MVdefaultColor[1] := Red
MVdefaultColor[-1] := Blue
MVdefaultColor[0] := Black


Options[MVColor] = { "Mountain" -> Red, "Valley" -> Blue, "Hinge" -> Black , Precision -> 10^(-8)};

MVColor[ m_Origami, s : _String : "target" , opt : OptionsPattern[] ] := MVColor[ s, opt][m]
MVColor[ s : _String : "target" , opt : OptionsPattern[] ][m_Origami] :=
Module[
{ 
data = EquilibriumFoldAngles[m], styles, 
colorFunction = mvDefaultColorFunction[OptionValue["Mountain"], OptionValue["Valley"], OptionValue["Hinge"], OptionValue[Precision]]
},
	(
	styles = colorFunction /@ N[data[s]];
	ChangeCellData[m, TorsionalFold[data["TorsionalFolds"]],"Style" -> styles]
	) /; If[ MemberQ[ Keys[data], s], True, Message[MVColor::s,s,Keys[data]]; False]
]

mvDefaultColorFunction[ mountainColor_, valleyColor_, hingeColor_ , precision_] :=
With[{
	mc = If[Head[mountainColor]===List, Directive@@mountainColor, mountainColor],
	vc = If[Head[valleyColor]===List, Directive@@valleyColor, valleyColor],
	hc = If[Head[hingeColor]===List, Directive@@hingeColor, hingeColor],
	p = If[ NumericQ[precision] && precision >= 0, precision , Message[MVColor::p, precision]; 0 ]
},
	Function[{x},Which[
		Not[NumericQ[x]], hc,
		x > p, mc,
		x < -p, vc,
		True, hc 
	]]
]

MVColor::s="`1` is not a valid string of type `2`.";
MVColor::p="Precision `1` should be a positive number.";


SurfaceArea[o_Origami, r___] ^:= SurfaceArea[ o["MeshRegion"], r ]
RegionMeasure[o_Origami, r___] ^:= RegionMeasure[ o["MeshRegion"], r ]
RegionMoment[o_Origami, r___] ^:= RegionMoment[ o["MeshRegion"], r ]


Options[DeconstructedOrigami]={
	"edgeWeights" -> {},
	"defaultWeight" -> 0
};

DeconstructedOrigami[ m_Origami, opt : OptionsPattern[] ]:=
	DeconstructedOrigami[ Deformed[m, MechanismPositions[m]], opt ]

DeconstructedOrigami[ Deformed[ m_Origami, coords_], opt : OptionsPattern[] ]:=
With[{
	Faces = MechanismFaces[m], 
	widths = MechanismConnectivity[m,"faces" -> "edges"] /. OptionValue["edgeWeights"] /. {_Integer,_Integer} -> OptionValue["defaultWeight"]
},
	MapThread[ shrinkPolygon , {coords[[#]]& /@ Faces,widths} ]
] /; DeconstructedOrigamiQ[m , coords, OptionValue["edgeWeights"], OptionValue["defaultWeight"] ]

DeconstructedOrigamiQ[Deformed[ m_, positions_], rules_, default_ ]:=
	If[ VertexCoordinatesQ[m,positions], True, Message[DeconstructedOrigami::pos]; False] &&
	If[ NumericQ[default]&&default >= 0, True, Message[DeconstructedOrigami::defaultweight]; False ] && 
	If[ MatchQ[ rules, {___Rule} ], True, Message[DeconstructedOrigami::weightRules]; False ] &&
	If[ VectorQ[ rules[[All,2]] , NumericQ[#]&&#>=0& ], True, Message[DeconstructedOrigami::weightrules]; False ] &&
	If[ MatchQ[ rules[[All,1]] , {{_Integer,_Integer}...} ], True, Message[DeconstructedOrigami::weights]; False ]

DeconstructedOrigami::pos="The positions do not correspond to the Mechanism.";
DeconstructedOrigami::weights="The weights must be positive numbers.";
DeconstructedOrigami::defaultweight="The default weight must be a positive number.";
DeconstructedOrigami::edges="The left hand side of the rules must be well-formed edges.";
DeconstructedOrigami::weightrules="Option \"edgeWeights\" must be a list of rules of the form edge -> positive weight.";


shrinkPolygon[ pts_, widths_ ] := pts + Total @ MapIndexed[ shrinkPolygonSide[ pts, #2[[1]], #1 ]&, widths ]

shrinkPolygonSide[ pts_, v1_, width_ ] :=
Module[{n=Length[pts], v2, future, past, futureEdge, edge, pastEdge},
	v2=Mod[v1+1, n, 1]; future=Mod[v2+1, n, 1]; past = Mod[v1-1,n,1];
	edge=Normalize[ pts[[v2]] - pts[[v1]] ];
	futureEdge = Normalize[ pts[[future]] - pts[[v2]] ];
	pastEdge = Normalize[ pts[[past]] - pts[[v1]] ];
	
	RotateRight[Join[
		width*{
			pastEdge/Norm[ Cross[ pastEdge, edge ] ],
			futureEdge/Norm[ Cross[ futureEdge, edge ] ]
		},
		ConstantArray[{0,0,0},n-2]
	], v1-1]
]


End[];

EndPackage[];


BeginPackage["Mechanisms`graphics`"];


AngleMarker::usage="AngleMarker[m, {v1,v2,v3}, (radius) ] creates an arc around an angle spanning (v1,v2) to (v3,v2).";
AngleText::usage="angleTest[m, {v1,v2,v3}, (distance) ] adds a text label to the angle spanning (v1,v2) to (v3,v2).";

MechanismPrimitives::usage = "MechanismPrimitives[ m, (positions) ] returns a list of Mechanism primitives." ;
ToGraphicsComplex::usage = "ToGraphicsComplex[ m, (positions) ] returns a GraphicsComplex object identical to MechanismPrimitives[].";


PinnedJointShape::usage="PinnedJointShape[] is a triangular pinned joint in 2D.";
SpringShape::usage="SpringShape[] represents a Spring shape function with a particular thickness and number of jags.";
PinnedJointShape::usage="FreeJointShape[] represents a joint shape distinguishing pinned joints from free joints.";
RigidBarShape::usage="RigidBarShape[] represents the shape of a RigidBar";
FreeJointShape::usage="FreeJointShape[] represents the shape of a free joint.";
JointShape::usage="JointShape[] represents the shape of a joint that is either free or pinned.";
FaceShape::usage="FaceShape[]";


PlotMechanism::usage=
"PlotMechanism[ Mechanism, positions ] plots a Mechanism using positions.
PlotMechanism[Mechanism, {positions 1, positions 2,...}] creates a list of plotted Mechanisms with uniform size.";

PeriodicPlotMechanism::usage="PeriodicPlotMechanism[m], PeriodicPlotMechanism[m, positions] plots a periodic mechanism.
PeriodicPlotMechanism[{m,pi}], PeriodicPlotMechanism[{m, pi}, positions] plots a periodic mechanism with periodic identification data pi.";


StressStyle::usage="StressStyle is an option for PlotMechanism to provide a style for plotting stresses.";
DisplacementStyle::usage="DisplacementStyle is an option for PlotMechanism to provide a style for plotting displacements.";
DisplacementScale::usage="DisplacementScale is an option for PlotMechanism to provide an overall scale for displacements.";
DisplayDimension::usage="DisplayDimension is an option for PlotMechanism to choose the dimension in which a mechanism should be displayed.";
Displacements::usage="Displacements is an option for PlotMechanism to display a vertex displacement overlaid with a mechanism.";
Stresses::usage="Stresses is an option for PlotMechanism to display stresses overlaid with a mechanism.";


OrigamiTexture::usage="OrigamiTexture[ s ] returns a texture having the name s. Use $OrigamiTextures to see possible textures.";
$OrigamiTextures::usage="$OrigamiTextures returns a list of textures you can use in OrigamiTexture[] to texture the faces of origami.";


$MechanismThemes = "List of recognized graphics themes.";


PlotConfigurationSpaceCurve::usage="PlotConfigurationSpaceCurve[m, {p, d}, proj] draws a curve in the configuration space of a mechanism starting from p and in the direction d (or closest possible direction).
proj must be a function taking a set of vertex positions to a 2D or 3D coordinates.";


Begin["`Private`"];

Needs["Mechanisms`"];
Needs["Mechanisms`geometry`"];
Needs["Mechanisms`rigidity`"];
Needs["Mechanisms`Origami`"];


$MechanismThemes={"Standard" , "Minimal", "Thick"};


graphicsOrder[ AngleJoint ] := 3
graphicsOrder[ PinnedJoint|FreeJoint|Point ]:=2
graphicsOrder[ RigidBar|Spring|Line|TorsionalFold ]:=1
graphicsOrder[ Face|ElasticTriangle|Polygon ]:=0


ClearAll[defaultGraphicsPrimitive];
ClearAll[defaultGraphicsStyle];


defaultGraphicsPrimitive[RigidBar|Line , Linkage , {3,2}, "Standard"] := RigidBarShape["Width" -> 0.05]
defaultGraphicsPrimitive[RigidBar|Line , Linkage , _, "Standard"] := RigidBarShape[]
defaultGraphicsPrimitive[FreeJoint , Linkage , {3,2}, "Standard"] := FreeJointShape["Diameter" -> 0.05]
defaultGraphicsPrimitive[FreeJoint , Linkage , _, "Standard"] := FreeJointShape[]
defaultGraphicsPrimitive[PinnedJoint , Linkage , {3,2}, "Standard"] := PinnedJointShape["Diameter" -> 0.05]
defaultGraphicsPrimitive[PinnedJoint , Linkage , _ , "Standard"] := PinnedJointShape[]


defaultGraphicsPrimitive[RigidBar|Line , Origami , _ , "Standard"] := (Line[#]&)
defaultGraphicsPrimitive[FreeJoint , Origami , _ , "Standard"] := (Point[#]&)
defaultGraphicsPrimitive[PinnedJoint , Origami , _ , "Standard"] := (Point[#]&)
defaultGraphicsPrimitive[TorsionalFold, Origami, _ , "Standard"] := (Line[#]&)


defaultGraphicsStyle[ TorsionalFold, Origami, _ , "Standard" ] := {Black}


defaultGraphicsPrimitive[Face, _ , _ , "Standard"] := FaceShape[]
defaultGraphicsPrimitive[ElasticTriangle, _ , _ , "Standard"] := FaceShape["Thickness"->0.01]
defaultGraphicsPrimitive[Polygon , _ , _ , "Standard"] := (Polygon[#]&)
defaultGraphicsPrimitive[Spring , _ , _ , "Standard"] := SpringShape[]


defaultGraphicsStyle[ RigidBar , _ , {3,2} , "Standard"] := {RGBColor[0.25,0.45,0.95]}
defaultGraphicsStyle[ RigidBar , _ , _ , "Standard"] := {Black}
defaultGraphicsStyle[ FreeJoint , _ , _ , "Standard"] := {RGBColor[0.25,0.45,0.95]}
defaultGraphicsStyle[ PinnedJoint , _ , _ , "Standard"] := {Black}
defaultGraphicsStyle[ Face , _ , _ , "Standard"] := {GrayLevel[0.85]}
defaultGraphicsStyle[ ElasticTriangle , _ , _ , "Standard"] := {RGBColor[{0.85,0.85,0.95}]}
defaultGraphicsStyle[ Spring , _ , _ , "Standard"] := {}


defaultGraphicsPrimitive[ RigidBar , Linkage, _, "Thick" ] := RigidBarShape["Width" -> 0.05]
defaultGraphicsPrimitive[ Face | ElasticTriangle , Linkage, {_,3} , "Thick" ] := FaceShape["Thickness"->0.01]
defaultGraphicsPrimitive[Face | ElasticTriangle, Linkage, {_,3} , "Thick"[thickness_] ] := FaceShape["Thickness" -> thickness]

defaultGraphicsStyle[ cell_ , Linkage , d_ , "Thick" | "Thick"[_]] := defaultGraphicsStyle[cell, Linkage, d, "Standard" ]


defaultGraphicsPrimitive[Face | ElasticTriangle, Origami, {_,3} , "Thick"] := FaceShape["Thickness"->0.01]
defaultGraphicsPrimitive[Face | ElasticTriangle, Origami, {_,3} , "Thick"[thickness_] ] := FaceShape["Thickness" -> thickness]
defaultGraphicsPrimitive[ _ , Origami, {_,3}, "Thick"|"Thick"[_] ] := None

defaultGraphicsStyle[ cell_ , Origami, {d_,3}, "Thick"|"Thick"[_]] := defaultGraphicsStyle[ cell, Origami, {d,3}, "Standard" ]


defaultGraphicsPrimitive[ cell_ , Origami , {d_,2} , "Thick" | "Thick"[_]] := defaultGraphicsPrimitive[cell, Origami, {d,2}, "Standard" ]

defaultGraphicsStyle[ cell_ , Origami , {d_,2} , "Thick" | "Thick"[_]] := defaultGraphicsStyle[cell, Origami, {d,2}, "Standard" ]


defaultGraphicsPrimitive[ RigidBar|Spring|Line, _, _ , "Minimal" ] := (Line[#]&)
defaultGraphicsPrimitive[ FreeJoint|PinnedJoint|Point, _, _ , "Minimal" ] := (Point[#]&)
defaultGraphicsPrimitive[ Face|ElasticTriangle|Polygon, _, _ , "Minimal" ] := (Polygon[#]&)

defaultGraphicsStyle[ cell_ , type_ , dim_ , "Minimal"] := defaultGraphicsStyle[cell, type, dim, "Standard"]


dimension[ position_?MatrixQ ] := Length[position[[1]]]
dimension[ positions : {__?MatrixQ} ] := Max[Length /@ positions[[All,1]]]

sameVertexNumberQ[ m_, position_?MatrixQ ] := m["VertexCount"] == Length[position]
sameVertexNumberQ[ m_, positions : {__?MatrixQ} ] := With[ {n = m["VertexCount"]}, AllTrue[Length /@ positions , #==n& ]]
sameVertexNumberQ[ m_, Automatic ] := True

flatEnoughQ[ position_?MatrixQ ] := Chop[ Max[ Abs[ position[[All,3]] ] ] ] == 0
flatEnoughQ[ positions: {__?MatrixQ} ] := Chop[ Max[ Abs[ Flatten[positions[[All,All,3]]] ] ] ] == 0

recastDimension[ position_?MatrixQ , dim_ ] := PadRight[position, {Length[position],dim}]
recastDimension[ position:{__?MatrixQ} , dim_ ] := PadRight[position, {Length[position],Length[position[[1]]],dim}]


(*put the dimensions of the coordinates in the requested dimension*)
positionDimension[ m_, Automatic, dim_ ]:=
	Switch[ dim,
		Automatic,
			If[MechanismEmbeddingDimension[m]==3 && MechanismDisplayDimension[m]==2,
				recastDimension[m["VertexCoordinates"],2],
				m["VertexCoordinates"]
			],
		2, If[ MechanismEmbeddingDimension[m]==3 && Not@flatEnoughQ[m["VertexCoordinates"]],
			Message[Mechanism::notflat]; m["VertexCoordinates"],
			recastDimension[m["VertexCoordinates"],2]
			],
		3, recastDimension[m["VertexCoordinates"],3],
		_, $Failed
	]

positionDimension[ m_, positions : _?VertexCoordinatesQ|{__?VertexCoordinatesQ}, dim_ ] :=
	Switch[ dim,
		Automatic,
			recastDimension[ positions, dimension[positions] ],
		2,
			If[ dimension[positions] == 3 && Not@flatEnoughQ[positions],
				Message[Mechanism::notflat];
				recastDimension[ positions, 3],
				recastDimension[ positions, 2]
			],
		3, recastDimension[ positions, 3],
		_, $Failed
	] /; sameVertexNumberQ[ m, positions]
positionDimension[ m_, positions : _?VertexCoordinatesQ|{__?VertexCoordinatesQ}, dim_ ]:= (Message[Mechanism::vn, m["VertexCount"] ]; $Failed)


Mechanism::notflat = "Cannot project a fully 3D Mechanism into 2D.";
Mechanism::vn = "Number of vertices `1` does not agree with number of vertex positions.";


defaultGraphicsPrimitive[ RigidBar|Spring|Line, _, _ , None ] := (Line[#]&)
defaultGraphicsPrimitive[ FreeJoint|PinnedJoint|Point, _, _ , None] := (Point[#]&)
defaultGraphicsPrimitive[ Face|ElasticTriangle|Polygon, _, _ , None ] := (Polygon[#]&)

defaultGraphicsPrimitive[_ , _ , _ , _ ] := None
defaultGraphicsStyle[ _ , _ , _ , _] := {}


(*translating different themes*)
themesQ[m_, Automatic] := "Standard"
themesQ[m_,theme_ ] /; Length[theme]==0 := If[ Not@MemberQ[ Flatten[{$MechanismThemes,None}], theme ], Message[MechanismPrimitives::theme, theme]; "Standard" , theme]
themesQ[m_, theme_ ] := If[ Not@MemberQ[  Flatten[{$MechanismThemes,None}], Head[theme] ], Message[MechanismPrimitives::theme, theme]; "Standard" , theme]

MechanismPrimitives::theme="`1` is not a valid theme. Use $MechanismThemes to see what is possible.";


graphicsOrder[ _ ]:=4

(*sortComponentsForGraphics[] sorts a list of components in dimensional order.*)
sortComponentsForGraphics[ components_ ] :=
	SortBy[DeleteCases[
		{ graphicsOrder[Head[#[[1]]]] , # }& /@ components,
		{4,_}
	],First][[All,2]]


Options[MechanismPrimitives] = {PlotTheme->Automatic};

MechanismPrimitives[ m_?MechanismQ, dimension : 2|3|Automatic : Automatic , OptionsPattern[]] :=With[
{pos=positionDimension[m, Automatic, dimension]},
	mechanismPrimitivesInternal[ m, pos, m["VertexCoordinates"] , themesQ[m,OptionValue[PlotTheme]] ] /; pos =!= $Failed
]
MechanismPrimitives[ Deformed[ m_?MechanismQ, positions_?NumericCoordinatesQ], dimension : 2|3|Automatic : Automatic , OptionsPattern[]] :=With[
{ pos=positionDimension[m, positions, dimension]},
	mechanismPrimitivesInternal[ m, pos, positions, themesQ[m,OptionValue[PlotTheme]] ] /; pos =!= $Failed
]

MechanismPrimitives[ Deformed[m_?MechanismQ, positions_?NumericCoordinatesQ], dimension : 2|3|Automatic : Automatic , OptionsPattern[]] :=
	"nothing" /; Message[MechanismPrimitives::coord, Length[positions], m["VertexCount"]]
MechanismPrimitives[ Deformed[ m_?MechanismQ, positions_?NumericCoordinatesQ], dimension_ , OptionsPattern[]] :=
	"nothing" /; Message[MechanismPrimitives::dim]
MechanismPrimitives[ Deformed[ m_?MechanismQ, positions_?VertexCoordinatesQ], dimension : 2|3|Automatic : Automatic , OptionsPattern[]] :=
	"nothing" /; Message[MechanismPrimitives::num]


MechanismPrimitives::coord = "Number of vertices in second argument, `1`, does not match number of vertices in Mechanism, `2`.";
MechanismPrimitives::dim = "Number of dimensions requested is not 2, 3, or Automatic.";
MechanismPrimitives::num = "Vertices should be numeric.";


mechanismPrimitivesInternal[ m_, positions_ , actualPositions_, theme_] :=
	Transpose[
		mechanismPrimitivesFromComponent[ m, positions, # , theme]& /@ sortComponentsForGraphics[ MechanismCellData[ PlaceVertices[m,actualPositions], _ ] ]
	]

mechanismPrimitivesFromComponent[ m_, positions_, Rule[head_[ indices_ ], display_ ] , theme_] :=
With[ {
	coordinates = ToPackedArray[N[positions[[ # ]] & /@ indices]],
	dimensionData = ConstantArray[m["EmbeddingDimension"], Length[indices]],

	componentData = If[ Length[display]>3, Transpose[Drop[Values[display],-3]], ConstantArray[{},Length[indices]] ],
	componentDataType=ConstantArray[ Drop[Keys[display],-3], Length[indices]],

	style = Mechanisms`Private`combineDataList[ defaultGraphicsStyle[head, Head[m], {Length[positions[[1]]],m["EmbeddingDimension"]}, theme] , display["Style"]],
	labels = display["Label"],
	shapeFunction = display["Shape"] /. {Automatic -> defaultGraphicsPrimitive[head, Head[m], {Length[positions[[1]]],m["EmbeddingDimension"]},theme]} /. { None -> ({}&) }
},
	{
		MapThread[applyFunction ,
			{
			Mechanisms`geometry`Private`MechanismGeometricExpression[ m, N[positions], style] ,
			Mechanisms`geometry`Private`MechanismGeometricExpression[ m, N[positions], shapeFunction] ,
			coordinates, 
			dimensionData,
			componentDataType,
			componentData,
			head /@ indices
			}
		],

		Flatten @ MapThread[applyLabel,
			{
			If[ MatrixQ[coordinates], coordinates, Mean /@ coordinates ],
			indices,
			labels
			}
		]
	}
]

$textOffset = 0.05;
applyLabel[ coordinates_, _, None ] := {}
applyLabel[ coordinates_, label_, "Index"] := Text[label, coordinates + ConstantArray[$textOffset,Length[coordinates]]]
applyLabel[ coordinates_, _, lab_ ] := Text[ lab, coordinates + ConstantArray[$textOffset,Length[coordinates]] ] /; Head[lab] =!= Text
applyLabel[ coordinates_, _, Text[lab_, coord_, other___] ] := Text[ lab, coord + coordinates, other ]

applyFunction[ style_ , None, coordinates_, dimensionData_, componentDataType_, componentData_, primitive_ ] := {}
applyFunction[ style_ , shapeFunction_, coordinates_,  dimensionData_, componentDataType_, componentData_ , primitive_ ] :=
With[{ rules = Thread[componentDataType -> componentData]},
	Flatten[ {style /. rules, (shapeFunction /.rules)[coordinates, primitive, dimensionData, componentData, componentDataType]} ]
]


Options[ToGraphicsComplex] = Join[Options[GraphicsComplex], {PlotTheme->Automatic}];

ToGraphicsComplex[ m_?MechanismQ, dimension : 2|3|Automatic : Automatic, opt : OptionsPattern[] ] :=
With[ {
res=ToGraphicsComplexInternal[ m, positionDimension[m, Automatic, dimension], m["VertexCoordinates"],
	dimension, OptionValue[PlotTheme], FilterRules[{opt},Options[GraphicsComplex]] ]
},
	res /; res =!= $Failed
]
ToGraphicsComplex[ Deformed[ m_?MechanismQ, positions_?VertexCoordinatesQ ], dimension : 2|3|Automatic : Automatic, opt : OptionsPattern[] ] :=
With[ {res = ToGraphicsComplexInternal[ m, positionDimension[m, positions, dimension], positions, 
	dimension, OptionValue[PlotTheme],FilterRules[{opt},Options[GraphicsComplex]] ]
},
	res /; res =!= $Failed
 ] /; Length[positions] == m["VertexCount"]


canonicalizePrimitiveRules = {
	p : _Polyhedron|_Parallelepiped|_Cuboid :> CanonicalizePolyhedron[p],
	p : _Polygon :> CanonicalizePolygon[p]
};

extractVertexCoordinates[primitives_] := 
DeleteDuplicates[
	Flatten[ Cases[ Flatten[primitives] ,_?RegionQ|_Text] /. {
		p_Polygon :> (Point /@ PolygonCoordinates[p]),
		p_Polyhedron :> (Point /@ PolyhedronCoordinates[p]),
		(p_ /; RegionQ[p]) :> If[ Length[Dimensions[ p[[1]] ] ] == 1, Point[p[[1]]] , Point/@p[[1]] ],
		Text[_,p_,___] :> Point[p],
		Text[_,x_,y_,___] :> Point[x+y]
	}][[All,1]]
]


ToGraphicsComplexInternal[ m_, positions_, actualPositions_, dimension_, theme_, options_ ] :=
Module[ {prims, modifiedPrimitives, coordinates, coordinateRules, x},
	prims = mechanismPrimitivesInternal[m , positions, actualPositions , themesQ[m,theme] ] /. canonicalizePrimitiveRules;

	If[ Head[prims] === MechanismPrimitives,
		$Failed,

		coordinates=extractVertexCoordinates[prims];
		coordinateRules = Dispatch[Thread[coordinates -> Range[Length[coordinates]]]];

		modifiedPrimitives = prims /. {
			Polygon[x_,y_] :> Polygon[ x[[y]]  ],
			Polyhedron[x_,y_] :> Polyhedron[ x[[#]]&/@y ]
		} /. coordinateRules /. {CanonicalizePolyhedron[Polyhedron[x_]] :> Polyhedron[x],CanonicalizePolygon[Polygon[x_]] :> Polygon[x]};

		GraphicsComplex[
			coordinates,
			modifiedPrimitives,
			Flatten[{ options,VertexTextureCoordinates -> coordinates}]
		]
	]
]


$OrigamiTextures= { "WhitePaper", "GrayPaper", "WrinkledPaper" };

$dataDirectory=FileNameJoin[{(First@PacletFind["Mechanisms"])["Location"],"Resources","Textures"}];

OrigamiTexture["WrinkledPaper"] := OrigamiTexture["WrinkledPaper"] = Texture @ Normal[Import[FileNameJoin[{$dataDirectory,"crinkled-paper.jpg"}]]]
OrigamiTexture["WhitePaper"] := OrigamiTexture["WhitePaper"] = Texture @ Normal[Import[FileNameJoin[{$dataDirectory,"white-paper.jpg"}]]]
OrigamiTexture["GrayPaper"] := OrigamiTexture["GrayPaper"] = Texture @ Normal[Import[FileNameJoin[{$dataDirectory,"blue-paper.jpeg"}]]]

OrigamiTexture::bad="Unrecognized texture `1`.";
OrigamiTexture[s_] := "nothing" /; Message[OrigamiTexture::bad, s]


coordinate2D={_?NumericQ, _?NumericQ};
coordinate3D={_?NumericQ,_?NumericQ,_?NumericQ};
meshAccessQ=_Integer|{__Integer};
plotAccessQ=_Line|_Point|_Polygon;


coordinate2DQ = VectorQ[#,NumericQ] && Length[#]==2&;
coordinate3DQ = VectorQ[#,NumericQ] && Length[#]==3&;


edgeCellPattern = Alternatives@@(Blank /@ Join[{Line},Mechanisms`Private`edgeCells]);
vertexCellPattern = Alternatives@@(Blank /@ Join[{Point},Mechanisms`Private`vertexCells]);
faceCellPattern = Alternatives@@(Blank /@ Join[{Polygon},Mechanisms`Private`faceCells]);
angleCellPattern = Alternatives@@(Blank /@ Mechanisms`Private`angleCells);


Options[RigidBarShape] = 
{
	"Width" -> 0.01,
	"MiddleWidth" -> 0,
	"Thickness" -> 0.025,
	"EndOffset" -> 0,
	"HeightOffset" -> 0	
};


(*any embedding dimension and 2D display dimension*)
RigidBarShape[ opt : OptionsPattern[] ][ {x_?coordinate2DQ, y_?coordinate2DQ} , edgeCellPattern , 2|3 , ___ ] :=
With[{
	length = Norm[y-x], dir = Normalize[y-x],
	middleWidth = OptionValue["MiddleWidth"] + OptionValue["Width"],
	endWidth = OptionValue["Width"],
	endOffset = OptionValue["EndOffset"]
},
	{
		EdgeForm[None],
		polygonShape[{x,y}, length, dir, {{0,1},{-1,0}} . dir , endOffset, endWidth , middleWidth ] ,
		Disk[x, endWidth/2],
		Disk[y, endWidth/2]
	} /;
		And[
			AllTrue[{middleWidth, endWidth, endOffset}, NumericQ],
			0 <= endOffset <= length/2 && endWidth >= 0 && middleWidth >= 0
		]
]

(*2D embedding dimension and 3D display dimension*)
RigidBarShape[ opt : OptionsPattern[] ][ {x_?coordinate3DQ, y_?coordinate3DQ}, edgeCellPattern , 2 ,  ___ ] :=
With[{
	length = Norm[y-x], dir = Normalize[y-x],
	middleWidth = OptionValue["MiddleWidth"] + OptionValue["Width"],
	endWidth = OptionValue["Width"],
	endOffset = OptionValue["EndOffset"],
	heightOffset = OptionValue["HeightOffset"],
	thickness = OptionValue["Thickness"]
},
	{
	EdgeForm[None],
	ExtrudedPolygon[{heightOffset-thickness/2 , thickness/2 + heightOffset}] @@ polygonShape[{x,y}, length, dir, Cross[{0,0,01},dir] , endOffset, endWidth , middleWidth ]
	} /;
		And[
			AllTrue[{middleWidth, endWidth, endOffset,heightOffset, thickness}, NumericQ],
			0 <= endOffset <= length/2 && endWidth >= 0 && middleWidth >= 0 && thickness >= 0
		]
]

(*3D embedding dimension and 3D display dimension*)
RigidBarShape[ opt : OptionsPattern[] ][{x_?coordinate3DQ, y_?coordinate3DQ}, edgeCellPattern , 3 ,  ___ ] :=
With[{
	radius = OptionValue["Width"],
	middleWidth = OptionValue["MiddleWidth"] + OptionValue["Width"]
},
	If[OptionValue["MiddleWidth"]==0,
		Tube[{x,y}, radius],
		Tube[{x,(x+y)/2,y}, {radius,middleWidth, radius}]
	] /; NumericQ[radius] && radius >= 0 && middleWidth >= 0
]

RigidBarShape[ opt : OptionsPattern[] ][coord_, pattern_, dim_ , ___] := "nothing" /; (
	If[ MatchQ[ pattern , edgeCellPattern] && Not@MatrixQ[coord], (*coordinates are improperly formed*)Message[RigidBarShape::coord, coord, pattern] ];
	If[ Not@MatchQ[ pattern , edgeCellPattern], (*not at edge cell*) Message[RigidBarShape::cell, pattern] ];
	If[ dim != 2 && dim != 3, Message[RigidBarShape::dim, pattern, dim] ];
	False
)

RigidBarShape::coord="Coordinates `1` for cell `2` are valid 2D or 3D coordinates.";
RigidBarShape::cell="Cell `2` is not a valid edge cell.";
RigidBarShape::dim="Cell `1` cannot be displayed in `2` dimensions.";


polygonShape[ {x_,y_}, length_, direction_, normal_, endOffset_, endWidth_ , middleWidth_ ] :=
	Polygon[
	{
		x + endOffset * direction - endWidth normal/2,
		x + endOffset * direction + endWidth normal/2,
		(x+y)/2 + middleWidth normal/2,
		y - endOffset * direction + endWidth normal/2,
		y - endOffset * direction - endWidth normal/2,
		(x+y)/2 - middleWidth normal/2
	}] /; middleWidth != endWidth

polygonShape[ {x_,y_}, length_, direction_, normal_, endOffset_, endWidth_ , middleWidth_ ] :=
	Polygon[
	{
		x + endOffset * direction - endWidth normal/2,
		x + endOffset * direction + endWidth normal/2,
		y - endOffset * direction + endWidth normal/2,
		y - endOffset * direction - endWidth normal/2
	}] /; middleWidth == endWidth


Options[FreeJointShape] = 
{
	"Diameter" -> 0.04,
	"Thickness" -> 0.027,
	"HeightOffset" -> 0
};


(*any embedding dimension, plotted in 2D*)
FreeJointShape[ OptionsPattern[] ][x : coordinate2D, vertexCellPattern , 2|3 , ___]:=
	With[{circleRadius = OptionValue["Diameter"]/2}, Disk[x, circleRadius] /; NumericQ[circleRadius] && circleRadius >= 0]

(*embedded in 2D, plotted in 3D*)
FreeJointShape[ OptionsPattern[] ][x : coordinate3D, vertexCellPattern, 2, ___]:=
	With[{circleRadius = OptionValue["Diameter"]/2 , thickness = OptionValue["Thickness"],off = OptionValue["HeightOffset"]},
		{EdgeForm[None],Cylinder[{ x - {0,0,thickness/2-off}, x + {0,0,thickness/2+off} }, circleRadius]} /; 
			And[
				AllTrue[{thickness, off, circleRadius}, NumericQ],
				thickness >= 0, circleRadius >= 0
			]
	]

(*embedded in 3D, plotted in 3D*)
FreeJointShape[ OptionsPattern[] ][ x : coordinate3D, vertexCellPattern, 3, ___] :=
	With[ {sphereRadius = OptionValue["Diameter"]/2}, Sphere[ x, sphereRadius] /; NumericQ[sphereRadius] && sphereRadius >= 0]

FreeJointShape[ OptionsPattern[] ][ coord_ , pattern_ , dim_, ___ ] := "nothing" /; (
	If[Not@VectorQ[coord], Message[FreeJointShape::coord, coord, pattern] ];
	If[MatchQ[pattern, vertexCellPattern] && (dim <2 || dim <3), Message[FreeJointShape::dim, dim, pattern] ];
	If[ Not@MatchQ[pattern, vertexCellPattern], Message[FreeJointShape::cell, pattern] ];
	False
)

FreeJointShape::coord = "Coordinate `1` is not a single 2D or 3D position for cell `2`.";
FreeJointShape::dim = "Display dimension `2` is not a single 2D or 3D position for cell `2`.";
FreeJointShape::cell = "Cell `2` is not a valid vertex cell.";

(*
FreeJointShape[ OptionsPattern[] ][ x : coordinate3D, _Point, 0, ___ ] :=
	With[ {sphereRadius = OptionValue["Diameter"]/2}, Sphere[ x, sphereRadius] /; NumericQ[sphereRadius] && sphereRadius >= 0]
*)


Options[PinnedJointShape] =
{
	"Diameter" -> 0.05,
	"Angle" -> 0,
	"Thickness" -> 0.027
};


PinnedJointShape[ OptionsPattern[] ][ pt : coordinate2D, vertexCellPattern, 2|3, ___]:=
With[{circleRadius = OptionValue["Diameter"]/5, x = pt[[1]], y = pt[[2]], angle = OptionValue["Angle"], size = OptionValue["Diameter"]},
	With[{
		mat={{Cos[angle],-Sin[angle]},{Sin[angle],Cos[angle]}},
		translation1 = ConstantArray[{x,y},4], translation2 = ConstantArray[{x,y},2]
	},
		{
			Circle[ pt , circleRadius],
			Line[translation1 + {{0,0-circleRadius},{0-size,0-circleRadius-size},{0+size,0-circleRadius-size},{0,0-circleRadius}} . mat],
			Line[translation2 + {{0-2 size,0-circleRadius-size},{0+2 size, 0-circleRadius-size}} . mat]
		}
	] /;
		And[
			AllTrue[{circleRadius, angle, size}, NumericQ],
			circleRadius >= 0 && size >= 0
		]
]


PinnedJointShape[OptionsPattern[]][x : coordinate3D, vertexCellPattern, 2, ___ ] :=
With[{circleRadius = OptionValue["Diameter"] + 0.02 , thickness = OptionValue["Thickness"]},
	{
	EdgeForm[None],
	Cylinder[{x -{0,0,thickness/2},x+{0,0,thickness/2}}, circleRadius/2],
	Cylinder[{x - {0,0,2 thickness},x - {0,0,thickness/2} }, circleRadius/4]
	} /;
		And[
			AllTrue[{circleRadius, thickness}, NumericQ],
			circleRadius >= 0 && thickness >= 0		
		]
]

PinnedJointShape[OptionsPattern[]][pt : coordinate3D, vertexCellPattern, 3 , ___ ]:= Sphere[pt,OptionValue["Diameter"]/2]
(*PinnedJointShape[OptionsPattern[]][pt : coordinate3D, _Point , ___ ]:= Sphere[pt,OptionValue["Diameter"]/2]*)

PinnedJointShape[ OptionsPattern[] ][ coord_ , pattern_ , dim_, ___ ] := "nothing" /; (
	If[Not@VectorQ[coord], Message[PinnedJointShape::coord, coord, pattern] ];
	If[MatchQ[pattern, vertexCellPattern] && (dim <2 || dim <3), Message[PinnedJointShape::dim, dim, pattern] ];
	If[ Not@MatchQ[pattern, vertexCellPattern], Message[PinnedJointShape::cell, pattern] ];
	False
)

PinnedJointShape::coord = "Coordinate `1` is not a single 2D or 3D position for cell `2`.";
PinnedJointShape::dim = "Display dimension `2` is not a single 2D or 3D position for cell `2`.";
PinnedJointShape::cell = "Cell `2` is not a valid vertex cell.";


Options[JointShape] =
{
	"Diameter" -> 0.01,
	"Angle" -> 0,
	"Thickness" -> 0.026,
	"HeightOffset" -> 0
};

JointShape[ opt : OptionsPattern[] ][ x : coordinate2D, b : _FreeJoint|_PinnedJoint, d_ , a : {Infinity, ___}, rest : ___ ] := 
	PinnedJointShape[ FilterRules[{opt},Options[PinnedJointShape]] ][x,b,d, a, rest]
JointShape[ opt : OptionsPattern[] ][ x : coordinate3D, b : _FreeJoint|_PinnedJoint, d_ , a : {Infinity, ___}, rest : ___ ] :=
	PinnedJointShape[ FilterRules[{opt},Options[PinnedJointShape]] ][x,b,d, a, rest]

JointShape[ opt : OptionsPattern[] ][ x : coordinate2D, b : _FreeJoint|_PinnedJoint, rest : ___ ] :=
	FreeJointShape[ FilterRules[{opt},Options[FreeJointShape]] ][x, b, rest]
JointShape[ opt : OptionsPattern[] ][ x : coordinate3D, b : _FreeJoint|_PinnedJoint, rest : ___ ] :=
	FreeJointShape[ FilterRules[{opt},Options[FreeJointShape]] ][x,b, rest]

JointShape[ opt : OptionsPattern[] ][ x : coordinate2D, b_Point, rest___ ] := FreeJointShape[ FilterRules[{opt},Options[FreeJointShape]] ][x,b,rest]
JointShape[ opt : OptionsPattern[] ][ x : coordinate3D, b_Point, rest___ ] := FreeJointShape[ FilterRules[{opt},Options[FreeJointShape]] ][x,b,rest]


Options[SpringShape] =
{
	"Width" -> 0.1,
	"Number" -> 5,
	"Resolution" -> 30,
	"Absolute"->False
};

SpringShape[ opt : OptionsPattern[] ][ coord_ , patt : edgeCellPattern, dim : 2|3 ] := SpringShape[ opt ][coord, patt, dim, {1,1} ]


rot2D = Compile[{x1,x2},{{x1,x2},{-x2,x1}}/Sqrt[x1^2+x2^2]];

SpringShape[ OptionsPattern[] ][ { x_?coordinate2DQ, y_?coordinate2DQ }, edgeCellPattern , 2|3 , {l_,___}, ___ ]:=
With[{ 
length = Sqrt[(y-x) . (y-x)],
width = OptionValue["Width"]/2*If[TrueQ[OptionValue["Absolute"]],1,l], 
period = 2 OptionValue["Number"], 
nPoints = Round[(l+0.1)*OptionValue["Resolution"]*OptionValue["Number"]]
},
With[{ delta = N[length/nPoints], rotMat = rot2D @@ (y-x)},
	{
	BezierCurve[
		N@Join[
			{x},
			ConstantArray[x,nPoints-3]+
					N[{
					# + width Cos[ period Pi #/length ],
					width Sin[ period Pi #/length ]
					}& /@ Range[2 delta, length - 2 delta, delta]
				] . rotMat,
			{y}
		]
	]
	}
] /; NumericQ[width] && width>=0 && IntegerQ[period] && period>0 && IntegerQ[nPoints] && nPoints>0

]


rot3D = Compile[{x1,x2,x3},
	{{(x2^2+(x1^2 x3)/Sqrt[x1^2+x2^2+x3^2])/(x1^2+x2^2),(x1 x2 (-1+x3/Sqrt[x1^2+x2^2+x3^2]))/(x1^2+x2^2),x1/Sqrt[x1^2+x2^2+x3^2]},{(x1 x2 (-1+x3/Sqrt[x1^2+x2^2+x3^2]))/(x1^2+x2^2),(x1^2+(x2^2 x3)/Sqrt[x1^2+x2^2+x3^2])/(x1^2+x2^2),x2/Sqrt[x1^2+x2^2+x3^2]},{-(x1/Sqrt[x1^2+x2^2+x3^2]),-(x2/Sqrt[x1^2+x2^2+x3^2]),x3/Sqrt[x1^2+x2^2+x3^2]}}
];

SpringShape[ OptionsPattern[] ][ {x : coordinate3D, y : coordinate3D}, edgeCellPattern , 2|3 , {l_,___},___ ] :=
With[ {
rotMat = rot3D @@ (x-y),
length=Norm[ y-x ], 
numPoints = Round[(l+0.1)*OptionValue["Resolution"]*OptionValue["Number"]], 
number = OptionValue["Number"],
thickness = OptionValue["Width"]*l/2
}, With[{ delta = N[length/numPoints] },
	{
	BezierCurve[
		N@Join[
		{x},
		ConstantArray[x,numPoints-3] + N[
			{ thickness Cos[number 2 Pi #/length],thickness Sin[number 2 Pi #/length], # }& /@ Range[2 delta,length-2 delta,delta]
		] . rotMat,
		{y}
		]
	]
	}
]/; NumericQ[thickness] && thickness>=0 && IntegerQ[number] && number>0 && IntegerQ[numPoints] && numPoints>0

]


SpringShape[ opt : OptionsPattern[] ][coord_, pattern_, dim_ , ___] := "nothing" /; (
	If[ MatchQ[ pattern , edgeCellPattern] && Not@MatrixQ[coord], (*coordinates are improperly formed*)Message[SpringShape::coord, coord, pattern] ];
	If[ Not@MatchQ[ pattern , edgeCellPattern], (*not at edge cell*) Message[SpringShape::cell, pattern] ];
	If[ dim != 2 && dim != 3, Message[SpringShape::dim, pattern, dim] ];
	False
)

SpringShape::coord="Coordinates `1` for cell `2` are valid 2D or 3D coordinates.";
SpringShape::cell="Cell `2` is not a valid edge cell.";
SpringShape::dim="Cell `1` cannot be displayed in `2` dimensions.";


Options[FaceShape] = {
	"Thickness" -> 0
};


FaceShape[ OptionsPattern[] ][ x : {coordinate2D..}, ___] := Polygon[ x , VertexTextureCoordinates -> x]

FaceShape[ OptionsPattern[] ][ x : {coordinate3D..}, _Face|_ElasticTriangle, 2|3, ___ ] := 
	If[ OptionValue["Thickness"] == 0,
		Polygon[ x , VertexTextureCoordinates -> x],
		ExtrudedPolygon[{-OptionValue["Thickness"], OptionValue["Thickness"]}][x]
	] /; NumericQ[OptionValue["Thickness"]] && OptionValue["Thickness"]>=0

FaceShape[ OptionsPattern[] ][ x : {coordinate3D..},  _Polygon, ___ ] := Polygon[ x , VertexTextureCoordinates -> x]

FaceShape[ OptionsPattern[] ][___] := "nothing" /; (
	If[Not[NumericQ[OptionValue["Thickness"]] && TrueQ[OptionValue["Thickness"]>= 0]], Message[FaceShape::thick, OptionValue["Thickness"]]];
	False
)

FaceShape::thick="Thickness `1` should be a non-negative real number.";


AngleText[m_?MechanismQ, {v1_Integer,v2_Integer,v3_Integer}, label_ : "",distance : _?NumericQ : 0]:=With[
{
	angleLocation=m["VertexCoordinates"][[v2,1;;MechanismDisplayDimension[m]]],
	vectors=-DisplacementVector[m["VertexCoordinates"],{{v3,v2},{v1,v2}}][[All,1;;MechanismDisplayDimension[m]]]
},
	Text[label,angleLocation + (distance+0.12) Mean[vectors]]
]


AngleMarker[m_?MechanismQ, {v1_Integer,v2_Integer,v3_Integer}, radius : _?NumericQ : 1/10]:=With[
{
	(*project the vectors making this angle to the xy-plane*)
	angleLocation=m["VertexCoordinates"][[v2,1;;2]],
	vectors=DisplacementVector[m["VertexCoordinates"],{{v2,v1},{v2,v3}}][[All,1;;2]]
},
	Circle[angleLocation,
		Abs[radius] Sqrt[Min[vectors[[1]] . vectors[[1]],vectors[[2]] . vectors[[2]]]],
		(If[Pi+#[[2]]<Pi+#[[1]],{0,2Pi}+#,#]&)[ArcTan@@@vectors]
	]
] /; MechanismDisplayDimension[m]==2 && Max[{v1,v2,v3}]<=m["VertexCount"](*MeshCellCount[m["MeshRegion"],0]*) && Min[{v1,v2,v3}]>0


(*Code borrowed from https://mathematica.stackexchange.com/questions/10957/an-efficient-circular-arc-primitive-for-graphics3d*)
ClearAll[splineCircle2];
splineCircle[m_List, r_, angles_List: {0., 2. \[Pi]}] := 
 Module[{seg, \[Phi], start, end, pts, w, k, pihalf},
   pihalf = 0.5 \[Pi];
   {start, end} = Mod[N[angles], 2. \[Pi]];
   If[end <= start, end += 2. \[Pi]];
   seg = Quotient[N[end - start], pihalf];
   \[Phi] = Mod[N[end - start], pihalf];
   If[seg == 4, seg = 3; \[Phi] = pihalf];
   With[{
     cseg = Cos[pihalf seg], sseg = Sin[pihalf seg],
     c\[Phi] = Cos[\[Phi]], s\[Phi] = Sin[\[Phi]], 
     t\[Phi] = Tan[0.5 \[Phi]],
     rcs = r Cos[start], rss = r Sin[start]
     },
    pts = Join[
       Take[{{1., 0.}, {1., 1.}, {0., 1.}, {-1., 1.}, {-1., 0.}, {-1., -1.}, {0., -1.}}, 2 seg + 1],
       {{cseg - sseg t\[Phi], sseg + cseg t\[Phi]}, {cseg c\[Phi] - sseg s\[Phi], c\[Phi] sseg + cseg s\[Phi]}}
       ] . {{rcs, rss}, {-rss, rcs}}
    ];
   pts = ConstantArray[m, Length[pts]] + 
     If[Length[m] == 2, 
      pts, 
      Join[pts, ConstantArray[{0.}, Length[pts]], 2]
     ];
   w = With[{c = 1./Sqrt[2.]}, 
     Join[Take[{1., c, 1., c, 1., c, 1.}, 2 seg + 1], {Cos[0.5 \[Phi]], 1.}]
     ];
   k = Join[{0, 0, 0}, Riffle[#, #] &@Range[seg + 1], {seg + 1}];
   BSplineCurve[pts, SplineDegree -> 2, SplineKnots -> k, SplineWeights -> w]
   ] /; Length[m] == 2 || Length[m] == 3
 
Options[circleFromPoints] = {arc -> False};

circleFromPoints[m : {q1_, q2_, q3_}, OptionsPattern[]] :=
Module[{c, r, \[Phi]1, \[Phi]2, p1, p2, p3, h, 
        rot = Quiet[RotationMatrix[{{0, 0, 1}, Cross[#1 - #2, #3 - #2]}],RotationMatrix::spln] &},
  {p1, p2, p3} = {q1, q2, q3} . rot[q1, q2, q3];
  h = p1[[3]];
  {p1, p2, p3} = {p1, p2, p3}[[All, ;; 2]];
  {c, r} = List @@ Circumsphere[{p1, p2, p3}];
  \[Phi]1 = ArcTan @@ (p3 - c);
  \[Phi]2 = ArcTan @@ (p1 - c);
  c = Append[c, h];
  If[OptionValue[arc] // TrueQ,
    MapAt[Function[{p}, rot[q1, q2, q3] . p] /@ # &, splineCircle[c, r, {\[Phi]1, \[Phi]2}], {1}],
    MapAt[Function[{p}, rot[q1, q2, q3] . p] /@ # &, splineCircle[c, r], {1}]
  ]
] /; MatrixQ[m, NumericQ] && Dimensions[m] == {3, 3}


AngleMarker[m_?MechanismQ, {v1_Integer,v2_Integer,v3_Integer}, radius : _?NumericQ : 1/10]:=With[
{
	angleLocation=m["VertexCoordinates"][[v2]],
	(*project the vectors making this angle to the xy-plane*)
	vectors=DisplacementVector[m["VertexCoordinates"],{{v2,v1},{v2,v3}}]
},
	circleFromPoints[{angleLocation+radius vectors[[1]],angleLocation+radius (vectors[[1]]+vectors[[2]])/Sqrt[2],angleLocation+radius vectors[[2]]},arc ->True]
] /; MechanismDisplayDimension[m]==3 && Max[{v1,v2,v3}]<=m["VertexCount"](*MeshCellCount[m["MeshRegion"],0]*) && Min[{v1,v2,v3}]>0


AngleMarker::bounds="Vertices are out of bounds.";
AngleMarker[m_?MechanismQ, {v1_Integer,v2_Integer,v3_Integer}]:="nothing"/;Message[AngleMarker::bounds]
AngleMarker[m_?MechanismQ, {v1_Integer,v2_Integer,v3_Integer},_]:="nothing"/;Message[AngleMarker::bounds]
AngleMarker[m_?MechanismQ, {v1_Integer,v2_Integer,v3_Integer},_,_?NumericQ]:="nothing"/;Message[AngleMarker::bounds]


Options[PlotMechanism] = Join[
	Options[Graphics3D],
	{
		PlotTheme -> Automatic,
		Displacements -> None,
		Stresses -> None,

		StressStyle -> {
			{RGBColor[{#2,0,0}] , AbsoluteThickness[1+3*#2] , Line[#]}&,
			{RGBColor[{0,0,-#2}] , AbsoluteThickness[1+3*(-#2)] ,Line[#]}&
		},

		DisplacementStyle -> {Black},
		DisplacementScale -> 0.25,

		DisplayDimension -> Automatic,
		Prolog->{}
	}
];


PlotMechanism[ m_?MechanismQ, opt : OptionsPattern[] ] :=
With[ {res = plotMechanismInternal[ m, m["VertexCoordinates"] , OptionValue[DisplayDimension], OptionValue[Prolog], {opt},
										OptionValue[Stresses], OptionValue[StressStyle],
										OptionValue[Displacements], OptionValue[DisplacementStyle], OptionValue[DisplacementScale]
								]},
	res /; res =!= $Failed
]

PlotMechanism[ m_?MechanismQ, positions : _?NumericCoordinatesQ|{__?NumericCoordinatesQ}, opt : OptionsPattern[] ] :=
With[ {res = plotMechanismInternal[ m, positions , OptionValue[DisplayDimension], OptionValue[Prolog], {opt},
										OptionValue[Stresses], OptionValue[StressStyle],
										OptionValue[Displacements], OptionValue[DisplacementStyle], OptionValue[DisplacementScale]
								]},
	res /; res =!= $Failed
]


plotMechanismInternal[ m_ , positions_ , displayDimension_ , prolog_ , options_, inputStresses_ , stressStyle_ , inputDisplacements_ , displacementStyle_ , displacementScale_ ] :=
Module[{
	(*expand coordinates to the correct number of plots we are going to make*)
	coordinates, stresses, displacements,
	primitiveOptions = FilterRules[ {options}, Options[MechanismPrimitives] ], mechanismGraphics,
	directive, displayOptions,
	edges = MechanismEdges[m],

	stressScale, maximumDisplacement
	
},
	(* each of coordinates, stresses, and displacements are lists of the same length *)
	{coordinates, stresses, displacements} = expandInputs[ Length[edges], positionDimension[m, positions, displayDimension], inputStresses, inputDisplacements ];

	If[coordinates === $Failed ,
		$Failed,

		(*compute the overall stress and displacement scale*)
		stressScale = getStressScale[stresses];
		maximumDisplacement = getDisplacementScale[displacements];

		mechanismGraphics = MechanismPrimitives[ Deformed[m, #], displayDimension, primitiveOptions ] & /@ coordinates;
		directive = graphicsDirective[ m , mechanismGraphics , Length[coordinates[[1,1]]]];
		displayOptions = graphicsOptions[ {options}, directive , boundingRegions[m, coordinates] ];
		
		stresses = MapThread[ plotStresses[stressScale, edges, #1, #2, stressStyle ]& , {coordinates, stresses} ];
		displacements = MapThread[ plotDisplacements[ maximumDisplacement, #1, #2, displacementScale , displacementStyle ]&, {coordinates, displacements} ];

		If[ Length[coordinates]==1 , First, #& ] @ MapThread[ directive[ {prolog, #1, #2, #3}, displayOptions ]& , {mechanismGraphics, stresses, displacements} ]
	]
] /; NumericQ[displacementScale] && displacementScale > 0 && VectorQ[ stressStyle ] && Length[stressStyle] == 2

plotMechanismInternal[ m_ , positions_ , displayDimension_ , prolog_ , options_, inputStresses_ , stressStyle_ , inputDisplacements_ , displacementStyle_ , displacementScale_ ] :=
(
	If[ Not[NumericQ[displacementScale] && displacementScale > 0], Message[PlotMechanism::displscale] ];
	If[ Not[VectorQ[ stressStyle ] && Length[stressStyle] == 2], Message[PlotMechanism::stressstyle] ];
	$Failed
)

PlotMechanism::stressstyle = "Stress style should be of the form { positive stress style, negative stress style }.";
PlotMechanism::displscale="The displacement scale must be a positive real number.";


expandInputs[ $Failed , _ , _ ] := (
	Message[PlotMechanism::pos];
	{}
)

(*only one set of positions given*)
expandInputs[ _, coordinates_?(MatrixQ[#,NumericQ]&) , None|{}, None|{} ] := { {coordinates}, {None}, {None}}

(*one position, one stress*)
expandInputs[ edgeNumber_, coordinates_?(MatrixQ[#,NumericQ]&), stresses_?(VectorQ[#,NumericQ]&), None|{} ] :=
	{{coordinates}, {stresses}, {None}} /; Length[stresses] == edgeNumber
(*one position, multiple stresses*)
expandInputs[ edgeNumber_, coordinates_?(MatrixQ[#,NumericQ]&), stresses_?(MatrixQ[#,NumericQ]&) , None|{}] := {
	ConstantArray[ coordinates, Length[stresses] ], 
	stresses, 
	ConstantArray[ None, Length[stresses] ]
	} /; edgeNumber == Length[stresses[[1]]]
(*one position, one displacement*)
expandInputs[ _ , coordinates_?(MatrixQ[#,NumericQ]&), None|{}, displacements_?(MatrixQ[#,NumericQ]&) ] :=
	{
		{coordinates},
		{None},
		{displacements}
	} /; Dimensions[displacements] == Dimensions[coordinates]
(*one position, several displacements*)
expandInputs[ _ , coordinates_?(MatrixQ[#,NumericQ]&), None|{}, displacements_?(ArrayQ[#,_,NumericQ]&) ] := {
	ConstantArray[ coordinates , Length[displacements]],
	ConstantArray[ None , Length[displacements]],
	displacements
} /; ArrayDepth[displacements]==3 && Dimensions[ displacements[[1]] ] == Dimensions[coordinates]
(*one positions, multiple stresses and displacements -- these should match*)
expandInputs[ edgeNumber_ , coordinates_?(MatrixQ[#,NumericQ]&) , stresses_?(VectorQ[#,NumericQ]&) , displacements_?(MatrixQ[#,NumericQ]&) ] := {
	{coordinates},
	{stresses},
	{displacements}
} /; Dimensions[displacements] == Dimensions[coordinates] && Length[stresses] == edgeNumber
(*multiple positions but no stresses or displacements*)
expandInputs[ edgeNumber_ , coordinates_?(ArrayQ[ #, _, NumericQ]&), None|{}, None|{} ] :=
{
	coordinates,
	ConstantArray[None,Length[coordinates]],
	ConstantArray[None,Length[coordinates]]
}
(*multiple positions and multiple stresses*)
expandInputs[ edgeNumber_ , coordinates_?(ArrayQ[ #, _, NumericQ]&), stresses_?(MatrixQ[#,NumericQ]&), None|{} ] :=
{
	coordinates,
	stresses,
	ConstantArray[None,Length[stresses]]
} /; Length[ stresses[[1]] ] == edgeNumber && Length[stresses] == Length[coordinates]
(*multiple positions and multiple displacements*)
expandInputs[ edgeNumber_ , coordinates_?(ArrayQ[ #, _, NumericQ]&), None|{}, displacements_?(ArrayQ[#,_,NumericQ]&) ] :=
{
	coordinates,
	ConstantArray[None,Length[displacements]],
	displacements
} /; Dimensions[displacements] == Dimensions[coordinates]
(*multiple positions, stresses and displacements*)
expandInputs[ edgeNumber_ , coordinates_?(ArrayQ[ #, _, NumericQ]&), stresses_?(MatrixQ[#,NumericQ]&), displacements_?(ArrayQ[#,_,NumericQ]&) ] :=
{
	coordinates,
	stresses,
	displacements
} /; Dimensions[displacements] == Dimensions[coordinates] && Length[ stresses[[1]] ] == edgeNumber && Length[stresses] == Length[displacements]

expandInputs[ edgeNumber_, coordinates_ , stresses_, displacements_] := (
	(*is everything numerical if well-formed*)
	If[ MatrixQ[coordinates] && Not[MatrixQ[coordinates, NumericQ]] , Message[PlotMechanism::npos, coordinates]];
	If[ ArrayQ[coordinates] && Not[ArrayQ[coordinates,_,NumericQ]], Message[PlotMechanism::npos, coordinates]];
	If[ VectorQ[stresses] && Not[VectorQ[stresses,NumericQ]], Message[PlotMechanism::numstress, stresses]];
	If[ MatrixQ[stresses] && Not[MatrixQ[stresses,NumericQ]], Message[PlotMechanism::numstress, stresses]];
	If[ MatrixQ[displacements] && Not[MatrixQ[displacements,NumericQ]], Message[PlotMechanism::numdisp, displacements]];
	If[ ArrayQ[displacements] && Not[ArrayQ[displacements,NumericQ]], Message[PlotMechanism::numdisp, displacements]];

	(*are displacements the right size?*)
	If[ MatrixQ[coordinates] && MatrixQ[displacements] && Not[Dimensions[displacements]==Dimensions[coordinates]], Message[PlotMechanism::numdispl, Dimensions[coordinates]]];
	If[ MatrixQ[coordinates] && ArrayQ[displacements] && Not[Dimensions[displacements]==Dimensions[coordinates[[1]]]], Message[PlotMechanism::numdispl, Dimensions[coordinates]]];
	If[ ArrayQ[coordinates] && ArrayQ[displacements] && Not[Dimensions[displacements[[1]]]==Dimensions[coordinates[[1]]]], Message[PlotMechanism::numdispl, Dimensions[coordinates[[1]]]]];

	(*are stresses the right size?*)
	If[ VectorQ[stresses] && Not[edgeNumber == Length[stresses]], Message[PlotMechanism::stressmatch, edgeNumber]];
	If[ MatrixQ[stresses] && Not[edgeNumber == Length[stresses[[1]]]], Message[PlotMechanism::stressmatch, edgeNumber]];

	(*same number of coordinates, stresses, and displacements?*)
	If[ ArrayQ[coordinates] && MatrixQ[stresses] && Not[Length[coordinates] == Length[stresses]], Message[PlotMechanism::numinst] ];
	If[ ArrayQ[coordinates] && ArrayQ[displacements] && Not[Length[coordinates] == Length[displacements]], Message[PlotMechanism::numinstdisp] ];

	(*not well formed displacements or stresses*)
	If[ Not[MatrixQ[displacements]] && Not[ArrayQ[displacements]] && Not[displacements===None|{}], Message[PlotMechanism::numdispl, Dimensions[coordinates]] ];
	If[ Not[VectorQ[stresses]] && Not[MatrixQ[stresses] && Not[stresses===None|{}]], Message[PlotMechanism::stressmatch, edgeNumber] ];
	If[ Not[MatrixQ[coordinates]] && Not[ArrayQ[coordinates]], Message[PlotMechanism::pos] ];

	{$Failed,$Failed,$Failed}
)


PlotMechanism::npos = "Coordinates `1` are not numeric.";
PlotMechanism::pos = "Requested display coordinates are not valid.";
PlotMechanism::numstress="Stresses `1` should be a numeric stress or a list of numeric stresses.";
PlotMechanism::numdisp="Displacements `1` must be numerical displacements or a list of numerical displacements.";
PlotMechanism::numdispl="Each displacement should have dimensions `1`.";
PlotMechanism::stressmatch="Stresses should agree with the number of edges, `1`.";
PlotMechanism::numinst = "There must be as many stresses as number of mechanism copies to plot.";
PlotMechanism::numinstdisp = "There must be as many displacements as number of mechanism copies to plot.";


(*clip the bounding box to a minimum size*)
$minsize=0.25;
minSize[{x_,y_}] := { x-$minsize, x+$minsize } /; Abs[y-x] < $minsize
minSize[{x_,y_}] := {x-$minsize, y+$minsize}

(*figure out plot range and ratios*)
plotSizes[positions_] :=
Module[{
	boundingRegion, boundingBoxRatios
},
	boundingRegion = 
		minSize /@ (Transpose @  CoordinateBoundingBox[positions]);
	boundingBoxRatios = (#[[2]] - #[[1]] &) /@ boundingRegion;

	{boundingRegion, boundingBoxRatios}
]


boundingRegions[ m_, $Failed] := $Failed
boundingRegions[ m_, graphics : {__GraphicsComplex}] := plotSizes[ Flatten[ graphics[[All,1]], 1 ] ]
boundingRegions[ m_, pos_ ] := plotSizes[pos]

graphicsDirective[ m_, $Failed, dim_ ] := (#&)
graphicsDirective[ m_, graphics : {__GraphicsComplex}, expectedDim_ ] := With[ {dims = Length /@ graphics[[All,1,1]]},
	Which[
		Not[ Equal @@ dims ], (#&),
		dims[[1]]==2, Graphics,
		dims[[1]]==3, Graphics3D,
		True, (#&)
	]
]
graphicsDirective[m_, graphics_, expectedDim_ ] := 
	Switch[ expectedDim,
		2, Graphics, 
		3, Graphics3D,
		_, (#&)
	]

graphicsOptions[ options_, directive_, $Failed ] := {}
graphicsOptions[ options_, directive_, {boundingRegion_, boundingRatios_} ] :=
	Join[
		FilterRules[{options},Options[Graphics3D]], 
		{Boxed -> False, Lighting->"Neutral",PlotRange -> boundingRegion, BoxRatios -> boundingRatios}
	]


getStressScale[ stresses_ ] := With[ { tmp = DeleteCases[stresses, None]},
	Max[ Max[tmp,0], Abs @ Min[tmp,0] ]
]


plotStresses[ _ , _ , _ , None, _ ] := {}

plotStresses[ stressScale_, edges_, coordinates_, stress_, stressFunc_Function ] :=
	plotStresses[ stressScale, edges, coordinates, stress, {stressFunc, stressFunc} ]

plotStresses[ stressScale_, edges_, coordinates_, stress_, {posStress_Function, negStress_Function} ] :=
With[ {
	coordinatePairs = coordinates[[ # ]]& /@ edges,
	normalizedStresses = If[stressScale>0, stress/stressScale, stress ]
},
	MapThread[
		Which[#2<0, negStress[ #1, #2 ], #2>0, posStress[ #1, #2 ], True, {} ]&,
		{
		coordinatePairs,
		normalizedStresses
		}
	]
]


getDisplacementScale[displacements_] := With[ {tmp = DeleteCases[ displacements, None ]},
	Max[ Map[Norm , tmp, {2} ] ]
]


plotDisplacements[ _, _, None, _, _ ] := {}

plotDisplacements[ maxDisplacement_, coordinates_, displacement_, displacementScale_, style_] :=
With[{padding = 0.9},
	Flatten @ MapThread[
		displacementGraphic[ style ],
		{
			coordinates,
			displacementScale * displacement/maxDisplacement
		}
	]
]

displacementGraphic[ style_ ][ vertexLocation_, displacement_ ] := 
	{
	style,
	Arrow[ {vertexLocation, vertexLocation + displacement} ]
	}


Options[PeriodicPlotMechanism] = Join[
	Options[PlotMechanism],
	{
		"Scale" -> 3/2
	}
];

scaleQ[ n_ ] := If[NumericQ[n] && 1 <= n <= 2, True, Message[PeriodicPlotMechanism::scale, n]; False]

PeriodicPlotMechanism::scale="Option \"Scale\" must be a number between 1 and 2.";

PeriodicPlotMechanism[ m_?PeriodicMechanismQ , rest___] :=
	PeriodicPlotMechanism[{m, PeriodicIdentification[m]} , rest]

PeriodicPlotMechanism[ {m_?MechanismQ , pi_PeriodicIdentificationData}, opt : OptionsPattern[] ] :=
With[{
	plotsize = RegionBounds[ RegionResize[ BoundingRegion[ MechanismPositions[m] ] , Scaled[OptionValue["Scale"]] ]],
	basis = pi["LatticeVectors"],
	positions = MechanismPositions[m],
	opaqueMechanism = ChangeCellData[MechanismCells[_], "Label"->None] @ ChangeCellData[MechanismCells[_], "Style" -> Opacity[0.25]] @ m,
	indices = generateIndices[ MechanismEmbeddingDimension[m] ],
	scale = OptionValue["Scale"]
},
	Show[
		PlotMechanism[m, opt],
		PlotMechanism[ opaqueMechanism,
			translateMechanismPositions[ positions, basis, #] & /@ indices
		],
		PlotRange -> plotsize
	]
] /; scaleQ[ OptionValue["Scale"] ]

PeriodicPlotMechanism[ {m_?MechanismQ , pi_PeriodicIdentificationData}, pos_?MatrixQ , opt : OptionsPattern[] ] :=
With[{
	plotsize = RegionBounds[ RegionResize[ BoundingRegion[ MechanismPositions[m] ] , Scaled[OptionValue["Scale"]] ]],
	basis = pi["LatticeVectors"],
	positions = MechanismPositions[m],
	opaqueMechanism = ChangeCellData[MechanismCells[_], "Label"->None] @ ChangeCellData[MechanismCells[_], "Style" -> Opacity[0.25]] @ m,
	indices = generateIndices[ MechanismEmbeddingDimension[m] ],
	scale = OptionValue["Scale"]
},
	Show[
		PlotMechanism[m, pos, opt],
		PlotMechanism[ opaqueMechanism, 
			translateMechanismPositions[ pos, basis, #] & /@ indices
		],
		PlotRange-> plotsize
	]
] /; scaleQ[ OptionValue["Scale"] ] && MechanismEmbeddingDimension[m]==Length[pos[[1]]]

generateIndices[ 1 ] := Module[{i}, DeleteCases[Table[{i}, {i,-1,1}], {0} ] ]
generateIndices[ 2 ] := Module[{i,j}, DeleteCases[ Flatten[Table[{i,j}, {i,-1,1},{j,-1,1}],1], {0,0} ] ]
generateIndices[ 3 ] := Module[{i,j,k}, DeleteCases[ Flatten[Table[{i,j,k}, {i,-1,1},{j,-1,1},{k,-1,1}],1], {0,0,0} ] ]

translateMechanismPositions[positions_?MatrixQ , basis_ , {i_,j_,k_}] := 
	(basis[[1]] i + basis[[2]] j + basis[[3]] k + #) & /@ positions /; Length[positions[[1]]]>=3
translateMechanismPositions[positions_?MatrixQ , basis_ , {i_,j_}] := 
	(basis[[1]] i + basis[[2]] j + #) & /@ positions /; Length[positions[[1]]]>=2
translateMechanismPositions[positions_?MatrixQ , basis_ , {i_}] := 
	(basis[[1]] i + #) & /@ positions /; Length[positions[[1]]]>=1


scalePolygon[coords_ , shrinkBy_ ]:=
With[
{
	center = ConstantArray[Mean[coords],Length[coords]]
},
	center + Clip[1-shrinkBy,{0,1}] (coords-center)
]


ExtrudedPolygon[ { thickness1_?NumericQ, thickness2_?NumericQ } ][coords_] :=
With[{ extrusionVector = First @ NormalVector[coords,{{1,2,3}}]},
	With[{
		Face1 = coords + thickness1 ConstantArray[ extrusionVector, Length[coords] ],
		Face2 = coords + thickness2 ConstantArray[ extrusionVector , Length[coords] ]
		},
		Polyhedron @ Join[
			{
			Face1
			},
			MapThread[ Join[#1,Reverse[#2]]& , {Partition[Face1,2,1,1],Partition[Face2,2,1,1]} ],
			{
			Reverse @ Face2
			}
		]
	] 
] /; MatrixQ[coords] && Dimensions[coords][[2]] == 3

ExtrudedPolygon[ extrusionVector : {_?NumericQ, _?NumericQ, _?NumericQ} , { thickness1_?NumericQ, thickness2_?NumericQ } ][coords_] :=
	With[{
		Face1 = coords + thickness1 ConstantArray[ extrusionVector, Length[coords] ],
		Face2 = coords + thickness2 ConstantArray[extrusionVector , Length[coords] ]
		},
		Polyhedron @ Join[
			{
			Face1
			},
			MapThread[ Join[#1,Reverse[#2]]& , {Partition[Face1,2,1,1],Partition[Face2,2,1,1]} ],
			{
			Reverse @ Face2
			}
		]
	] /; MatrixQ[coords] && Dimensions[coords][[2]] == 3

ExtrudedPolygon[{thickness1_?NumericQ, thickness2_?NumericQ}][coords_] :=
	With[{ coords2 = PadRight[ coords, {Length[coords],3} ] },With[{
		Face1 = coords2 + thickness1 ConstantArray[{0,0,1} , Length[coords] ],
		Face2 = coords2 + thickness2 ConstantArray[{0,0,1} , Length[coords] ]
		},
		Polyhedron @ Join[
			{
			Face1
			},
			MapThread[ Join[#1,Reverse[#2]]& , {Partition[Face1,2,1,1],Partition[Face2,2,1,1]} ],
			{
			Reverse @ Face2
			}
		]
	]] /; MatrixQ[coords] && Dimensions[coords][[2]] == 2


shrinkPolygon[ pts_, widths_ ] := pts + Total @ MapIndexed[ shrinkPolygonSide[ pts, #2[[1]], #1 ]&, widths ]

shrinkPolygonSide[ pts_, v1_, width_ ] :=
Module[{n=Length[pts], v2, future, past, futureEdge, edge, pastEdge},
	v2=Mod[v1+1, n, 1]; future=Mod[v2+1, n, 1]; past = Mod[v1-1,n,1];
	edge=Normalize[ pts[[v2]] - pts[[v1]] ];
	futureEdge = Normalize[ pts[[future]] - pts[[v2]] ];
	pastEdge = Normalize[ pts[[past]] - pts[[v1]] ];
	
	RotateRight[Join[
		width*{
			pastEdge/Norm[ Cross[ pastEdge, edge ] ],
			futureEdge/Norm[ Cross[ futureEdge, edge ] ]
		},
		ConstantArray[{0,0,0},n-2]
	], v1-1]
]


Options[PlotConfigurationSpaceCurve] = Join[
	Options[MechanismTangentForm],
	{
	Oriented -> False,
	MaxSteps -> 10^3,
	MinSteps -> 3,
	PlotStyle->{}
	},
	FilterRules[Options[MechanismIsometricTrajectory],Except[{InitialPositions,StoppingCriteria}]],
	FilterRules[Options[ListPointPlot3D],Except[PlotStyle]]
];

curvePlot[pointList_, tol_ : 0.25] := With[
{
	partitionedLine = Select[Partition[pointList,2,1,1],Norm[#[[2]]-#[[1]]]<tol&]
},
	Line/@partitionedLine
]

smoothCurvePlot[pointList_, tol_ : 0.25] := With[
{
	partitionedLine = Select[Partition[N@pointList,2,1,1],Norm[#[[2]]-#[[1]]]<tol&],
	rules=Dispatch[Thread[pointList -> Range[Length[pointList]]]]
},
	BSplineCurve[pointList[[#]]]&/@ConnectedComponents[partitionedLine /. rules]
]

orientedCurvePlot[pointList_, arrowNumber_ : 5, tol_ : 0.25] := With[
{
	partitionedLine = Select[Partition[pointList,2,1,1],Norm[#[[2]]-#[[1]]]<tol&]
},
	{Line/@partitionedLine, Arrow/@Partition[partitionedLine,Floor[Length[partitionedLine]/arrowNumber]][[All,-1]]}
]

criticalPointMeasure[ expression_ , pos_] := Norm[expression /. N[PositionRules[pos]]]

computeSegment[m_, initialPositions_ , initialDirection_ , {minSteps_, maxSteps_}, stoppingExpression_ , options_] := 
Module[{ vars, rules , tangentField, start, scale},
	start = MechanismIsometricTrajectory[m, initialDirection, minSteps, Flatten[{InitialPositions -> initialPositions,FilterRules[options,Options[MechanismIsometricTrajectory]]}]];
	scale = criticalPointMeasure[ stoppingExpression , Last[start]];
	
	Join[
		Drop[start,-1],
		MechanismIsometricTrajectory[m, initialDirection, maxSteps - minSteps, Flatten[{
			InitialPositions -> Last[start], 
			StoppingCriteria -> (criticalPointMeasure[stoppingExpression, #]>= scale &),
			FilterRules[options,Options[MechanismIsometricTrajectory]]}]
		]
	]
]

plotCurveArguments[ m_ , initialPositions_ , initialDirection_ , minSteps_, maxSteps_ , orientedQ_] :=
	Check[
		If[Not[NumericCoordinatesQ[m,initialPositions]], Message[PlotConfigurationSpaceCurve::pos] ];
		If[Not[NumericCoordinatesQ[m,initialDirection]], Message[PlotConfigurationSpaceCurve::dir] ];
		If[Not[IntegerQ[minSteps]] || minSteps < 0, Message[PlotConfigurationSpaceCurve::minsteps] ];
		If[Not[IntegerQ[maxSteps]] || maxSteps <= minSteps, Message[PlotConfigurationSpaceCurve::maxsteps] ];
		If[Not[BooleanQ[orientedQ]], Message[PlotConfigurationSpaceCurve::oriented]];
		True,
		False
	]

PlotConfigurationSpaceCurve[ m_?MechanismQ , {initialPositions_, initialDirection_ } , displayFunction_ , opt : OptionsPattern[] ] :=
	Module[{
		vars, rules, tangentField, curve, dim, displayCurve
	},
	{vars, rules, tangentField} = MechanismTangentForm[m, FilterRules[{opt},Options[MechanismTangentForm]]];
	curve = computeSegment[m, initialPositions, initialDirection, {OptionValue[MinSteps],OptionValue[MaxSteps]}, tangentField /. rules,{opt}];
	displayCurve = displayFunction /@ curve;
	dim = Length[displayCurve[[1]]];

	Switch[dim,
		2, Show[
			ListPlot[{displayFunction[initialPositions]} , FilterRules[{opt},Options[ListPlot]]  ],
			Graphics[
				Flatten[{
					OptionValue[PlotStyle] /. Automatic->Nothing,
					If[OptionValue[Oriented], 
						orientedCurve[displayCurve], 
						curvePlot[displayCurve]
					]
				}]
			],
			PlotRange->OptionValue[PlotRange]
		],
		
		3, Show[
			ListPointPlot3D[{displayFunction[initialPositions]} , FilterRules[{opt},Options[ListPointPlot3D]] ],
			Graphics3D[
				Flatten[{
					OptionValue[PlotStyle] /. Automatic->Nothing,
					If[OptionValue[Oriented], 
						orientedCurve[displayCurve], 
						curvePlot[displayCurve]
					]
				}]
			],
			PlotRange->OptionValue[PlotRange]
		],
		_,
		displayCurve
	]
] /; plotCurveArguments[m, initialPositions, initialDirection, OptionValue[MinSteps], OptionValue[MaxSteps], OptionValue[Oriented]]


PlotConfigurationSpaceCurve::pos = "Positions must be numerical and correspond to the mechanism.";
PlotConfigurationSpaceCurve::dir = "Initial direction must be numerical and correspond to the mechanism.";
PlotConfigurationSpaceCurve::minsteps = "Minimum number of steps to take before terminating must be a positive integer.";
PlotConfigurationSpaceCurve::maxsteps = "Maximum number of steps to take before terminating must be a positive integer larger than the minimum number of steps.";
PlotConfigurationSpaceCurve::oriented = "Option Oriented must be Boolean.";


End[];

EndPackage[];


BeginPackage["Mechanisms`critical`"];


MechanismCriticalConfiguration::usage="MechanismCriticalConfiguration[ m , {s1, s2, ...} ] attempts to return a configuration on the critical surface of a mechanism.
The vector {s1, s2, ..} should have as many components as the number of edges and {s1, s2, ..} and {c s1, c s2, ...} return the same result.

Option \"FixedEdges\" allows you to specify a set of edges that are to have fixed length.";


MechanismTangentForm::usage="MechanismTangentForm[m] computes either a scalar (for generically 0D mechanisms), a vector tangent to the configuration space (for generically 1D mechanisms) or an antisymmetric matrix (for 2D).
Output is of the form { variable list , constraint list , tangent form }.";

MechanismCriticalSet::usage="MechanismCriticalSet[m] attempts to compute the critical configuration set of a generically 0D or 1D mechanism.
MechanismCriticalSet[m, constraints ] attempts to compute the cross-section of the critical configuration set with constraints.";
MechanismCriticalSetEquations::usage="MechanismCriticalSetEquations[m] returns equations to compute the critical configuration set of a generically 0D or 1D mechanism.
MechanismCriticalSet[m, constraints ] compute equations for the cross-section of the critical configuration set with constraints.";


MechanismCriticalDeterminant::usage = "MechanismCriticalDeterminant[ m ] evaluates det( R R^T ), where R is the constraint matrix. When this is zero, the mechanism is at a critical point.";

MechanismCriticalPoint::usage = "MechanismCriticalPoint[ m ] attempts to find a critical point for a given mechanism.
MechanismCriticalPoint[ m , v] attempts to find a point such that det(R R^T) = v for a given mechanism, where R is the constraint matrix.
Returns { det(R R^T) , positions } for the configuration found.

Use option InitialPositions to start search from a given set of positions. Use CellPattern to specify a subset of cells to constraint, and use Constraints to add additional constraints";

MechanismCriticalTrajectory::usage=
"MechanismCriticalTrajectory[\!\(\*
StyleBox[\"Mechanism\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]x1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]y1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)] creates a trajectory using \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) steps with Det(R R^T), where R is the constraint matrix, constant for a Mechanism starting in the
displacement direction \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]x1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[CapitalDelta]y1\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"..\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\).";

MechanismCriticalTangentVectors::usage="MechanismCriticalTangentVectors[m], MechanismCriticalTangentVectors[ Deformed[ m, positions ]] returns vertex displacements tangent to the manifold of constant critical value corresponding to the mechanism.";


Begin["`Private`"];

Needs["Mechanisms`"];
Needs["Mechanisms`geometry`"];
Needs["Mechanisms`rigidity`"];
Needs["Mechanisms`Origami`"];
Needs["Mechanisms`graphics`"];


criticalPointData[ m_ , coords_ , fixedEdges_ , selfstress_Symbol , constraints_ ] :=
Module[{
	linearConstraints = MechanismLinearConstraints[m, Constraints -> constraints],
	fixedLengthEdgesTMP = If[ fixedEdges===None, {}, MechanismEdges[m , fixedEdges]], fixedLengthEdges, selfstressSpecifiedEdges,
	stresses,
	positions,
	variables,
	criticalPotential, criticalArrays
},
	fixedLengthEdges = DeleteMissing @ fixedLengthEdgesTMP;
	If[ Length[fixedLengthEdges] + Length[coords] == Length[MechanismEdges[m]],
	
		selfstressSpecifiedEdges = Complement[Range[Length[MechanismEdges[m]]], fixedLengthEdges];
	
		(*construct the stress coordinates with variables inserted where specified and the user specified stresses everywhere else*)
		stresses = Fold[ #2[#1]&, coords , Insert @@@ Transpose[{Map[ selfstress, fixedLengthEdges], Sort[fixedLengthEdges]}] ];

		positions = VertexPosition[m] /. linearConstraints ;
		variables = DeleteDuplicates[ Cases[Flatten[positions], _VertexPosition, Infinity] ];

		criticalPotential = stresses . DisplacementLengthSquared[m , positions , MechanismEdges[m] ];

		Association[
			"positions" -> positions,
			"variables" -> variables,
			"potential" -> criticalPotential,
			"stresses" -> stresses,
			"fixedLength" -> Thread[DisplacementLengthSquared[m, MechanismEdges[m][[fixedLengthEdges]]] == DisplacementLengthSquared[m , positions , MechanismEdges[m][[fixedLengthEdges]]] ],
		
			"badEdges" -> Cases[fixedLengthEdgesTMP,_Missing][[All,2]] (*the last of bad edges*)
		],
		(*not enough coordinates here*)
		Message[MechanismCriticalConfiguration::dim, Length[MechanismEdges[m]] - Length[fixedLengthEdges]];
		$Failed
	]
]


Options[MechanismCriticalConfiguration] = {
	Constraints -> None,
	Method -> Automatic,
	"FixedEdges" -> None
};

MechanismCriticalConfiguration[ m_?MechanismQ, coord : _?VectorQ , opt : OptionsPattern[] ] :=
Module[{s, criticalPositions, criticalStresses, zeroLengthEdges},
	With[{ data = criticalPointData[ m , coord , OptionValue["FixedEdges"] , s, OptionValue[Constraints] ] },
		With[{
		(*this does the work*)
		solutions = internalCriticalConfiguration[ m, coord, data , OptionValue[Method] ]
		},
		
		Which[ 
			solutions === Indeterminate,
				Association[
					"SelfStress" -> data["stresses"],
					"Positions" -> Indeterminate,
					"Potential" -> data["potential"],
					"Variables" -> data["variables"]
				],
			Length[solutions] == 0,
				Association[
					"SelfStress" -> {},
					"Positions" -> {},
					"Potential" -> data["potential"],
					"Variables" -> data["variables"]
				],
			True,
				(*everything now is about writing out the information and provided errors and warnings*)
				criticalPositions = data["positions"] /. solutions;
				criticalStresses = data["stresses"] /. solutions;
				zeroLengthEdges = ZeroLengthEdgeQ[PlaceVertices[m,#]]& /@ criticalPositions;
	
				If[ Or @@ zeroLengthEdges,
					Message[MechanismCriticalConfiguration::zedge, Pick[ Range[Length[zeroLengthEdges]], zeroLengthEdges ]]
				];
		
				Association[
					"SelfStress" -> criticalStresses,
					"Positions" -> criticalPositions,
					"Potential" -> data["potential"],
					"Variables" -> data["variables"]
				]
		] /; solutions =!= $Failed
		] /; data =!= $Failed
	]
]

MechanismCriticalConfiguration::dim="The number of coordinates provided must be `1`.";
MechanismCriticalConfiguration::zedge = "Warning: Some edges have zero length in solutions `1`.";


(*Automatic*)
internalCriticalConfiguration[m_,coord_,data_Association, Automatic] := internalCriticalConfiguration[m,coord,data,"Direct"] /; TrueQ[data["fixedLength"]]

(*Automatic but some of the edges are held to have fixed length*)
internalCriticalConfiguration[m_,coord_,data_Association, Automatic] := internalCriticalConfiguration[m,coord,data,NSolve] /; Not[TrueQ[data["fixedLength"]]]


possibleDetZeroMatrixQ[ mat_?MatrixQ, tol_ ] := Det[mat] < tol /; Precision[mat] === MachinePrecision
possibleDetZeroMatrixQ[ mat_?MatrixQ, tol_ ] := PossibleZeroQ[ Det[mat] ]
possibleDetZeroMatrixQ[ __ ] := False

(*we can solve this right quick*)
internalCriticalConfiguration[ m_, coord_, data_, "Direct"] := internalCriticalConfiguration[m,coord,data,{"Direct"}]

internalCriticalConfiguration[ m_, coord_ , data_Association , {"Direct", opt : ___} ] :=
Module[{
	criticalArrays = CoefficientArrays[ data["potential"] , data["variables"] , Symmetric -> True ],
	nullspace
	},
	If[ possibleDetZeroMatrixQ[ criticalArrays[[3]], 10^(-10) ],
		(*Message[MechanismCriticalConfiguration::pseudo];*)
		With[{pseudoinverse = PseudoInverse[criticalArrays[[3]]]},
			If[ (# . #&)[criticalArrays[[3]] . pseudoinverse . criticalArrays[[2]] - criticalArrays[[2]]] < 10^(-10), 
				(*this is solvable with a pseudoinverse*)
				nullspace = NullSpace[criticalArrays[[3]] , FilterRules[{opt},Options[NullSpace]]];
				{
				(*the critical configuration*)
				Thread[ data["variables"] -> (
					- pseudoinverse . criticalArrays[[2]]/2 + Array[C,Length[nullspace]] . nullspace
					)]
				},

				(*this is not solvable*)
				{}
			]
		],
		
		(*it is a Morse function*)
		{ Thread[ data["variables"] -> - Inverse[criticalArrays[[3]]] . criticalArrays[[2]]/2 ] }
	]
] /; TrueQ[data["fixedLength"]]

internalCriticalConfiguration[ m_, coord_ , data_Association , {"Direct", opt : ___} ] := (
	Message[MechanismCriticalConfiguration::edge];
	$Failed
) /; Not[TrueQ[data["fixedLength"]]]

MechanismCriticalConfiguration::edge = "Method \"Direct\" not available with fixed length edges.";
MechanismCriticalConfiguration::pseudo = "Using Pseudoinverse to solve for critical point.";


(*NSolve method*)
internalCriticalConfiguration[ m_, coord_ , data_Association , NSolve ] :=
	internalCriticalConfiguration[m,coord,data, {NSolve, WorkingPrecision -> $MachinePrecision}]
	(*this fixes a Mathematica bug introduced into WorkingPrecision -> Automatic with version 10 and 13*)

internalCriticalConfiguration[ m_, coord_ , data_Association , {NSolve, opt___} ] :=
Module[{
	equations,
	variables,
	nsolveOptions = Join[FilterRules[{opt}, Options[NSolve] ],{WorkingPrecision -> $MachinePrecision}]
			(*this fixes a Mathematica bug introduced into WorkingPrecision -> Automatic with version 10 and 13*)
	 },

	equations = Flatten[{
		(*extremum equations*)
		Thread[D[ data["potential"] , {data["variables"]} ] == 0 ],
		(*length constraints*)
		If[ TrueQ[ data["fixedLength"] ], {} , data["fixedLength"] ]
	}];
	variables = Join[data["variables"], DeleteCases[data["stresses"],_?NumericQ ]];	
	NSolve[ equations , variables , Reals, nsolveOptions]
]


(*Solve method*)
internalCriticalConfiguration[ m_, coord_ , data_Association , Solve ] :=
Module[{
	equations,
	variables
	 },

	equations = Flatten[{
		Thread[D[ data["potential"] , {data["variables"]} ] == 0 ],
		If[ TrueQ[ data["fixedLength"] ], {} , data["fixedLength"] ]
	}];
	variables = Join[data["variables"], DeleteCases[data["stresses"],_?NumericQ ]];	
	Quiet[Solve[ equations , variables ], {Solve::ratnz, Solve::svars} ]
]

internalCriticalConfiguration[ m_, coord_ , data_Association , {Solve, opt___} ] :=
Module[{
	equations,
	variables,
	solveOptions = FilterRules[{opt}, Options[Solve] ]
	 },

	equations = Flatten[{
		Thread[D[ data["potential"] , {data["variables"]} ] == 0 ],
		If[ TrueQ[ data["fixedLength"] ], {} , data["fixedLength"] ]
	}];
	variables = Join[data["variables"], DeleteCases[data["stresses"],_?NumericQ ]];	
	Quiet[ Solve[ equations , variables , solveOptions] , {Solve::ratnz, Solve::svars} ]
]


(*FindRoot method*)
internalCriticalConfiguration[ m_, coord_ , data_Association , FindRoot ] :=
Module[{
	equations,
	variables,
	stresses = DeleteCases[data["stresses"],_?NumericQ ],
	initialPositions
	 },

	equations = Flatten[{
		Thread[D[ data["potential"] , {data["variables"]} ] == 0 ],
		If[ TrueQ[ data["fixedLength"] ], {} , data["fixedLength"] ]
	}];
	variables = Join[data["variables"], stresses];
	initialPositions = variables /. PositionRules[m] /. Thread[stresses -> 1.];

	{FindRoot[ equations , Transpose @ {variables , initialPositions } ]}
]

internalCriticalConfiguration[ m_, coord_ , data_Association , {FindRoot, opt___} ] :=
Module[{
	equations,
	variables,
	stresses = DeleteCases[data["stresses"],_?NumericQ ],
	initialPositions,
	rootOptions = FilterRules[{opt}, Options[FindRoot] ],
	initialGuess = "InitialStresses" /. Flatten[{opt}]
},
	equations = Flatten[{
		Thread[D[ data["potential"] , {data["variables"]} ] == 0 ],
		If[ TrueQ[ data["fixedLength"] ], {} , data["fixedLength"] ]
	}];
	variables = Join[data["variables"], stresses];
	
	initialPositions = Which[ 
		VectorQ[ initialGuess, NumericQ] && Length[initialGuess] == Length[stresses],
			{variables /. PositionRules[m] /. Thread[stresses -> initialGuess ]},
		MatrixQ[ initialGuess, NumericQ ] && Length[initialGuess[[1]]] == Length[stresses],
			(variables /. PositionRules[m] /. Thread[stresses -> #] &) /@ initialGuess,
		initialGuess === "InitialStresses",
			{variables /. PositionRules[m] /. Thread[stresses -> 1.]}, (*no guess for stresses specified*)
		True,
			Message[MechanismCriticalConfiguration::stress, initialGuess, Length[stresses] ];
			{variables /. PositionRules[m] /. Thread[stresses -> 1.]} (*bad guess specified*)
	];
	
	FindRoot[ equations , Evaluate[Transpose[{variables , # }]] , Evaluate[Sequence @@ rootOptions] ]& /@ initialPositions
]

MechanismCriticalConfiguration::stresses = "Each initial guess for stresses `1` should be a list of numerical values with length `2`";


internalCriticalConfiguration[ m_, coord_ , data_ , method_]:=
	(If[ ListQ[method], Message[MechanismCriticalConfiguration::meth, method[[1]]] , Message[MechanismCriticalConfiguration::meth, method] ];
	$Failed)

MechanismCriticalConfiguration::meth="Method `1` is not Automatic,\"Direct\", NSolve, Solve, or FindRoot";


Options[MechanismTangentForm]={Constraints -> None, CellPattern -> _ };
MechanismTangentForm[ m_?MechanismQ , opt : OptionsPattern[] ] :=
Module[{
	constraints,
	pinnedVertexLocations = MechanismLinearConstraints[m, Constraints -> OptionValue[Constraints]],
	equations,
	variables,
	jacobian, variableLength, i,j
},
	equations = MechanismConstraintMap[m, opt, ReduceLinearConstraints->False] /. Dispatch[pinnedVertexLocations];
	(
		(*eliminate the trivial constraints after solving the linear constraints explicitly*)
		constraints = Pick[ equations , Not /@ PossibleZeroQ /@ equations ];
		(*what variables are left*)
		variables = Cases[Flatten[VertexPosition[m]] /. pinnedVertexLocations , VertexPosition[_,_]];
		variableLength = Length[variables];
		jacobian = D[constraints,{variables}];
		
		{
		variables,
		pinnedVertexLocations,
		Switch[ variableLength-Length[constraints],
			0, Det[ jacobian ],
			1, Cross @@ jacobian,
			2, Table[Det @ Join[{UnitVector[variableLength,i],UnitVector[variableLength,j]}, jacobian],{i,1,variableLength},{j,1,variableLength}],
			_, Message[MechanismTangentForm::dim, variableLength - Length[constraints]]; D[constraints,{variables}]
		]/Factorial[Length[constraints]]
		}

	) /; Head[equations] =!= MechanismConstraintMap (*catch an error*)
]

MechanismTangentForm::dim = "Current version cannot compute tangent form for dimensions other than 0 or 1 or 2. Dimension of configuration space is nominally `1`. Returning reduced Jacobian instead.";


Options[MechanismCriticalSet] = {
	CellPattern -> _,
	Constraints -> {}
};

MechanismCriticalSet[ m_?MechanismQ , extraConstraints : Except[_Rule] : {}, opt : OptionsPattern[]] := 
Module[
{
	tf, vars,
	pinnedVertexLocations,
	soln, positions, constraintEquations,
	extraVariables
},
	{vars,pinnedVertexLocations,tf}=Simplify[MechanismTangentForm[m, Sequence @@ FilterRules[{opt},Options[MechanismTangentForm] ]]];
	soln = Simplify[Quiet[Solve[tf==0,vars],Solve::svars]];
	positions = VertexPosition[m] /. pinnedVertexLocations;

	constraintEquations = extraConstraints /. pinnedVertexLocations;
	(*are there any extra variables declared?*)
	extraVariables = toVariables[constraintEquations];

	If[Length[soln]>0,
		With[{ fullVariableSet = DeleteDuplicates[Flatten[{vars,extraVariables}]] },
		DeleteDuplicates[
			Flatten[
				Map[(*for each entry in soln, try to solve the extra constraints*)
					With[{ constrainedSolution = Quiet[Solve[Simplify[constraintEquations /. #]==0, fullVariableSet],Solve::svars]},
						If[ Length[constrainedSolution] > 0,
							positions /. # /. constrainedSolution, 
							{{}}
						]
					] &,
					soln
			],1]
		]]
		,
		(*there are no critical points at all*)
		{}
	]
]


Options[MechanismCriticalSetEquations] = {
	CellPattern -> _,
	Constraints -> {}
};
MechanismCriticalSetEquations[m_?MechanismQ, extraConstraints : Except[_Rule] : {}, opt : OptionsPattern[]] :=
Module[{vars,pinnedLocations,tf},
	{vars,pinnedLocations,tf} = MechanismTangentForm[m,opt];
	Join[ tf , extraConstraints ] /. pinnedLocations
]


toVariables[expr_] := DeleteDuplicates[Cases[expr,_Symbol|_VertexPosition,All]]


Options[criticalGradient] = Options[MechanismConstraintMatrix];

criticalGradient[ m_?MechanismQ , opt : OptionsPattern[]] := 
With[{
	names = standardVariableNames[m] ,
	mat = (# . Transpose[#] &)[MechanismConstraintMatrix[ Deformed[m, VertexPosition[m]] , ReduceLinearConstraints -> False, opt]]
},
	With[ { 
		f1 = Compile @@ { Flatten[names[[1]]], renameVertexVariables[ names[[1]], Normal[mat] ] },
		f2 = Compile @@ { Flatten[names[[1]]], renameVertexVariables[ names[[1]], D[Normal[mat],#]& /@ Flatten[VertexPosition[m]] ] }
	  },
	{f1, f2}
	]
]

detEval[ {f1_,f2_}][z_?(VectorQ[#,NumericQ]&)] := Det[f1 @@ z]
gradEval[ {f1_,f2_}][z_?(VectorQ[#,NumericQ]&)] := With[ { x = Adjugate[ f1 @@ z ] , y = f2 @@ z }, Tr[ x . #]& /@ y ]

detEval[ {f1_,f2_}, Automatic][z_?(VectorQ[#,NumericQ]&)] := Det[f1 @@ z]
gradEval[ {f1_,f2_}, Automatic][z_?(VectorQ[#,NumericQ]&)] := With[ { x = Adjugate[ f1 @@ z ] , y = f2 @@ z }, Tr[ x . #]& /@ y ]

detEval[ {f1_,f2_}, n_?NumericQ ][z_?(VectorQ[#,NumericQ]&)] := (Det[ f1 @@ z ] - n)^2/2
gradEval[ {f1_,f2_}, n_?NumericQ ][ z_?(VectorQ[#,NumericQ]&) ] := With[ {det = f1 @@ z }, With[{x = Adjugate[ det ] , y = f2 @@ z}, (Det[det]-n) (Tr[ x . #]& /@ y) ]]


criticalSetConstraintFunction[ criticalGradInfo_ , otherConstraints_ ][positions_] := 
	With[{ gradient = Normalize @ gradEval[criticalGradInfo][Flatten[positions]] },
		Join[{gradient} , otherConstraints ]
	]


criticalSetTangents[ criticalGradInfo_ , otherConstraints_ ][positions_] := Chop @ NullSpace @ criticalSetConstraintFunction[criticalGradInfo , otherConstraints][positions]


Options[ MechanismCriticalTrajectory ] := {
	(*any constraints added by the user*)
	Constraints -> None,
	CellPattern -> _,
	(*positions from which to start the walk*)
	InitialPositions -> Automatic,
	Method -> {"Minimization", MaxIterations -> 10^4},
	Tolerance -> 10^(-8),
	StepSize -> 0.1
};


MechanismCriticalTrajectory[m_?MechanismQ, direction_, steps_?stepsQ , opt : OptionsPattern[] ] :=
With[{
	initialPositions = If[ OptionValue[InitialPositions] === Automatic, m["VertexCoordinates"], OptionValue[InitialPositions] ]
},
	With[{
		res = mechanismCriticalTrajectoryInternal[m, 
			(*initial positions and direction*)
			initialPositions, direction, 
			(*data to decide on how to choose step size*)
			{steps, OptionValue[StepSize], OptionValue[Tolerance]}, 
			(*what method to use to take a step*)
			Flatten[{OptionValue[Method]}],
			mobileVariables[ m, MechanismConstraintMap[m, Constraints -> OptionValue[Constraints] , CellPattern -> OptionValue[CellPattern], ReduceLinearConstraints -> False] ],
			{opt}
		]
	},
		ToPackedArray[N[res]] /; Head[res] =!= mechanismCriticalTrajectoryInternal
	] /; And[ positions2Q[m, initialPositions] , displacements2Q[m, direction] , tolerance2Q[ OptionValue[Tolerance] ] ]
]

steps2Q[ steps_Integer?(#>0&) ] := True
steps2Q[ steps_ ] := (Message[MechanismCriticalTrajectory::steps]; False)

tolerance2Q[ tol_?(NumericQ[#]&&#>=0&) ] := True
tolerance2Q[ tol_ ] := (Message[MechanismCriticalTrajectory::tol]; False)

positions2Q[ m_ , positions_ ] := If[ NumericCoordinatesQ[m,positions], True, Message[MechanismCriticalTrajectory::pos,positions]; False]
displacements2Q[ m_ , positions_ ] := If[ NumericCoordinatesQ[m,positions], True, Message[MechanismCriticalTrajectory::disp,positions]; False]

MechanismCriticalTrajectory::steps="Number of steps is not a positive integer.";
MechanismCriticalTrajectory::tol = "Tolerance should be a positive real number.";
MechanismCriticalTrajectory::pos = "Initial positions `1` should be numerical and correspond to Mechanism..";
MechanismCriticalTrajectory::disp = "Initial displacements `1` should be numerical and correspond to Mechanism..";
MechanismCriticalTrajectory::sc = "Option StoppingCriteria is not a function or the keyword None.";
MechanismCriticalTrajectory::sc2 = "Function provided to StoppingCriteria does not return True or False.";


mechanismCriticalTrajectoryInternal[ m_, 
	initialPositions_, direction_, 
	{steps_, stepsize_, tolerance_}, 
	{method_ , methodSpec___} , 
	constraintData_,
	options_ ] :=
Module[ {detval, grad}, With[
{
	minimizationOptions = FilterRules[ FilterRules[ {methodSpec}, Options[FindMinimum] ], Except[Gradient] ],
	nullspaceOptions = FilterRules[ {methodSpec}, Options[NullSpace] ],
	(*normalize the initial direction*)
		normalizedDirection = direction/Sqrt[Flatten[direction] . Flatten[direction] ],
	(*function to determine local constraints*)
		constraintMatrixFunc = mechanismConstraintMatrixFunction[ m , FilterRules[ options, Options[mechanismConstraintMatrixFunction] ]],
	(* data needed to compute the energy and gradient *)
		criticalEnergy = criticalGradient[m],
	(*rest of energy to minimize*)
		energy = MechanismEnergy[m , ReduceLinearConstraints -> False, 
						Sequence @@ FilterRules[FilterRules[ options , Options[MechanismEnergy]], Except[ReduceLinearConstraints]] ],
	positions = Flatten[VertexPosition[m]],
	dim = Length[initialPositions[[1]]]
},
	detval = detEval[criticalEnergy][Flatten @ m["VertexCoordinates"]];
	grad = D[ energy , {positions}];

	Map[ Partition[# , dim]&,

		DeleteCases[
			FoldList[
				constrainedTrajectoryStep[ {method, stepsize, tolerance}, m, 
					#1, #2, 
					{ criticalSetConstraintFunction[criticalEnergy, constraintMatrixFunc @@ Flatten[#1[[1]]] ][Flatten[#1[[1]]]] , nullspaceOptions }, 
					{detEval[criticalEnergy,detval][positions]+energy , {positions,positions}, 
							Join[ {Gradient :> (gradEval[criticalEnergy,detval][positions] + grad)} , minimizationOptions]
					} 
				] &,
				{Flatten@initialPositions,normalizedDirection},
				Range[steps]
			][[All,1]],
			$Failed
		]
	]
]]


(*
computes the determinant of R R^T, where R is the constraint matrix.

The null space of this matrix gives the self stresses and so its determinant vanishes on the critical surface.
*)
Options[MechanismCriticalDeterminant] = FilterRules[ Options[MechanismConstraintMatrix], Except[ReduceLinearConstraints] ];

MechanismCriticalDeterminant[ m_?MechanismQ , opt : OptionsPattern[] ] := 
With[{
	mat = (# . Transpose[#] &)[MechanismConstraintMatrix[ Deformed[m, VertexPosition[m]] , ReduceLinearConstraints -> False, opt]]
	},
	Det[Normal[mat] /. PositionRules[m["VertexCoordinates"]]]
]

MechanismCriticalDeterminant[ Deformed[ m_?MechanismQ , positions_ ], opt : OptionsPattern[] ] := 
With[
	{
	mat = (# . Transpose[#] &)[MechanismConstraintMatrix[ Deformed[m, VertexPosition[m]] , ReduceLinearConstraints -> False, opt]]
	},
	Det[Normal[mat] /. PositionRules[positions]]
] /; VertexCoordinates[m,positions]

MechanismCriticalDeterminant[ Deformed[ m_?MechanismQ , positions_ ], opt : OptionsPattern[] ] := 
With[
	{
	mat = (# . Transpose[#] &)[MechanismConstraintMatrix[ Deformed[m, VertexPosition[m]] , ReduceLinearConstraints -> False, opt]]
	},
	Det /@ (Normal[mat] /. PositionRules[positions])
] /; VertexCoordinateListQ[m,positions]

MechanismCriticalDeterminant[ Deformed[ m_?MechanismQ , positions_ ], opt : OptionsPattern[] ] := "nothing" /; Message[MechanismCriticalValue::pos,positions]

MechanismCriticalDeterminant::pos = "Positions `1` do not conform to mechanism.";


Options[MechanismCriticalPoint] = Join[ 
	{InitialPositions -> Automatic , CellPattern -> _, Constraints -> None, AddedEnergy -> 0} , 
	Options[FindMinimum]
	];

MechanismCriticalPoint[ m_?MechanismQ, n : _?NumericQ : Automatic, opt : OptionsPattern[] ] :=
Module[{
	initialPositions = criticalPointInitial[ m["VertexCoordinates"], OptionValue[InitialPositions] ],
	positions,
	linear = MechanismLinearConstraints[m, Constraints -> OptionValue[Constraints], CellPattern -> OptionValue[CellPattern] ],
	(*this is potentially inefficient because we are basically doing this more than once.*)
	inequalities,

	variables, namedVariables, mobileVertices,
			
	energy, gradient,
	
	criticalFunctions = criticalGradient[ m ],
	argument,
	
	solution, nPositions
},
	inequalities = DeleteCases[ processConstraintEquations[VertexPosition[m], OptionValue[Constraints]]["inequalities"] /. linear, True ];
	If[ Length[Cases[inequalities, False]] > 0, 
		Message[MechanismCriticalPoint::ineq];
		inequalities = DeleteCases[ inequalities , False ]
	];

	positions = VertexPosition[m] /. linear;
	variables = Cases[ Flatten[positions], _VertexPosition ];
	namedVariables = Unique[]& /@ variables;
	mobileVertices = Pick[ Range[Length[Flatten[positions]]], MatchQ[#,_VertexPosition]& /@ Flatten[positions]];

	(*construct the additional mechanism energy and its gradient*)	
	energy = MechanismEnergy[ m , 
		Constraints -> OptionValue[Constraints] ,
		CellPattern -> OptionValue[CellPattern] ] + Mechanisms`geometry`Private`MechanismGeometricExpression[m,OptionValue[AddedEnergy]] /. PositionRules[ positions ] /. Thread[ variables -> namedVariables ];
	gradient = D[ energy , {namedVariables} ];
	argument = Flatten[positions] /. Thread[variables -> namedVariables];

	solution = If[Length[inequalities]==0,
		 FindMinimum @@ {
			detEval[criticalFunctions, n][ argument ] + energy,
			Transpose[ {namedVariables , variables /. PositionRules[ initialPositions ]}],
			Gradient :> gradEval[criticalFunctions, n][ argument ][[ mobileVertices ]] + gradient,
			Sequence @@ FilterRules[ FilterRules[ {opt}, Options[FindMinimum]], Except[Gradient] ]
		},
		 FindMinimum @@ {
			Flatten[{detEval[criticalFunctions, n][ argument ] + energy, inequalities /. Thread[variables -> namedVariables]}],
			Transpose[ {namedVariables , variables /. PositionRules[ initialPositions ]}],
			Gradient :> gradEval[criticalFunctions, n][ argument ][[ mobileVertices ]] + gradient,
			Sequence @@ FilterRules[ FilterRules[ {opt}, Options[FindMinimum]], Except[Gradient] ]
		}		
	];

	If[ ListQ[ solution ], 
		nPositions = positions /. Thread[variables -> namedVariables] /. solution[[2]] ;
		{detEval[criticalFunctions][Flatten@nPositions] , nPositions },
		$Failed
	]
]

criticalPointInitial[ coordinates_ , Automatic ] := coordinates
criticalPointInitial[ coordinates_ , positions_?NumericCoordinatesQ ] := positions /; Dimensions[ coordinates ] == Dimensions[ positions ]
criticalPointInitial[ coordinates_, positions_ ] := (Message[MechanismCriticalPoints::pos, positions ]; coordinates)

MechanismCriticalPoint::pos = "Positions `1` do not match mechanism.";
MechanismCriticalPoint::ineq = "Some inequalities are strictly False.";


(*
computes the tangent vectors to the surface of constant determinant of R R^T, where R is the constraint matrix.
*)
Options[MechanismCriticalTangentVectors] = FilterRules[ Options[MechanismConstraintMatrix], Except[ReduceLinearConstraints] ] ;

MechanismCriticalTangentVectors[ m_?MechanismQ , opt : OptionsPattern[] ] := 
With[{criticalFunc = criticalGradient[m] },
	Partition[# , m["EmbeddingDimension"] ]& /@ criticalSetTangents[ criticalFunc , MechanismConstraintMatrix[ m , ReduceLinearConstraints->False, opt] ][Flatten @ m["VertexCoordinates"]]
]
MechanismCriticalTangentVectors[ Deformed[ m_?MechanismQ , positions_ ], opt : OptionsPattern[] ] := 
With[{criticalFunc = criticalGradient[m] },
	Partition[# , m["EmbeddingDimension"] ]& /@ criticalSetTangents[ 
			criticalFunc , 
			MechanismConstraintMatrix[ Deformed[m,positions] , ReduceLinearConstraints->False, opt] ][
		Flatten @ positions]
] /; VertexCoordinatesQ[m,positions]

MechanismCriticalTangentVectors[ Deformed[ m_?MechanismQ , positions_ ], opt : OptionsPattern[] ] := "nothing" /; Message[MechanismCriticalTangentVectors::pos,positions]

MechanismCriticalTangentVectors::pos = "Positions `1` do not match mechanism.";


End[];

EndPackage[];
